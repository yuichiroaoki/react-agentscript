void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
  void 0 === Number.isInteger &&
    (Number.isInteger = function (t) {
      return "number" == typeof t && isFinite(t) && Math.floor(t) === t;
    }),
  void 0 === Math.sign &&
    (Math.sign = function (t) {
      return t < 0 ? -1 : t > 0 ? 1 : +t;
    }),
  "name" in Function.prototype == !1 &&
    Object.defineProperty(Function.prototype, "name", {
      get: function () {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
      },
    }),
  void 0 === Object.assign &&
    (Object.assign = function (t) {
      if (null == t)
        throw new TypeError("Cannot convert undefined or null to object");
      const e = Object(t);
      for (let t = 1; t < arguments.length; t++) {
        const n = arguments[t];
        if (null != n)
          for (const t in n)
            Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
      }
      return e;
    });
const t = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  e = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
function n() {}
Object.assign(n.prototype, {
  addEventListener: function (t, e) {
    void 0 === this._listeners && (this._listeners = {});
    const n = this._listeners;
    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
  },
  hasEventListener: function (t, e) {
    if (void 0 === this._listeners) return !1;
    const n = this._listeners;
    return void 0 !== n[t] && -1 !== n[t].indexOf(e);
  },
  removeEventListener: function (t, e) {
    if (void 0 === this._listeners) return;
    const n = this._listeners[t];
    if (void 0 !== n) {
      const t = n.indexOf(e);
      -1 !== t && n.splice(t, 1);
    }
  },
  dispatchEvent: function (t) {
    if (void 0 === this._listeners) return;
    const e = this._listeners[t.type];
    if (void 0 !== e) {
      t.target = this;
      const n = e.slice(0);
      for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
    }
  },
});
const i = [];
for (let t = 0; t < 256; t++) i[t] = (t < 16 ? "0" : "") + t.toString(16);
let r = 1234567;
const o = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    const t = (4294967295 * Math.random()) | 0,
      e = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0,
      r = (4294967295 * Math.random()) | 0;
    return (
      i[255 & t] +
      i[(t >> 8) & 255] +
      i[(t >> 16) & 255] +
      i[(t >> 24) & 255] +
      "-" +
      i[255 & e] +
      i[(e >> 8) & 255] +
      "-" +
      i[((e >> 16) & 15) | 64] +
      i[(e >> 24) & 255] +
      "-" +
      i[(63 & n) | 128] +
      i[(n >> 8) & 255] +
      "-" +
      i[(n >> 16) & 255] +
      i[(n >> 24) & 255] +
      i[255 & r] +
      i[(r >> 8) & 255] +
      i[(r >> 16) & 255] +
      i[(r >> 24) & 255]
    ).toUpperCase();
  },
  clamp: function (t, e, n) {
    return Math.max(e, Math.min(n, t));
  },
  euclideanModulo: function (t, e) {
    return ((t % e) + e) % e;
  },
  mapLinear: function (t, e, n, i, r) {
    return i + ((t - e) * (r - i)) / (n - e);
  },
  lerp: function (t, e, n) {
    return (1 - n) * t + n * e;
  },
  smoothstep: function (t, e, n) {
    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
  },
  smootherstep: function (t, e, n) {
    return t <= e
      ? 0
      : t >= n
      ? 1
      : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
  },
  randInt: function (t, e) {
    return t + Math.floor(Math.random() * (e - t + 1));
  },
  randFloat: function (t, e) {
    return t + Math.random() * (e - t);
  },
  randFloatSpread: function (t) {
    return t * (0.5 - Math.random());
  },
  seededRandom: function (t) {
    return (
      void 0 !== t && (r = t % 2147483647),
      (r = (16807 * r) % 2147483647),
      (r - 1) / 2147483646
    );
  },
  degToRad: function (t) {
    return t * o.DEG2RAD;
  },
  radToDeg: function (t) {
    return t * o.RAD2DEG;
  },
  isPowerOfTwo: function (t) {
    return 0 == (t & (t - 1)) && 0 !== t;
  },
  ceilPowerOfTwo: function (t) {
    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
  },
  floorPowerOfTwo: function (t) {
    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (t, e, n, i, r) {
    const o = Math.cos,
      s = Math.sin,
      a = o(n / 2),
      c = s(n / 2),
      l = o((e + i) / 2),
      h = s((e + i) / 2),
      u = o((e - i) / 2),
      d = s((e - i) / 2),
      p = o((i - e) / 2),
      f = s((i - e) / 2);
    switch (r) {
      case "XYX":
        t.set(a * h, c * u, c * d, a * l);
        break;
      case "YZY":
        t.set(c * d, a * h, c * u, a * l);
        break;
      case "ZXZ":
        t.set(c * u, c * d, a * h, a * l);
        break;
      case "XZX":
        t.set(a * h, c * f, c * p, a * l);
        break;
      case "YXY":
        t.set(c * p, a * h, c * f, a * l);
        break;
      case "ZYZ":
        t.set(c * f, c * p, a * h, a * l);
        break;
      default:
        console.warn(
          "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
            r
        );
    }
  },
};
class s {
  constructor(t = 0, e = 0) {
    Object.defineProperty(this, "isVector2", { value: !0 }),
      (this.x = t),
      (this.y = e);
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this;
  }
  add(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), this);
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this;
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this;
  }
  sub(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), this);
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this;
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this;
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = t.elements;
    return (
      (this.x = i[0] * e + i[3] * n + i[6]),
      (this.y = i[1] * e + i[4] * n + i[7]),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y;
    return e * e + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e) {
    return void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this;
  }
  toArray(t, e) {
    return (
      void 0 === t && (t = []),
      void 0 === e && (e = 0),
      (t[e] = this.x),
      (t[e + 1] = this.y),
      t
    );
  }
  fromBufferAttribute(t, e, n) {
    return (
      void 0 !== n &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      this
    );
  }
  rotateAround(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      r = this.x - t.x,
      o = this.y - t.y;
    return (this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
}
class a {
  constructor() {
    Object.defineProperty(this, "isMatrix3", { value: !0 }),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(t, e, n, i, r, o, s, a, c) {
    const l = this.elements;
    return (
      (l[0] = t),
      (l[1] = i),
      (l[2] = s),
      (l[3] = e),
      (l[4] = r),
      (l[5] = a),
      (l[6] = n),
      (l[7] = o),
      (l[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    );
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return (
      this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      r = this.elements,
      o = n[0],
      s = n[3],
      a = n[6],
      c = n[1],
      l = n[4],
      h = n[7],
      u = n[2],
      d = n[5],
      p = n[8],
      f = i[0],
      m = i[3],
      g = i[6],
      v = i[1],
      y = i[4],
      x = i[7],
      b = i[2],
      _ = i[5],
      w = i[8];
    return (
      (r[0] = o * f + s * v + a * b),
      (r[3] = o * m + s * y + a * _),
      (r[6] = o * g + s * x + a * w),
      (r[1] = c * f + l * v + h * b),
      (r[4] = c * m + l * y + h * _),
      (r[7] = c * g + l * x + h * w),
      (r[2] = u * f + d * v + p * b),
      (r[5] = u * m + d * y + p * _),
      (r[8] = u * g + d * x + p * w),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      r = t[3],
      o = t[4],
      s = t[5],
      a = t[6],
      c = t[7],
      l = t[8];
    return (
      e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a
    );
  }
  getInverse(t, e) {
    void 0 !== e &&
      console.warn(
        "THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate."
      );
    const n = t.elements,
      i = this.elements,
      r = n[0],
      o = n[1],
      s = n[2],
      a = n[3],
      c = n[4],
      l = n[5],
      h = n[6],
      u = n[7],
      d = n[8],
      p = d * c - l * u,
      f = l * h - d * a,
      m = u * a - c * h,
      g = r * p + o * f + s * m;
    if (0 === g) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const v = 1 / g;
    return (
      (i[0] = p * v),
      (i[1] = (s * u - d * o) * v),
      (i[2] = (l * o - s * c) * v),
      (i[3] = f * v),
      (i[4] = (d * r - s * h) * v),
      (i[5] = (s * a - l * r) * v),
      (i[6] = m * v),
      (i[7] = (o * h - u * r) * v),
      (i[8] = (c * r - o * a) * v),
      this
    );
  }
  transpose() {
    let t;
    const e = this.elements;
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    );
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).getInverse(this).transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    );
  }
  setUvTransform(t, e, n, i, r, o, s) {
    const a = Math.cos(r),
      c = Math.sin(r);
    this.set(
      n * a,
      n * c,
      -n * (a * o + c * s) + o + t,
      -i * c,
      i * a,
      -i * (-c * o + a * s) + s + e,
      0,
      0,
      1
    );
  }
  scale(t, e) {
    const n = this.elements;
    return (
      (n[0] *= t),
      (n[3] *= t),
      (n[6] *= t),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      this
    );
  }
  rotate(t) {
    const e = Math.cos(t),
      n = Math.sin(t),
      i = this.elements,
      r = i[0],
      o = i[3],
      s = i[6],
      a = i[1],
      c = i[4],
      l = i[7];
    return (
      (i[0] = e * r + n * a),
      (i[3] = e * o + n * c),
      (i[6] = e * s + n * l),
      (i[1] = -n * r + e * a),
      (i[4] = -n * o + e * c),
      (i[7] = -n * s + e * l),
      this
    );
  }
  translate(t, e) {
    const n = this.elements;
    return (
      (n[0] += t * n[2]),
      (n[3] += t * n[5]),
      (n[6] += t * n[8]),
      (n[1] += e * n[2]),
      (n[4] += e * n[5]),
      (n[7] += e * n[8]),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      n = t.elements;
    for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
    return !0;
  }
  fromArray(t, e) {
    void 0 === e && (e = 0);
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
    return this;
  }
  toArray(t, e) {
    void 0 === t && (t = []), void 0 === e && (e = 0);
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    );
  }
}
let c;
const l = {
  getDataURL: function (t) {
    if (/^data:/i.test(t.src)) return t.src;
    if ("undefined" == typeof HTMLCanvasElement) return t.src;
    let e;
    if (t instanceof HTMLCanvasElement) e = t;
    else {
      void 0 === c &&
        (c = document.createElementNS(
          "http://www.w3.org/1999/xhtml",
          "canvas"
        )),
        (c.width = t.width),
        (c.height = t.height);
      const n = c.getContext("2d");
      t instanceof ImageData
        ? n.putImageData(t, 0, 0)
        : n.drawImage(t, 0, 0, t.width, t.height),
        (e = c);
    }
    return e.width > 2048 || e.height > 2048
      ? e.toDataURL("image/jpeg", 0.6)
      : e.toDataURL("image/png");
  },
};
let h = 0;
function u(t, e, n, i, r, c, l, d, p, f) {
  Object.defineProperty(this, "id", { value: h++ }),
    (this.uuid = o.generateUUID()),
    (this.name = ""),
    (this.image = void 0 !== t ? t : u.DEFAULT_IMAGE),
    (this.mipmaps = []),
    (this.mapping = void 0 !== e ? e : u.DEFAULT_MAPPING),
    (this.wrapS = void 0 !== n ? n : 1001),
    (this.wrapT = void 0 !== i ? i : 1001),
    (this.magFilter = void 0 !== r ? r : 1006),
    (this.minFilter = void 0 !== c ? c : 1008),
    (this.anisotropy = void 0 !== p ? p : 1),
    (this.format = void 0 !== l ? l : 1023),
    (this.internalFormat = null),
    (this.type = void 0 !== d ? d : 1009),
    (this.offset = new s(0, 0)),
    (this.repeat = new s(1, 1)),
    (this.center = new s(0, 0)),
    (this.rotation = 0),
    (this.matrixAutoUpdate = !0),
    (this.matrix = new a()),
    (this.generateMipmaps = !0),
    (this.premultiplyAlpha = !1),
    (this.flipY = !0),
    (this.unpackAlignment = 4),
    (this.encoding = void 0 !== f ? f : 3e3),
    (this.version = 0),
    (this.onUpdate = null);
}
(u.DEFAULT_IMAGE = void 0),
  (u.DEFAULT_MAPPING = 300),
  (u.prototype = Object.assign(Object.create(n.prototype), {
    constructor: u,
    isTexture: !0,
    updateMatrix: function () {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return (
        (this.name = t.name),
        (this.image = t.image),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.encoding = t.encoding),
        this
      );
    },
    toJSON: function (t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      if (void 0 !== this.image) {
        const i = this.image;
        if (
          (void 0 === i.uuid && (i.uuid = o.generateUUID()),
          !e && void 0 === t.images[i.uuid])
        ) {
          let e;
          if (Array.isArray(i)) {
            e = [];
            for (let t = 0, n = i.length; t < n; t++)
              e.push(l.getDataURL(i[t]));
          } else e = l.getDataURL(i);
          t.images[i.uuid] = { uuid: i.uuid, url: e };
        }
        n.image = i.uuid;
      }
      return e || (t.textures[this.uuid] = n), n;
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function (t) {
      if (300 !== this.mapping) return t;
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case 1e3:
            t.x = t.x - Math.floor(t.x);
            break;
          case 1001:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case 1002:
            1 === Math.abs(Math.floor(t.x) % 2)
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x));
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case 1e3:
            t.y = t.y - Math.floor(t.y);
            break;
          case 1001:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case 1002:
            1 === Math.abs(Math.floor(t.y) % 2)
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y));
        }
      return this.flipY && (t.y = 1 - t.y), t;
    },
  })),
  Object.defineProperty(u.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++;
    },
  });
class d {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    Object.defineProperty(this, "isVector4", { value: !0 }),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n, i) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setW(t) {
    return (this.w = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = void 0 !== t.w ? t.w : 1),
      this
    );
  }
  add(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x),
        (this.y += t.y),
        (this.z += t.z),
        (this.w += t.w),
        this);
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    );
  }
  addScaledVector(t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    );
  }
  sub(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x),
        (this.y -= t.y),
        (this.z -= t.z),
        (this.w -= t.w),
        this);
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    );
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      o = t.elements;
    return (
      (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
      (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
      (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
      (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
      this
    );
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, r;
    const o = 0.01,
      s = 0.1,
      a = t.elements,
      c = a[0],
      l = a[4],
      h = a[8],
      u = a[1],
      d = a[5],
      p = a[9],
      f = a[2],
      m = a[6],
      g = a[10];
    if (Math.abs(l - u) < o && Math.abs(h - f) < o && Math.abs(p - m) < o) {
      if (
        Math.abs(l + u) < s &&
        Math.abs(h + f) < s &&
        Math.abs(p + m) < s &&
        Math.abs(c + d + g - 3) < s
      )
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const t = (c + 1) / 2,
        a = (d + 1) / 2,
        v = (g + 1) / 2,
        y = (l + u) / 4,
        x = (h + f) / 4,
        b = (p + m) / 4;
      return (
        t > a && t > v
          ? t < o
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))
          : a > v
          ? a < o
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(a)), (n = y / i), (r = b / i))
          : v < o
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(v)), (n = x / r), (i = b / r)),
        this.set(n, i, r, e),
        this
      );
    }
    let v = Math.sqrt(
      (m - p) * (m - p) + (h - f) * (h - f) + (u - l) * (u - l)
    );
    return (
      Math.abs(v) < 0.001 && (v = 1),
      (this.x = (m - p) / v),
      (this.y = (h - f) / v),
      (this.z = (u - l) / v),
      (this.w = Math.acos((c + d + g - 1) / 2)),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    );
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e) {
    return (
      void 0 === e && (e = 0),
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    );
  }
  toArray(t, e) {
    return (
      void 0 === t && (t = []),
      void 0 === e && (e = 0),
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    );
  }
  fromBufferAttribute(t, e, n) {
    return (
      void 0 !== n &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
}
function p(t, e, n) {
  (this.width = t),
    (this.height = e),
    (this.scissor = new d(0, 0, t, e)),
    (this.scissorTest = !1),
    (this.viewport = new d(0, 0, t, e)),
    (n = n || {}),
    (this.texture = new u(
      void 0,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.encoding
    )),
    (this.texture.image = {}),
    (this.texture.image.width = t),
    (this.texture.image.height = e),
    (this.texture.generateMipmaps =
      void 0 !== n.generateMipmaps && n.generateMipmaps),
    (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
    (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
    (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
    (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null);
}
function f(t, e, n) {
  p.call(this, t, e, n), (this.samples = 4);
}
(p.prototype = Object.assign(Object.create(n.prototype), {
  constructor: p,
  isWebGLRenderTarget: !0,
  setSize: function (t, e) {
    (this.width === t && this.height === e) ||
      ((this.width = t),
      (this.height = e),
      (this.texture.image.width = t),
      (this.texture.image.height = e),
      this.dispose()),
      this.viewport.set(0, 0, t, e),
      this.scissor.set(0, 0, t, e);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    return (
      (this.width = t.width),
      (this.height = t.height),
      this.viewport.copy(t.viewport),
      (this.texture = t.texture.clone()),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.depthTexture = t.depthTexture),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
})),
  (f.prototype = Object.assign(Object.create(p.prototype), {
    constructor: f,
    isWebGLMultisampleRenderTarget: !0,
    copy: function (t) {
      return p.prototype.copy.call(this, t), (this.samples = t.samples), this;
    },
  }));
class m {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    Object.defineProperty(this, "isQuaternion", { value: !0 }),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i);
  }
  static slerp(t, e, n, i) {
    return n.copy(t).slerp(e, i);
  }
  static slerpFlat(t, e, n, i, r, o, s) {
    let a = n[i + 0],
      c = n[i + 1],
      l = n[i + 2],
      h = n[i + 3];
    const u = r[o + 0],
      d = r[o + 1],
      p = r[o + 2],
      f = r[o + 3];
    if (h !== f || a !== u || c !== d || l !== p) {
      let t = 1 - s;
      const e = a * u + c * d + l * p + h * f,
        n = e >= 0 ? 1 : -1,
        i = 1 - e * e;
      if (i > Number.EPSILON) {
        const r = Math.sqrt(i),
          o = Math.atan2(r, e * n);
        (t = Math.sin(t * o) / r), (s = Math.sin(s * o) / r);
      }
      const r = s * n;
      if (
        ((a = a * t + u * r),
        (c = c * t + d * r),
        (l = l * t + p * r),
        (h = h * t + f * r),
        t === 1 - s)
      ) {
        const t = 1 / Math.sqrt(a * a + c * c + l * l + h * h);
        (a *= t), (c *= t), (l *= t), (h *= t);
      }
    }
    (t[e] = a), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
  }
  static multiplyQuaternionsFlat(t, e, n, i, r, o) {
    const s = n[i],
      a = n[i + 1],
      c = n[i + 2],
      l = n[i + 3],
      h = r[o],
      u = r[o + 1],
      d = r[o + 2],
      p = r[o + 3];
    return (
      (t[e] = s * p + l * h + a * d - c * u),
      (t[e + 1] = a * p + l * u + c * h - s * d),
      (t[e + 2] = c * p + l * d + s * u - a * h),
      (t[e + 3] = l * p - s * h - a * u - c * d),
      t
    );
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    (this._w = t), this._onChangeCallback();
  }
  set(t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(t, e) {
    if (!t || !t.isEuler)
      throw new Error(
        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      );
    const n = t._x,
      i = t._y,
      r = t._z,
      o = t._order,
      s = Math.cos,
      a = Math.sin,
      c = s(n / 2),
      l = s(i / 2),
      h = s(r / 2),
      u = a(n / 2),
      d = a(i / 2),
      p = a(r / 2);
    switch (o) {
      case "XYZ":
        (this._x = u * l * h + c * d * p),
          (this._y = c * d * h - u * l * p),
          (this._z = c * l * p + u * d * h),
          (this._w = c * l * h - u * d * p);
        break;
      case "YXZ":
        (this._x = u * l * h + c * d * p),
          (this._y = c * d * h - u * l * p),
          (this._z = c * l * p - u * d * h),
          (this._w = c * l * h + u * d * p);
        break;
      case "ZXY":
        (this._x = u * l * h - c * d * p),
          (this._y = c * d * h + u * l * p),
          (this._z = c * l * p + u * d * h),
          (this._w = c * l * h - u * d * p);
        break;
      case "ZYX":
        (this._x = u * l * h - c * d * p),
          (this._y = c * d * h + u * l * p),
          (this._z = c * l * p - u * d * h),
          (this._w = c * l * h + u * d * p);
        break;
      case "YZX":
        (this._x = u * l * h + c * d * p),
          (this._y = c * d * h + u * l * p),
          (this._z = c * l * p - u * d * h),
          (this._w = c * l * h - u * d * p);
        break;
      case "XZY":
        (this._x = u * l * h - c * d * p),
          (this._y = c * d * h - u * l * p),
          (this._z = c * l * p + u * d * h),
          (this._w = c * l * h + u * d * p);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return !1 !== e && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const n = e / 2,
      i = Math.sin(n);
    return (
      (this._x = t.x * i),
      (this._y = t.y * i),
      (this._z = t.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      n = e[0],
      i = e[4],
      r = e[8],
      o = e[1],
      s = e[5],
      a = e[9],
      c = e[2],
      l = e[6],
      h = e[10],
      u = n + s + h;
    if (u > 0) {
      const t = 0.5 / Math.sqrt(u + 1);
      (this._w = 0.25 / t),
        (this._x = (l - a) * t),
        (this._y = (r - c) * t),
        (this._z = (o - i) * t);
    } else if (n > s && n > h) {
      const t = 2 * Math.sqrt(1 + n - s - h);
      (this._w = (l - a) / t),
        (this._x = 0.25 * t),
        (this._y = (i + o) / t),
        (this._z = (r + c) / t);
    } else if (s > h) {
      const t = 2 * Math.sqrt(1 + s - n - h);
      (this._w = (r - c) / t),
        (this._x = (i + o) / t),
        (this._y = 0.25 * t),
        (this._z = (a + l) / t);
    } else {
      const t = 2 * Math.sqrt(1 + h - n - s);
      (this._w = (o - i) / t),
        (this._x = (r + c) / t),
        (this._y = (a + l) / t),
        (this._z = 0.25 * t);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1;
    return (
      n < 1e-6
        ? ((n = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(o.clamp(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t);
    if (0 === n) return this;
    const i = Math.min(1, e / n);
    return this.slerp(t, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  inverse() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let t = this.length();
    return (
      0 === t
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
        ),
        this.multiplyQuaternions(t, e))
      : this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const n = t._x,
      i = t._y,
      r = t._z,
      o = t._w,
      s = e._x,
      a = e._y,
      c = e._z,
      l = e._w;
    return (
      (this._x = n * l + o * s + i * c - r * a),
      (this._y = i * l + o * a + r * s - n * c),
      (this._z = r * l + o * c + n * a - i * s),
      (this._w = o * l - n * s - i * a - r * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(t, e) {
    if (0 === e) return this;
    if (1 === e) return this.copy(t);
    const n = this._x,
      i = this._y,
      r = this._z,
      o = this._w;
    let s = o * t._w + n * t._x + i * t._y + r * t._z;
    if (
      (s < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (s = -s))
        : this.copy(t),
      s >= 1)
    )
      return (this._w = o), (this._x = n), (this._y = i), (this._z = r), this;
    const a = 1 - s * s;
    if (a <= Number.EPSILON) {
      const t = 1 - e;
      return (
        (this._w = t * o + e * this._w),
        (this._x = t * n + e * this._x),
        (this._y = t * i + e * this._y),
        (this._z = t * r + e * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(a),
      l = Math.atan2(c, s),
      h = Math.sin((1 - e) * l) / c,
      u = Math.sin(e * l) / c;
    return (
      (this._w = o * h + this._w * u),
      (this._x = n * h + this._x * u),
      (this._y = i * h + this._y * u),
      (this._z = r * h + this._z * u),
      this._onChangeCallback(),
      this
    );
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    );
  }
  fromArray(t, e) {
    return (
      void 0 === e && (e = 0),
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t, e) {
    return (
      void 0 === t && (t = []),
      void 0 === e && (e = 0),
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this
    );
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
}
class g {
  constructor(t = 0, e = 0, n = 0) {
    Object.defineProperty(this, "isVector3", { value: !0 }),
      (this.x = t),
      (this.y = e),
      (this.z = n);
  }
  set(t, e, n) {
    return (
      void 0 === n && (n = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      this
    );
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  }
  add(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    );
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
  }
  sub(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    );
  }
  multiply(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
        ),
        this.multiplyVectors(t, e))
      : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  }
  multiplyVectors(t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    );
  }
  applyEuler(t) {
    return (
      (t && t.isEuler) ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ),
      this.applyQuaternion(y.setFromEuler(t))
    );
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(y.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[3] * n + r[6] * i),
      (this.y = r[1] * e + r[4] * n + r[7] * i),
      (this.z = r[2] * e + r[5] * n + r[8] * i),
      this
    );
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements,
      o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
      (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
      (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
      this
    );
  }
  applyQuaternion(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.x,
      o = t.y,
      s = t.z,
      a = t.w,
      c = a * e + o * i - s * n,
      l = a * n + s * e - r * i,
      h = a * i + r * n - o * e,
      u = -r * e - o * n - s * i;
    return (
      (this.x = c * a + u * -r + l * -s - h * -o),
      (this.y = l * a + u * -o + h * -r - c * -s),
      (this.z = h * a + u * -s + c * -o - l * -r),
      this
    );
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix
    );
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld
    );
  }
  transformDirection(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[4] * n + r[8] * i),
      (this.y = r[1] * e + r[5] * n + r[9] * i),
      (this.z = r[2] * e + r[6] * n + r[10] * i),
      this.normalize()
    );
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    );
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    );
  }
  cross(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
        ),
        this.crossVectors(t, e))
      : this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      o = e.x,
      s = e.y,
      a = e.z;
    return (
      (this.x = i * a - r * s),
      (this.y = r * o - n * a),
      (this.z = n * s - i * o),
      this
    );
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (0 === e) return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  }
  projectOnPlane(t) {
    return v.copy(this).projectOnVector(t), this.sub(v);
  }
  reflect(t) {
    return this.sub(v.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (0 === e) return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(o.clamp(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.z - t.z;
    return e * e + n * n + i * i;
  }
  manhattanDistanceTo(t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    );
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(e) * t),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n) {
    return (
      (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
    );
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      i = this.setFromMatrixColumn(t, 2).length();
    return (this.x = e), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, 4 * e);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, 3 * e);
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e) {
    return (
      void 0 === e && (e = 0),
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      this
    );
  }
  toArray(t, e) {
    return (
      void 0 === t && (t = []),
      void 0 === e && (e = 0),
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      t
    );
  }
  fromBufferAttribute(t, e, n) {
    return (
      void 0 !== n &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
}
const v = new g(),
  y = new m();
class x {
  constructor(t, e) {
    Object.defineProperty(this, "isBox3", { value: !0 }),
      (this.min = void 0 !== t ? t : new g(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new g(-1 / 0, -1 / 0, -1 / 0));
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      s = -1 / 0;
    for (let a = 0, c = t.length; a < c; a += 3) {
      const c = t[a],
        l = t[a + 1],
        h = t[a + 2];
      c < e && (e = c),
        l < n && (n = l),
        h < i && (i = h),
        c > r && (r = c),
        l > o && (o = l),
        h > s && (s = h);
    }
    return this.min.set(e, n, i), this.max.set(r, o, s), this;
  }
  setFromBufferAttribute(t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      s = -1 / 0;
    for (let a = 0, c = t.count; a < c; a++) {
      const c = t.getX(a),
        l = t.getY(a),
        h = t.getZ(a);
      c < e && (e = c),
        l < n && (n = l),
        h < i && (i = h),
        c > r && (r = c),
        l > o && (o = l),
        h > s && (s = h);
    }
    return this.min.set(e, n, i), this.max.set(r, o, s), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = w.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  setFromObject(t) {
    return this.makeEmpty(), this.expandByObject(t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Box3: .getCenter() target is now required"),
        (t = new g())),
      this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5)
    );
  }
  getSize(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Box3: .getSize() target is now required"),
        (t = new g())),
      this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    );
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t) {
    t.updateWorldMatrix(!1, !1);
    const e = t.geometry;
    void 0 !== e &&
      (null === e.boundingBox && e.computeBoundingBox(),
      M.copy(e.boundingBox),
      M.applyMatrix4(t.matrixWorld),
      this.union(M));
    const n = t.children;
    for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
    return this;
  }
  containsPoint(t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y ||
      t.z < this.min.z ||
      t.z > this.max.z
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    );
  }
  getParameter(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Box3: .getParameter() target is now required"),
        (e = new g())),
      e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      )
    );
  }
  intersectsBox(t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y ||
      t.max.z < this.min.z ||
      t.min.z > this.max.z
    );
  }
  intersectsSphere(t) {
    return (
      this.clampPoint(t.center, w),
      w.distanceToSquared(t.center) <= t.radius * t.radius
    );
  }
  intersectsPlane(t) {
    let e, n;
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    );
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1;
    this.getCenter(P),
      C.subVectors(this.max, P),
      S.subVectors(t.a, P),
      T.subVectors(t.b, P),
      E.subVectors(t.c, P),
      A.subVectors(T, S),
      L.subVectors(E, T),
      R.subVectors(S, E);
    let e = [
      0,
      -A.z,
      A.y,
      0,
      -L.z,
      L.y,
      0,
      -R.z,
      R.y,
      A.z,
      0,
      -A.x,
      L.z,
      0,
      -L.x,
      R.z,
      0,
      -R.x,
      -A.y,
      A.x,
      0,
      -L.y,
      L.x,
      0,
      -R.y,
      R.x,
      0,
    ];
    return (
      !!b(e, S, T, E, C) &&
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!b(e, S, T, E, C) &&
        (O.crossVectors(A, L), (e = [O.x, O.y, O.z]), b(e, S, T, E, C)))
    );
  }
  clampPoint(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Box3: .clampPoint() target is now required"),
        (e = new g())),
      e.copy(t).clamp(this.min, this.max)
    );
  }
  distanceToPoint(t) {
    return w.copy(t).clamp(this.min, this.max).sub(t).length();
  }
  getBoundingSphere(t) {
    return (
      void 0 === t &&
        console.error(
          "THREE.Box3: .getBoundingSphere() target is now required"
        ),
      this.getCenter(t.center),
      (t.radius = 0.5 * this.getSize(w).length()),
      t
    );
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return (
      this.isEmpty() ||
        (_[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        _[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        _[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        _[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        _[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        _[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        _[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        _[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(_)),
      this
    );
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
function b(t, e, n, i, r) {
  for (let o = 0, s = t.length - 3; o <= s; o += 3) {
    N.fromArray(t, o);
    const s = r.x * Math.abs(N.x) + r.y * Math.abs(N.y) + r.z * Math.abs(N.z),
      a = e.dot(N),
      c = n.dot(N),
      l = i.dot(N);
    if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1;
  }
  return !0;
}
const _ = [
    new g(),
    new g(),
    new g(),
    new g(),
    new g(),
    new g(),
    new g(),
    new g(),
  ],
  w = new g(),
  M = new x(),
  S = new g(),
  T = new g(),
  E = new g(),
  A = new g(),
  L = new g(),
  R = new g(),
  P = new g(),
  C = new g(),
  O = new g(),
  N = new g(),
  I = new x();
class D {
  constructor(t, e) {
    (this.center = void 0 !== t ? t : new g()),
      (this.radius = void 0 !== e ? e : -1);
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this;
  }
  setFromPoints(t, e) {
    const n = this.center;
    void 0 !== e ? n.copy(e) : I.setFromPoints(t).getCenter(n);
    let i = 0;
    for (let e = 0, r = t.length; e < r; e++)
      i = Math.max(i, n.distanceToSquared(t[e]));
    return (this.radius = Math.sqrt(i)), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t);
    return (
      void 0 === e &&
        (console.warn("THREE.Sphere: .clampPoint() target is now required"),
        (e = new g())),
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    );
  }
  getBoundingBox(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
        (t = new x())),
      this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
    );
  }
  applyMatrix4(t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    );
  }
  translate(t) {
    return this.center.add(t), this;
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
}
const B = new g(),
  z = new g(),
  F = new g(),
  U = new g(),
  G = new g(),
  H = new g(),
  k = new g();
class V {
  constructor(t, e) {
    (this.origin = void 0 !== t ? t : new g()),
      (this.direction = void 0 !== e ? e : new g(0, 0, -1));
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Ray: .at() target is now required"),
        (e = new g())),
      e.copy(this.direction).multiplyScalar(t).add(this.origin)
    );
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, B)), this;
  }
  closestPointToPoint(t, e) {
    void 0 === e &&
      (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
      (e = new g())),
      e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0
      ? e.copy(this.origin)
      : e.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = B.subVectors(t, this.origin).dot(this.direction);
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (B.copy(this.direction).multiplyScalar(e).add(this.origin),
        B.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n, i) {
    z.copy(t).add(e).multiplyScalar(0.5),
      F.copy(e).sub(t).normalize(),
      U.copy(this.origin).sub(z);
    const r = 0.5 * t.distanceTo(e),
      o = -this.direction.dot(F),
      s = U.dot(this.direction),
      a = -U.dot(F),
      c = U.lengthSq(),
      l = Math.abs(1 - o * o);
    let h, u, d, p;
    if (l > 0)
      if (((h = o * a - s), (u = o * s - a), (p = r * l), h >= 0))
        if (u >= -p)
          if (u <= p) {
            const t = 1 / l;
            (h *= t),
              (u *= t),
              (d = h * (h + o * u + 2 * s) + u * (o * h + u + 2 * a) + c);
          } else
            (u = r),
              (h = Math.max(0, -(o * u + s))),
              (d = -h * h + u * (u + 2 * a) + c);
        else
          (u = -r),
            (h = Math.max(0, -(o * u + s))),
            (d = -h * h + u * (u + 2 * a) + c);
      else
        u <= -p
          ? ((h = Math.max(0, -(-o * r + s))),
            (u = h > 0 ? -r : Math.min(Math.max(-r, -a), r)),
            (d = -h * h + u * (u + 2 * a) + c))
          : u <= p
          ? ((h = 0),
            (u = Math.min(Math.max(-r, -a), r)),
            (d = u * (u + 2 * a) + c))
          : ((h = Math.max(0, -(o * r + s))),
            (u = h > 0 ? r : Math.min(Math.max(-r, -a), r)),
            (d = -h * h + u * (u + 2 * a) + c));
    else
      (u = o > 0 ? -r : r),
        (h = Math.max(0, -(o * u + s))),
        (d = -h * h + u * (u + 2 * a) + c);
    return (
      n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
      i && i.copy(F).multiplyScalar(u).add(z),
      d
    );
  }
  intersectSphere(t, e) {
    B.subVectors(t.center, this.origin);
    const n = B.dot(this.direction),
      i = B.dot(B) - n * n,
      r = t.radius * t.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i),
      s = n - o,
      a = n + o;
    return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t);
    return null === n ? null : this.at(n, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    if (0 === e) return !0;
    return t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n, i, r, o, s, a;
    const c = 1 / this.direction.x,
      l = 1 / this.direction.y,
      h = 1 / this.direction.z,
      u = this.origin;
    return (
      c >= 0
        ? ((n = (t.min.x - u.x) * c), (i = (t.max.x - u.x) * c))
        : ((n = (t.max.x - u.x) * c), (i = (t.min.x - u.x) * c)),
      l >= 0
        ? ((r = (t.min.y - u.y) * l), (o = (t.max.y - u.y) * l))
        : ((r = (t.max.y - u.y) * l), (o = (t.min.y - u.y) * l)),
      n > o || r > i
        ? null
        : ((r > n || n != n) && (n = r),
          (o < i || i != i) && (i = o),
          h >= 0
            ? ((s = (t.min.z - u.z) * h), (a = (t.max.z - u.z) * h))
            : ((s = (t.max.z - u.z) * h), (a = (t.min.z - u.z) * h)),
          n > a || s > i
            ? null
            : ((s > n || n != n) && (n = s),
              (a < i || i != i) && (i = a),
              i < 0 ? null : this.at(n >= 0 ? n : i, e)))
    );
  }
  intersectsBox(t) {
    return null !== this.intersectBox(t, B);
  }
  intersectTriangle(t, e, n, i, r) {
    G.subVectors(e, t), H.subVectors(n, t), k.crossVectors(G, H);
    let o,
      s = this.direction.dot(k);
    if (s > 0) {
      if (i) return null;
      o = 1;
    } else {
      if (!(s < 0)) return null;
      (o = -1), (s = -s);
    }
    U.subVectors(this.origin, t);
    const a = o * this.direction.dot(H.crossVectors(U, H));
    if (a < 0) return null;
    const c = o * this.direction.dot(G.cross(U));
    if (c < 0) return null;
    if (a + c > s) return null;
    const l = -o * U.dot(k);
    return l < 0 ? null : this.at(l / s, r);
  }
  applyMatrix4(t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    );
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
}
class j {
  constructor() {
    Object.defineProperty(this, "isMatrix4", { value: !0 }),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(t, e, n, i, r, o, s, a, c, l, h, u, d, p, f, m) {
    const g = this.elements;
    return (
      (g[0] = t),
      (g[4] = e),
      (g[8] = n),
      (g[12] = i),
      (g[1] = r),
      (g[5] = o),
      (g[9] = s),
      (g[13] = a),
      (g[2] = c),
      (g[6] = l),
      (g[10] = h),
      (g[14] = u),
      (g[3] = d),
      (g[7] = p),
      (g[11] = f),
      (g[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new j().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    );
  }
  copyPosition(t) {
    const e = this.elements,
      n = t.elements;
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(t, e, n) {
    return (
      this.set(
        t.x,
        e.x,
        n.x,
        0,
        t.y,
        e.y,
        n.y,
        0,
        t.z,
        e.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(t) {
    const e = this.elements,
      n = t.elements,
      i = 1 / W.setFromMatrixColumn(t, 0).length(),
      r = 1 / W.setFromMatrixColumn(t, 1).length(),
      o = 1 / W.setFromMatrixColumn(t, 2).length();
    return (
      (e[0] = n[0] * i),
      (e[1] = n[1] * i),
      (e[2] = n[2] * i),
      (e[3] = 0),
      (e[4] = n[4] * r),
      (e[5] = n[5] * r),
      (e[6] = n[6] * r),
      (e[7] = 0),
      (e[8] = n[8] * o),
      (e[9] = n[9] * o),
      (e[10] = n[10] * o),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromEuler(t) {
    (t && t.isEuler) ||
      console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
    const e = this.elements,
      n = t.x,
      i = t.y,
      r = t.z,
      o = Math.cos(n),
      s = Math.sin(n),
      a = Math.cos(i),
      c = Math.sin(i),
      l = Math.cos(r),
      h = Math.sin(r);
    if ("XYZ" === t.order) {
      const t = o * l,
        n = o * h,
        i = s * l,
        r = s * h;
      (e[0] = a * l),
        (e[4] = -a * h),
        (e[8] = c),
        (e[1] = n + i * c),
        (e[5] = t - r * c),
        (e[9] = -s * a),
        (e[2] = r - t * c),
        (e[6] = i + n * c),
        (e[10] = o * a);
    } else if ("YXZ" === t.order) {
      const t = a * l,
        n = a * h,
        i = c * l,
        r = c * h;
      (e[0] = t + r * s),
        (e[4] = i * s - n),
        (e[8] = o * c),
        (e[1] = o * h),
        (e[5] = o * l),
        (e[9] = -s),
        (e[2] = n * s - i),
        (e[6] = r + t * s),
        (e[10] = o * a);
    } else if ("ZXY" === t.order) {
      const t = a * l,
        n = a * h,
        i = c * l,
        r = c * h;
      (e[0] = t - r * s),
        (e[4] = -o * h),
        (e[8] = i + n * s),
        (e[1] = n + i * s),
        (e[5] = o * l),
        (e[9] = r - t * s),
        (e[2] = -o * c),
        (e[6] = s),
        (e[10] = o * a);
    } else if ("ZYX" === t.order) {
      const t = o * l,
        n = o * h,
        i = s * l,
        r = s * h;
      (e[0] = a * l),
        (e[4] = i * c - n),
        (e[8] = t * c + r),
        (e[1] = a * h),
        (e[5] = r * c + t),
        (e[9] = n * c - i),
        (e[2] = -c),
        (e[6] = s * a),
        (e[10] = o * a);
    } else if ("YZX" === t.order) {
      const t = o * a,
        n = o * c,
        i = s * a,
        r = s * c;
      (e[0] = a * l),
        (e[4] = r - t * h),
        (e[8] = i * h + n),
        (e[1] = h),
        (e[5] = o * l),
        (e[9] = -s * l),
        (e[2] = -c * l),
        (e[6] = n * h + i),
        (e[10] = t - r * h);
    } else if ("XZY" === t.order) {
      const t = o * a,
        n = o * c,
        i = s * a,
        r = s * c;
      (e[0] = a * l),
        (e[4] = -h),
        (e[8] = c * l),
        (e[1] = t * h + r),
        (e[5] = o * l),
        (e[9] = n * h - i),
        (e[2] = i * h - n),
        (e[6] = s * l),
        (e[10] = r * h + t);
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(t) {
    return this.compose(X, t, Y);
  }
  lookAt(t, e, n) {
    const i = this.elements;
    return (
      K.subVectors(t, e),
      0 === K.lengthSq() && (K.z = 1),
      K.normalize(),
      Z.crossVectors(n, K),
      0 === Z.lengthSq() &&
        (1 === Math.abs(n.z) ? (K.x += 1e-4) : (K.z += 1e-4),
        K.normalize(),
        Z.crossVectors(n, K)),
      Z.normalize(),
      J.crossVectors(K, Z),
      (i[0] = Z.x),
      (i[4] = J.x),
      (i[8] = K.x),
      (i[1] = Z.y),
      (i[5] = J.y),
      (i[9] = K.y),
      (i[2] = Z.z),
      (i[6] = J.z),
      (i[10] = K.z),
      this
    );
  }
  multiply(t, e) {
    return void 0 !== e
      ? (console.warn(
          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
        ),
        this.multiplyMatrices(t, e))
      : this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      r = this.elements,
      o = n[0],
      s = n[4],
      a = n[8],
      c = n[12],
      l = n[1],
      h = n[5],
      u = n[9],
      d = n[13],
      p = n[2],
      f = n[6],
      m = n[10],
      g = n[14],
      v = n[3],
      y = n[7],
      x = n[11],
      b = n[15],
      _ = i[0],
      w = i[4],
      M = i[8],
      S = i[12],
      T = i[1],
      E = i[5],
      A = i[9],
      L = i[13],
      R = i[2],
      P = i[6],
      C = i[10],
      O = i[14],
      N = i[3],
      I = i[7],
      D = i[11],
      B = i[15];
    return (
      (r[0] = o * _ + s * T + a * R + c * N),
      (r[4] = o * w + s * E + a * P + c * I),
      (r[8] = o * M + s * A + a * C + c * D),
      (r[12] = o * S + s * L + a * O + c * B),
      (r[1] = l * _ + h * T + u * R + d * N),
      (r[5] = l * w + h * E + u * P + d * I),
      (r[9] = l * M + h * A + u * C + d * D),
      (r[13] = l * S + h * L + u * O + d * B),
      (r[2] = p * _ + f * T + m * R + g * N),
      (r[6] = p * w + f * E + m * P + g * I),
      (r[10] = p * M + f * A + m * C + g * D),
      (r[14] = p * S + f * L + m * O + g * B),
      (r[3] = v * _ + y * T + x * R + b * N),
      (r[7] = v * w + y * E + x * P + b * I),
      (r[11] = v * M + y * A + x * C + b * D),
      (r[15] = v * S + y * L + x * O + b * B),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[4],
      i = t[8],
      r = t[12],
      o = t[1],
      s = t[5],
      a = t[9],
      c = t[13],
      l = t[2],
      h = t[6],
      u = t[10],
      d = t[14];
    return (
      t[3] *
        (+r * a * h -
          i * c * h -
          r * s * u +
          n * c * u +
          i * s * d -
          n * a * d) +
      t[7] *
        (+e * a * d -
          e * c * u +
          r * o * u -
          i * o * d +
          i * c * l -
          r * a * l) +
      t[11] *
        (+e * c * h -
          e * s * d -
          r * o * h +
          n * o * d +
          r * s * l -
          n * c * l) +
      t[15] *
        (-i * s * l - e * a * h + e * s * u + i * o * h - n * o * u + n * a * l)
    );
  }
  transpose() {
    const t = this.elements;
    let e;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  setPosition(t, e, n) {
    const i = this.elements;
    return (
      t.isVector3
        ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
        : ((i[12] = t), (i[13] = e), (i[14] = n)),
      this
    );
  }
  getInverse(t, e) {
    void 0 !== e &&
      console.warn(
        "THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate."
      );
    const n = this.elements,
      i = t.elements,
      r = i[0],
      o = i[1],
      s = i[2],
      a = i[3],
      c = i[4],
      l = i[5],
      h = i[6],
      u = i[7],
      d = i[8],
      p = i[9],
      f = i[10],
      m = i[11],
      g = i[12],
      v = i[13],
      y = i[14],
      x = i[15],
      b = p * y * u - v * f * u + v * h * m - l * y * m - p * h * x + l * f * x,
      _ = g * f * u - d * y * u - g * h * m + c * y * m + d * h * x - c * f * x,
      w = d * v * u - g * p * u + g * l * m - c * v * m - d * l * x + c * p * x,
      M = g * p * h - d * v * h - g * l * f + c * v * f + d * l * y - c * p * y,
      S = r * b + o * _ + s * w + a * M;
    if (0 === S)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / S;
    return (
      (n[0] = b * T),
      (n[1] =
        (v * f * a -
          p * y * a -
          v * s * m +
          o * y * m +
          p * s * x -
          o * f * x) *
        T),
      (n[2] =
        (l * y * a -
          v * h * a +
          v * s * u -
          o * y * u -
          l * s * x +
          o * h * x) *
        T),
      (n[3] =
        (p * h * a -
          l * f * a -
          p * s * u +
          o * f * u +
          l * s * m -
          o * h * m) *
        T),
      (n[4] = _ * T),
      (n[5] =
        (d * y * a -
          g * f * a +
          g * s * m -
          r * y * m -
          d * s * x +
          r * f * x) *
        T),
      (n[6] =
        (g * h * a -
          c * y * a -
          g * s * u +
          r * y * u +
          c * s * x -
          r * h * x) *
        T),
      (n[7] =
        (c * f * a -
          d * h * a +
          d * s * u -
          r * f * u -
          c * s * m +
          r * h * m) *
        T),
      (n[8] = w * T),
      (n[9] =
        (g * p * a -
          d * v * a -
          g * o * m +
          r * v * m +
          d * o * x -
          r * p * x) *
        T),
      (n[10] =
        (c * v * a -
          g * l * a +
          g * o * u -
          r * v * u -
          c * o * x +
          r * l * x) *
        T),
      (n[11] =
        (d * l * a -
          c * p * a -
          d * o * u +
          r * p * u +
          c * o * m -
          r * l * m) *
        T),
      (n[12] = M * T),
      (n[13] =
        (d * v * s -
          g * p * s +
          g * o * f -
          r * v * f -
          d * o * y +
          r * p * y) *
        T),
      (n[14] =
        (g * l * s -
          c * v * s -
          g * o * h +
          r * v * h +
          c * o * y -
          r * l * y) *
        T),
      (n[15] =
        (c * p * s -
          d * l * s +
          d * o * h -
          r * p * h -
          c * o * f +
          r * l * f) *
        T),
      this
    );
  }
  scale(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      r = t.z;
    return (
      (e[0] *= n),
      (e[4] *= i),
      (e[8] *= r),
      (e[1] *= n),
      (e[5] *= i),
      (e[9] *= r),
      (e[2] *= n),
      (e[6] *= i),
      (e[10] *= r),
      (e[3] *= n),
      (e[7] *= i),
      (e[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, i));
  }
  makeTranslation(t, e, n) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      r = 1 - n,
      o = t.x,
      s = t.y,
      a = t.z,
      c = r * o,
      l = r * s;
    return (
      this.set(
        c * o + n,
        c * s - i * a,
        c * a + i * s,
        0,
        c * s + i * a,
        l * s + n,
        l * a - i * o,
        0,
        c * a - i * s,
        l * a + i * o,
        r * a * a + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, n) {
    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, n) {
    const i = this.elements,
      r = e._x,
      o = e._y,
      s = e._z,
      a = e._w,
      c = r + r,
      l = o + o,
      h = s + s,
      u = r * c,
      d = r * l,
      p = r * h,
      f = o * l,
      m = o * h,
      g = s * h,
      v = a * c,
      y = a * l,
      x = a * h,
      b = n.x,
      _ = n.y,
      w = n.z;
    return (
      (i[0] = (1 - (f + g)) * b),
      (i[1] = (d + x) * b),
      (i[2] = (p - y) * b),
      (i[3] = 0),
      (i[4] = (d - x) * _),
      (i[5] = (1 - (u + g)) * _),
      (i[6] = (m + v) * _),
      (i[7] = 0),
      (i[8] = (p + y) * w),
      (i[9] = (m - v) * w),
      (i[10] = (1 - (u + f)) * w),
      (i[11] = 0),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = t.z),
      (i[15] = 1),
      this
    );
  }
  decompose(t, e, n) {
    const i = this.elements;
    let r = W.set(i[0], i[1], i[2]).length();
    const o = W.set(i[4], i[5], i[6]).length(),
      s = W.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (t.x = i[12]),
      (t.y = i[13]),
      (t.z = i[14]),
      q.copy(this);
    const a = 1 / r,
      c = 1 / o,
      l = 1 / s;
    return (
      (q.elements[0] *= a),
      (q.elements[1] *= a),
      (q.elements[2] *= a),
      (q.elements[4] *= c),
      (q.elements[5] *= c),
      (q.elements[6] *= c),
      (q.elements[8] *= l),
      (q.elements[9] *= l),
      (q.elements[10] *= l),
      e.setFromRotationMatrix(q),
      (n.x = r),
      (n.y = o),
      (n.z = s),
      this
    );
  }
  makePerspective(t, e, n, i, r, o) {
    void 0 === o &&
      console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
    const s = this.elements,
      a = (2 * r) / (e - t),
      c = (2 * r) / (n - i),
      l = (e + t) / (e - t),
      h = (n + i) / (n - i),
      u = -(o + r) / (o - r),
      d = (-2 * o * r) / (o - r);
    return (
      (s[0] = a),
      (s[4] = 0),
      (s[8] = l),
      (s[12] = 0),
      (s[1] = 0),
      (s[5] = c),
      (s[9] = h),
      (s[13] = 0),
      (s[2] = 0),
      (s[6] = 0),
      (s[10] = u),
      (s[14] = d),
      (s[3] = 0),
      (s[7] = 0),
      (s[11] = -1),
      (s[15] = 0),
      this
    );
  }
  makeOrthographic(t, e, n, i, r, o) {
    const s = this.elements,
      a = 1 / (e - t),
      c = 1 / (n - i),
      l = 1 / (o - r),
      h = (e + t) * a,
      u = (n + i) * c,
      d = (o + r) * l;
    return (
      (s[0] = 2 * a),
      (s[4] = 0),
      (s[8] = 0),
      (s[12] = -h),
      (s[1] = 0),
      (s[5] = 2 * c),
      (s[9] = 0),
      (s[13] = -u),
      (s[2] = 0),
      (s[6] = 0),
      (s[10] = -2 * l),
      (s[14] = -d),
      (s[3] = 0),
      (s[7] = 0),
      (s[11] = 0),
      (s[15] = 1),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      n = t.elements;
    for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
    return !0;
  }
  fromArray(t, e) {
    void 0 === e && (e = 0);
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
    return this;
  }
  toArray(t, e) {
    void 0 === t && (t = []), void 0 === e && (e = 0);
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    );
  }
}
const W = new g(),
  q = new j(),
  X = new g(0, 0, 0),
  Y = new g(1, 1, 1),
  Z = new g(),
  J = new g(),
  K = new g();
class Q {
  constructor(t = 0, e = 0, n = 0, i = Q.DefaultOrder) {
    Object.defineProperty(this, "isEuler", { value: !0 }),
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    (this._order = t), this._onChangeCallback();
  }
  set(t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i || this._order),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t, e, n) {
    const i = o.clamp,
      r = t.elements,
      s = r[0],
      a = r[4],
      c = r[8],
      l = r[1],
      h = r[5],
      u = r[9],
      d = r[2],
      p = r[6],
      f = r[10];
    switch ((e = e || this._order)) {
      case "XYZ":
        (this._y = Math.asin(i(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(-u, f)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(p, h)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-i(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(c, f)), (this._z = Math.atan2(l, h)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(i(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, f)), (this._z = Math.atan2(-a, h)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-i(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, f)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, h)));
        break;
      case "YZX":
        (this._z = Math.asin(i(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, h)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(c, f)));
        break;
      case "XZY":
        (this._z = Math.asin(-i(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(p, h)), (this._y = Math.atan2(c, s)))
            : ((this._x = Math.atan2(-u, f)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            e
        );
    }
    return (this._order = e), !1 !== n && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n) {
    return $.makeRotationFromQuaternion(t), this.setFromRotationMatrix($, e, n);
  }
  setFromVector3(t, e) {
    return this.set(t.x, t.y, t.z, e || this._order);
  }
  reorder(t) {
    return tt.setFromEuler(this), this.setFromQuaternion(tt, t);
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    );
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      void 0 !== t[3] && (this._order = t[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t, e) {
    return (
      void 0 === t && (t = []),
      void 0 === e && (e = 0),
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    );
  }
  toVector3(t) {
    return t
      ? t.set(this._x, this._y, this._z)
      : new g(this._x, this._y, this._z);
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
}
(Q.DefaultOrder = "XYZ"),
  (Q.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
const $ = new j(),
  tt = new m();
class et {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t) | 0;
  }
  enable(t) {
    this.mask |= (1 << t) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= (1 << t) | 0;
  }
  disable(t) {
    this.mask &= ~((1 << t) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return 0 != (this.mask & t.mask);
  }
}
let nt = 0;
const it = new g(),
  rt = new m(),
  ot = new j(),
  st = new g(),
  at = new g(),
  ct = new g(),
  lt = new m(),
  ht = new g(1, 0, 0),
  ut = new g(0, 1, 0),
  dt = new g(0, 0, 1),
  pt = { type: "added" },
  ft = { type: "removed" };
function mt() {
  Object.defineProperty(this, "id", { value: nt++ }),
    (this.uuid = o.generateUUID()),
    (this.name = ""),
    (this.type = "Object3D"),
    (this.parent = null),
    (this.children = []),
    (this.up = mt.DefaultUp.clone());
  const t = new g(),
    e = new Q(),
    n = new m(),
    i = new g(1, 1, 1);
  e._onChange(function () {
    n.setFromEuler(e, !1);
  }),
    n._onChange(function () {
      e.setFromQuaternion(n, void 0, !1);
    }),
    Object.defineProperties(this, {
      position: { configurable: !0, enumerable: !0, value: t },
      rotation: { configurable: !0, enumerable: !0, value: e },
      quaternion: { configurable: !0, enumerable: !0, value: n },
      scale: { configurable: !0, enumerable: !0, value: i },
      modelViewMatrix: { value: new j() },
      normalMatrix: { value: new a() },
    }),
    (this.matrix = new j()),
    (this.matrixWorld = new j()),
    (this.matrixAutoUpdate = mt.DefaultMatrixAutoUpdate),
    (this.matrixWorldNeedsUpdate = !1),
    (this.layers = new et()),
    (this.visible = !0),
    (this.castShadow = !1),
    (this.receiveShadow = !1),
    (this.frustumCulled = !0),
    (this.renderOrder = 0),
    (this.userData = {});
}
(mt.DefaultUp = new g(0, 1, 0)),
  (mt.DefaultMatrixAutoUpdate = !0),
  (mt.prototype = Object.assign(Object.create(n.prototype), {
    constructor: mt,
    isObject3D: !0,
    onBeforeRender: function () {},
    onAfterRender: function () {},
    applyMatrix4: function (t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function (t) {
      return this.quaternion.premultiply(t), this;
    },
    setRotationFromAxisAngle: function (t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    },
    setRotationFromEuler: function (t) {
      this.quaternion.setFromEuler(t, !0);
    },
    setRotationFromMatrix: function (t) {
      this.quaternion.setFromRotationMatrix(t);
    },
    setRotationFromQuaternion: function (t) {
      this.quaternion.copy(t);
    },
    rotateOnAxis: function (t, e) {
      return rt.setFromAxisAngle(t, e), this.quaternion.multiply(rt), this;
    },
    rotateOnWorldAxis: function (t, e) {
      return rt.setFromAxisAngle(t, e), this.quaternion.premultiply(rt), this;
    },
    rotateX: function (t) {
      return this.rotateOnAxis(ht, t);
    },
    rotateY: function (t) {
      return this.rotateOnAxis(ut, t);
    },
    rotateZ: function (t) {
      return this.rotateOnAxis(dt, t);
    },
    translateOnAxis: function (t, e) {
      return (
        it.copy(t).applyQuaternion(this.quaternion),
        this.position.add(it.multiplyScalar(e)),
        this
      );
    },
    translateX: function (t) {
      return this.translateOnAxis(ht, t);
    },
    translateY: function (t) {
      return this.translateOnAxis(ut, t);
    },
    translateZ: function (t) {
      return this.translateOnAxis(dt, t);
    },
    localToWorld: function (t) {
      return t.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function (t) {
      return t.applyMatrix4(ot.getInverse(this.matrixWorld));
    },
    lookAt: function (t, e, n) {
      t.isVector3 ? st.copy(t) : st.set(t, e, n);
      const i = this.parent;
      this.updateWorldMatrix(!0, !1),
        at.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? ot.lookAt(at, st, this.up)
          : ot.lookAt(st, at, this.up),
        this.quaternion.setFromRotationMatrix(ot),
        i &&
          (ot.extractRotation(i.matrixWorld),
          rt.setFromRotationMatrix(ot),
          this.quaternion.premultiply(rt.inverse()));
    },
    add: function (t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(pt))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                t
              ),
          this);
    },
    remove: function (t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this;
      }
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(ft)),
        this
      );
    },
    attach: function (t) {
      return (
        this.updateWorldMatrix(!0, !1),
        ot.getInverse(this.matrixWorld),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          ot.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(ot),
        t.updateWorldMatrix(!1, !1),
        this.add(t),
        this
      );
    },
    getObjectById: function (t) {
      return this.getObjectByProperty("id", t);
    },
    getObjectByName: function (t) {
      return this.getObjectByProperty("name", t);
    },
    getObjectByProperty: function (t, e) {
      if (this[t] === e) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const i = this.children[n].getObjectByProperty(t, e);
        if (void 0 !== i) return i;
      }
    },
    getWorldPosition: function (t) {
      return (
        void 0 === t &&
          (console.warn(
            "THREE.Object3D: .getWorldPosition() target is now required"
          ),
          (t = new g())),
        this.updateMatrixWorld(!0),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    },
    getWorldQuaternion: function (t) {
      return (
        void 0 === t &&
          (console.warn(
            "THREE.Object3D: .getWorldQuaternion() target is now required"
          ),
          (t = new m())),
        this.updateMatrixWorld(!0),
        this.matrixWorld.decompose(at, t, ct),
        t
      );
    },
    getWorldScale: function (t) {
      return (
        void 0 === t &&
          (console.warn(
            "THREE.Object3D: .getWorldScale() target is now required"
          ),
          (t = new g())),
        this.updateMatrixWorld(!0),
        this.matrixWorld.decompose(at, lt, t),
        t
      );
    },
    getWorldDirection: function (t) {
      void 0 === t &&
        (console.warn(
          "THREE.Object3D: .getWorldDirection() target is now required"
        ),
        (t = new g())),
        this.updateMatrixWorld(!0);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function () {},
    traverse: function (t) {
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
    },
    traverseVisible: function (t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
    },
    traverseAncestors: function (t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    },
    updateMatrix: function () {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    },
    updateMatrixWorld: function (t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
    },
    updateWorldMatrix: function (t, e) {
      const n = this.parent;
      if (
        (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, n = t.length; e < n; e++)
          t[e].updateWorldMatrix(!1, !0);
      }
    },
    toJSON: function (t) {
      const e = void 0 === t || "string" == typeof t,
        n = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
        }),
        (n.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const i = {};
      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        !1 === this.frustumCulled && (i.frustumCulled = !1),
        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        (i.layers = this.layers.mask),
        (i.matrix = this.matrix.toArray()),
        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((i.type = "InstancedMesh"),
          (i.count = this.count),
          (i.instanceMatrix = this.instanceMatrix.toJSON())),
        this.isMesh || this.isLine || this.isPoints)
      ) {
        i.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const n = e.shapes;
          if (Array.isArray(n))
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              r(t.shapes, i);
            }
          else r(t.shapes, n);
        }
      }
      if (void 0 !== this.material)
        if (Array.isArray(this.material)) {
          const e = [];
          for (let n = 0, i = this.material.length; n < i; n++)
            e.push(r(t.materials, this.material[n]));
          i.material = e;
        } else i.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let e = 0; e < this.children.length; e++)
          i.children.push(this.children[e].toJSON(t).object);
      }
      if (e) {
        const e = o(t.geometries),
          i = o(t.materials),
          r = o(t.textures),
          s = o(t.images),
          a = o(t.shapes);
        e.length > 0 && (n.geometries = e),
          i.length > 0 && (n.materials = i),
          r.length > 0 && (n.textures = r),
          s.length > 0 && (n.images = s),
          a.length > 0 && (n.shapes = a);
      }
      return (n.object = i), n;
      function o(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
    },
    clone: function (t) {
      return new this.constructor().copy(this, t);
    },
    copy: function (t, e) {
      if (
        (void 0 === e && (e = !0),
        (this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let e = 0; e < t.children.length; e++) {
          const n = t.children[e];
          this.add(n.clone());
        }
      return this;
    },
  }));
const gt = new g(),
  vt = new g(),
  yt = new a();
class xt {
  constructor(t, e) {
    Object.defineProperty(this, "isPlane", { value: !0 }),
      (this.normal = void 0 !== t ? t : new g(1, 0, 0)),
      (this.constant = void 0 !== e ? e : 0);
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this;
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
  }
  setFromCoplanarPoints(t, e, n) {
    const i = gt.subVectors(n, e).cross(vt.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), (this.constant *= t), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Plane: .projectPoint() target is now required"),
        (e = new g())),
      e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    );
  }
  intersectLine(t, e) {
    void 0 === e &&
      (console.warn("THREE.Plane: .intersectLine() target is now required"),
      (e = new g()));
    const n = t.delta(gt),
      i = this.normal.dot(n);
    if (0 === i)
      return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
    const r = -(t.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end);
    return (e < 0 && n > 0) || (n < 0 && e > 0);
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
        (t = new g())),
      t.copy(this.normal).multiplyScalar(-this.constant)
    );
  }
  applyMatrix4(t, e) {
    const n = e || yt.getNormalMatrix(t),
      i = this.coplanarPoint(gt).applyMatrix4(t),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
}
const bt = new g(),
  _t = new g(),
  wt = new g(),
  Mt = new g(),
  St = new g(),
  Tt = new g(),
  Et = new g(),
  At = new g(),
  Lt = new g(),
  Rt = new g();
class Pt {
  constructor(t, e, n) {
    (this.a = void 0 !== t ? t : new g()),
      (this.b = void 0 !== e ? e : new g()),
      (this.c = void 0 !== n ? n : new g());
  }
  static getNormal(t, e, n, i) {
    void 0 === i &&
      (console.warn("THREE.Triangle: .getNormal() target is now required"),
      (i = new g())),
      i.subVectors(n, e),
      bt.subVectors(t, e),
      i.cross(bt);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  static getBarycoord(t, e, n, i, r) {
    bt.subVectors(i, e), _t.subVectors(n, e), wt.subVectors(t, e);
    const o = bt.dot(bt),
      s = bt.dot(_t),
      a = bt.dot(wt),
      c = _t.dot(_t),
      l = _t.dot(wt),
      h = o * c - s * s;
    if (
      (void 0 === r &&
        (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
        (r = new g())),
      0 === h)
    )
      return r.set(-2, -1, -1);
    const u = 1 / h,
      d = (c * a - s * l) * u,
      p = (o * l - s * a) * u;
    return r.set(1 - d - p, p, d);
  }
  static containsPoint(t, e, n, i) {
    return (
      this.getBarycoord(t, e, n, i, Mt),
      Mt.x >= 0 && Mt.y >= 0 && Mt.x + Mt.y <= 1
    );
  }
  static getUV(t, e, n, i, r, o, s, a) {
    return (
      this.getBarycoord(t, e, n, i, Mt),
      a.set(0, 0),
      a.addScaledVector(r, Mt.x),
      a.addScaledVector(o, Mt.y),
      a.addScaledVector(s, Mt.z),
      a
    );
  }
  static isFrontFacing(t, e, n, i) {
    return bt.subVectors(n, e), _t.subVectors(t, e), bt.cross(_t).dot(i) < 0;
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return (
      bt.subVectors(this.c, this.b),
      _t.subVectors(this.a, this.b),
      0.5 * bt.cross(_t).length()
    );
  }
  getMidpoint(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
        (t = new g())),
      t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3)
    );
  }
  getNormal(t) {
    return Pt.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Triangle: .getPlane() target is now required"),
        (t = new xt())),
      t.setFromCoplanarPoints(this.a, this.b, this.c)
    );
  }
  getBarycoord(t, e) {
    return Pt.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getUV(t, e, n, i, r) {
    return Pt.getUV(t, this.a, this.b, this.c, e, n, i, r);
  }
  containsPoint(t) {
    return Pt.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return Pt.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    void 0 === e &&
      (console.warn(
        "THREE.Triangle: .closestPointToPoint() target is now required"
      ),
      (e = new g()));
    const n = this.a,
      i = this.b,
      r = this.c;
    let o, s;
    St.subVectors(i, n), Tt.subVectors(r, n), At.subVectors(t, n);
    const a = St.dot(At),
      c = Tt.dot(At);
    if (a <= 0 && c <= 0) return e.copy(n);
    Lt.subVectors(t, i);
    const l = St.dot(Lt),
      h = Tt.dot(Lt);
    if (l >= 0 && h <= l) return e.copy(i);
    const u = a * h - l * c;
    if (u <= 0 && a >= 0 && l <= 0)
      return (o = a / (a - l)), e.copy(n).addScaledVector(St, o);
    Rt.subVectors(t, r);
    const d = St.dot(Rt),
      p = Tt.dot(Rt);
    if (p >= 0 && d <= p) return e.copy(r);
    const f = d * c - a * p;
    if (f <= 0 && c >= 0 && p <= 0)
      return (s = c / (c - p)), e.copy(n).addScaledVector(Tt, s);
    const m = l * p - d * h;
    if (m <= 0 && h - l >= 0 && d - p >= 0)
      return (
        Et.subVectors(r, i),
        (s = (h - l) / (h - l + (d - p))),
        e.copy(i).addScaledVector(Et, s)
      );
    const v = 1 / (m + f + u);
    return (
      (o = f * v),
      (s = u * v),
      e.copy(n).addScaledVector(St, o).addScaledVector(Tt, s)
    );
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
const Ct = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ot = { h: 0, s: 0, l: 0 },
  Nt = { h: 0, s: 0, l: 0 };
function It(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + 6 * (e - t) * n
      : n < 0.5
      ? e
      : n < 2 / 3
      ? t + 6 * (e - t) * (2 / 3 - n)
      : t
  );
}
function Dt(t) {
  return t < 0.04045
    ? 0.0773993808 * t
    : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
}
function Bt(t) {
  return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
class zt {
  constructor(t, e, n) {
    return (
      Object.defineProperty(this, "isColor", { value: !0 }),
      void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
    );
  }
  set(t) {
    return (
      t && t.isColor
        ? this.copy(t)
        : "number" == typeof t
        ? this.setHex(t)
        : "string" == typeof t && this.setStyle(t),
      this
    );
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  }
  setHex(t) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (255 & t) / 255),
      this
    );
  }
  setRGB(t, e, n) {
    return (this.r = t), (this.g = e), (this.b = n), this;
  }
  setHSL(t, e, n) {
    if (
      ((t = o.euclideanModulo(t, 1)),
      (e = o.clamp(e, 0, 1)),
      (n = o.clamp(n, 0, 1)),
      0 === e)
    )
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        r = 2 * n - i;
      (this.r = It(r, i, t + 1 / 3)),
        (this.g = It(r, i, t)),
        (this.b = It(r, i, t - 1 / 3));
    }
    return this;
  }
  setStyle(t) {
    function e(e) {
      void 0 !== e &&
        parseFloat(e) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
    }
    let n;
    if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
      let t;
      const i = n[1],
        r = n[2];
      switch (i) {
        case "rgb":
        case "rgba":
          if (
            (t =
              /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                r
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
              e(t[5]),
              this
            );
          if (
            (t =
              /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                r
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
              e(t[5]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (t =
              /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                r
              ))
          ) {
            const n = parseFloat(t[1]) / 360,
              i = parseInt(t[2], 10) / 100,
              r = parseInt(t[3], 10) / 100;
            return e(t[5]), this.setHSL(n, i, r);
          }
      }
    } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
      const t = n[1],
        e = t.length;
      if (3 === e)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
          (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
          (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
          this
        );
      if (6 === e)
        return (
          (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
          (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
          (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
          this
        );
    }
    return t && t.length > 0 ? this.setColorName(t) : this;
  }
  setColorName(t) {
    const e = Ct[t];
    return (
      void 0 !== e
        ? this.setHex(e)
        : console.warn("THREE.Color: Unknown color " + t),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  }
  copyGammaToLinear(t, e) {
    return (
      void 0 === e && (e = 2),
      (this.r = Math.pow(t.r, e)),
      (this.g = Math.pow(t.g, e)),
      (this.b = Math.pow(t.b, e)),
      this
    );
  }
  copyLinearToGamma(t, e) {
    void 0 === e && (e = 2);
    const n = e > 0 ? 1 / e : 1;
    return (
      (this.r = Math.pow(t.r, n)),
      (this.g = Math.pow(t.g, n)),
      (this.b = Math.pow(t.b, n)),
      this
    );
  }
  convertGammaToLinear(t) {
    return this.copyGammaToLinear(this, t), this;
  }
  convertLinearToGamma(t) {
    return this.copyLinearToGamma(this, t), this;
  }
  copySRGBToLinear(t) {
    return (this.r = Dt(t.r)), (this.g = Dt(t.g)), (this.b = Dt(t.b)), this;
  }
  copyLinearToSRGB(t) {
    return (this.r = Bt(t.r)), (this.g = Bt(t.g)), (this.b = Bt(t.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return (
      ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
    );
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(t) {
    void 0 === t &&
      (console.warn("THREE.Color: .getHSL() target is now required"),
      (t = { h: 0, s: 0, l: 0 }));
    const e = this.r,
      n = this.g,
      i = this.b,
      r = Math.max(e, n, i),
      o = Math.min(e, n, i);
    let s, a;
    const c = (o + r) / 2;
    if (o === r) (s = 0), (a = 0);
    else {
      const t = r - o;
      switch (((a = c <= 0.5 ? t / (r + o) : t / (2 - r - o)), r)) {
        case e:
          s = (n - i) / t + (n < i ? 6 : 0);
          break;
        case n:
          s = (i - e) / t + 2;
          break;
        case i:
          s = (e - n) / t + 4;
      }
      s /= 6;
    }
    return (t.h = s), (t.s = a), (t.l = c), t;
  }
  getStyle() {
    return (
      "rgb(" +
      ((255 * this.r) | 0) +
      "," +
      ((255 * this.g) | 0) +
      "," +
      ((255 * this.b) | 0) +
      ")"
    );
  }
  offsetHSL(t, e, n) {
    return (
      this.getHSL(Ot),
      (Ot.h += t),
      (Ot.s += e),
      (Ot.l += n),
      this.setHSL(Ot.h, Ot.s, Ot.l),
      this
    );
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    );
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  }
  lerpHSL(t, e) {
    this.getHSL(Ot), t.getHSL(Nt);
    const n = o.lerp(Ot.h, Nt.h, e),
      i = o.lerp(Ot.s, Nt.s, e),
      r = o.lerp(Ot.l, Nt.l, e);
    return this.setHSL(n, i, r), this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e) {
    return (
      void 0 === e && (e = 0),
      (this.r = t[e]),
      (this.g = t[e + 1]),
      (this.b = t[e + 2]),
      this
    );
  }
  toArray(t, e) {
    return (
      void 0 === t && (t = []),
      void 0 === e && (e = 0),
      (t[e] = this.r),
      (t[e + 1] = this.g),
      (t[e + 2] = this.b),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)),
      (this.g = t.getY(e)),
      (this.b = t.getZ(e)),
      !0 === t.normalized &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
}
(zt.NAMES = Ct),
  (zt.prototype.r = 1),
  (zt.prototype.g = 1),
  (zt.prototype.b = 1);
class Ft {
  constructor(t, e, n, i, r, o) {
    (this.a = t),
      (this.b = e),
      (this.c = n),
      (this.normal = i && i.isVector3 ? i : new g()),
      (this.vertexNormals = Array.isArray(i) ? i : []),
      (this.color = r && r.isColor ? r : new zt()),
      (this.vertexColors = Array.isArray(r) ? r : []),
      (this.materialIndex = void 0 !== o ? o : 0);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.a = t.a),
      (this.b = t.b),
      (this.c = t.c),
      this.normal.copy(t.normal),
      this.color.copy(t.color),
      (this.materialIndex = t.materialIndex);
    for (let e = 0, n = t.vertexNormals.length; e < n; e++)
      this.vertexNormals[e] = t.vertexNormals[e].clone();
    for (let e = 0, n = t.vertexColors.length; e < n; e++)
      this.vertexColors[e] = t.vertexColors[e].clone();
    return this;
  }
}
let Ut = 0;
function Gt() {
  Object.defineProperty(this, "id", { value: Ut++ }),
    (this.uuid = o.generateUUID()),
    (this.name = ""),
    (this.type = "Material"),
    (this.fog = !0),
    (this.blending = 1),
    (this.side = 0),
    (this.flatShading = !1),
    (this.vertexColors = !1),
    (this.opacity = 1),
    (this.transparent = !1),
    (this.blendSrc = 204),
    (this.blendDst = 205),
    (this.blendEquation = 100),
    (this.blendSrcAlpha = null),
    (this.blendDstAlpha = null),
    (this.blendEquationAlpha = null),
    (this.depthFunc = 3),
    (this.depthTest = !0),
    (this.depthWrite = !0),
    (this.stencilWriteMask = 255),
    (this.stencilFunc = 519),
    (this.stencilRef = 0),
    (this.stencilFuncMask = 255),
    (this.stencilFail = 7680),
    (this.stencilZFail = 7680),
    (this.stencilZPass = 7680),
    (this.stencilWrite = !1),
    (this.clippingPlanes = null),
    (this.clipIntersection = !1),
    (this.clipShadows = !1),
    (this.shadowSide = null),
    (this.colorWrite = !0),
    (this.precision = null),
    (this.polygonOffset = !1),
    (this.polygonOffsetFactor = 0),
    (this.polygonOffsetUnits = 0),
    (this.dithering = !1),
    (this.alphaTest = 0),
    (this.premultipliedAlpha = !1),
    (this.visible = !0),
    (this.toneMapped = !0),
    (this.userData = {}),
    (this.version = 0);
}
function Ht(t) {
  Gt.call(this),
    (this.type = "MeshBasicMaterial"),
    (this.color = new zt(16777215)),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.specularMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.combine = 0),
    (this.reflectivity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    this.setValues(t);
}
(Gt.prototype = Object.assign(Object.create(n.prototype), {
  constructor: Gt,
  isMaterial: !0,
  onBeforeCompile: function () {},
  customProgramCacheKey: function () {
    return this.onBeforeCompile.toString();
  },
  setValues: function (t) {
    if (void 0 !== t)
      for (const e in t) {
        const n = t[e];
        if (void 0 === n) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if ("shading" === e) {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          ),
            (this.flatShading = 1 === n);
          continue;
        }
        const i = this[e];
        void 0 !== i
          ? i && i.isColor
            ? i.set(n)
            : i && i.isVector3 && n && n.isVector3
            ? i.copy(n)
            : (this[e] = n)
          : console.warn(
              "THREE." +
                this.type +
                ": '" +
                e +
                "' is not a property of this material."
            );
      }
  },
  toJSON: function (t) {
    const e = void 0 === t || "string" == typeof t;
    e && (t = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    function i(t) {
      const e = [];
      for (const n in t) {
        const i = t[n];
        delete i.metadata, e.push(i);
      }
      return e;
    }
    if (
      ((n.uuid = this.uuid),
      (n.type = this.type),
      "" !== this.name && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      void 0 !== this.roughness && (n.roughness = this.roughness),
      void 0 !== this.metalness && (n.metalness = this.metalness),
      this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        1 !== this.emissiveIntensity &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      void 0 !== this.shininess && (n.shininess = this.shininess),
      void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
      void 0 !== this.clearcoatRoughness &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        (n.lightMap = this.lightMap.toJSON(t).uuid),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(t).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(t).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(t).uuid),
        (n.reflectivity = this.reflectivity),
        (n.refractionRatio = this.refractionRatio),
        void 0 !== this.combine && (n.combine = this.combine),
        void 0 !== this.envMapIntensity &&
          (n.envMapIntensity = this.envMapIntensity)),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
      void 0 !== this.size && (n.size = this.size),
      void 0 !== this.sizeAttenuation &&
        (n.sizeAttenuation = this.sizeAttenuation),
      1 !== this.blending && (n.blending = this.blending),
      !0 === this.flatShading && (n.flatShading = this.flatShading),
      0 !== this.side && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      !0 === this.transparent && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
      !0 === this.polygonOffset && (n.polygonOffset = !0),
      0 !== this.polygonOffsetFactor &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      0 !== this.polygonOffsetUnits &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
      void 0 !== this.dashSize && (n.dashSize = this.dashSize),
      void 0 !== this.gapSize && (n.gapSize = this.gapSize),
      void 0 !== this.scale && (n.scale = this.scale),
      !0 === this.dithering && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      !0 === this.premultipliedAlpha &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      !0 === this.wireframe && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      "round" !== this.wireframeLinecap &&
        (n.wireframeLinecap = this.wireframeLinecap),
      "round" !== this.wireframeLinejoin &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      !0 === this.morphTargets && (n.morphTargets = !0),
      !0 === this.morphNormals && (n.morphNormals = !0),
      !0 === this.skinning && (n.skinning = !0),
      !1 === this.visible && (n.visible = !1),
      !1 === this.toneMapped && (n.toneMapped = !1),
      "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
      e)
    ) {
      const e = i(t.textures),
        r = i(t.images);
      e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
    }
    return n;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (t) {
    (this.name = t.name),
      (this.fog = t.fog),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.flatShading = t.flatShading),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite);
    const e = t.clippingPlanes;
    let n = null;
    if (null !== e) {
      const t = e.length;
      n = new Array(t);
      for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
})),
  Object.defineProperty(Gt.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++;
    },
  }),
  (Ht.prototype = Object.create(Gt.prototype)),
  (Ht.prototype.constructor = Ht),
  (Ht.prototype.isMeshBasicMaterial = !0),
  (Ht.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      this
    );
  });
const kt = new g(),
  Vt = new s();
function jt(t, e, n) {
  if (Array.isArray(t))
    throw new TypeError(
      "THREE.BufferAttribute: array should be a Typed Array."
    );
  (this.name = ""),
    (this.array = t),
    (this.itemSize = e),
    (this.count = void 0 !== t ? t.length / e : 0),
    (this.normalized = !0 === n),
    (this.usage = 35044),
    (this.updateRange = { offset: 0, count: -1 }),
    (this.version = 0);
}
function Wt(t, e, n) {
  jt.call(this, new Int8Array(t), e, n);
}
function qt(t, e, n) {
  jt.call(this, new Uint8Array(t), e, n);
}
function Xt(t, e, n) {
  jt.call(this, new Uint8ClampedArray(t), e, n);
}
function Yt(t, e, n) {
  jt.call(this, new Int16Array(t), e, n);
}
function Zt(t, e, n) {
  jt.call(this, new Uint16Array(t), e, n);
}
function Jt(t, e, n) {
  jt.call(this, new Int32Array(t), e, n);
}
function Kt(t, e, n) {
  jt.call(this, new Uint32Array(t), e, n);
}
function Qt(t, e, n) {
  jt.call(this, new Float32Array(t), e, n);
}
function $t(t, e, n) {
  jt.call(this, new Float64Array(t), e, n);
}
Object.defineProperty(jt.prototype, "needsUpdate", {
  set: function (t) {
    !0 === t && this.version++;
  },
}),
  Object.assign(jt.prototype, {
    isBufferAttribute: !0,
    onUploadCallback: function () {},
    setUsage: function (t) {
      return (this.usage = t), this;
    },
    copy: function (t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        this
      );
    },
    copyAt: function (t, e, n) {
      (t *= this.itemSize), (n *= e.itemSize);
      for (let i = 0, r = this.itemSize; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    },
    copyArray: function (t) {
      return this.array.set(t), this;
    },
    copyColorsArray: function (t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyColorsArray(): color is undefined",
            i
          ),
          (r = new zt())),
          (e[n++] = r.r),
          (e[n++] = r.g),
          (e[n++] = r.b);
      }
      return this;
    },
    copyVector2sArray: function (t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
            i
          ),
          (r = new s())),
          (e[n++] = r.x),
          (e[n++] = r.y);
      }
      return this;
    },
    copyVector3sArray: function (t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
            i
          ),
          (r = new g())),
          (e[n++] = r.x),
          (e[n++] = r.y),
          (e[n++] = r.z);
      }
      return this;
    },
    copyVector4sArray: function (t) {
      const e = this.array;
      let n = 0;
      for (let i = 0, r = t.length; i < r; i++) {
        let r = t[i];
        void 0 === r &&
          (console.warn(
            "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
            i
          ),
          (r = new d())),
          (e[n++] = r.x),
          (e[n++] = r.y),
          (e[n++] = r.z),
          (e[n++] = r.w);
      }
      return this;
    },
    applyMatrix3: function (t) {
      if (2 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          Vt.fromBufferAttribute(this, e),
            Vt.applyMatrix3(t),
            this.setXY(e, Vt.x, Vt.y);
      else if (3 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          kt.fromBufferAttribute(this, e),
            kt.applyMatrix3(t),
            this.setXYZ(e, kt.x, kt.y, kt.z);
      return this;
    },
    applyMatrix4: function (t) {
      for (let e = 0, n = this.count; e < n; e++)
        (kt.x = this.getX(e)),
          (kt.y = this.getY(e)),
          (kt.z = this.getZ(e)),
          kt.applyMatrix4(t),
          this.setXYZ(e, kt.x, kt.y, kt.z);
      return this;
    },
    applyNormalMatrix: function (t) {
      for (let e = 0, n = this.count; e < n; e++)
        (kt.x = this.getX(e)),
          (kt.y = this.getY(e)),
          (kt.z = this.getZ(e)),
          kt.applyNormalMatrix(t),
          this.setXYZ(e, kt.x, kt.y, kt.z);
      return this;
    },
    transformDirection: function (t) {
      for (let e = 0, n = this.count; e < n; e++)
        (kt.x = this.getX(e)),
          (kt.y = this.getY(e)),
          (kt.z = this.getZ(e)),
          kt.transformDirection(t),
          this.setXYZ(e, kt.x, kt.y, kt.z);
      return this;
    },
    set: function (t, e) {
      return void 0 === e && (e = 0), this.array.set(t, e), this;
    },
    getX: function (t) {
      return this.array[t * this.itemSize];
    },
    setX: function (t, e) {
      return (this.array[t * this.itemSize] = e), this;
    },
    getY: function (t) {
      return this.array[t * this.itemSize + 1];
    },
    setY: function (t, e) {
      return (this.array[t * this.itemSize + 1] = e), this;
    },
    getZ: function (t) {
      return this.array[t * this.itemSize + 2];
    },
    setZ: function (t, e) {
      return (this.array[t * this.itemSize + 2] = e), this;
    },
    getW: function (t) {
      return this.array[t * this.itemSize + 3];
    },
    setW: function (t, e) {
      return (this.array[t * this.itemSize + 3] = e), this;
    },
    setXY: function (t, e, n) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        this
      );
    },
    setXYZ: function (t, e, n, i) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        this
      );
    },
    setXYZW: function (t, e, n, i, r) {
      return (
        (t *= this.itemSize),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        (this.array[t + 3] = r),
        this
      );
    },
    onUpload: function (t) {
      return (this.onUploadCallback = t), this;
    },
    clone: function () {
      return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function () {
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized,
      };
    },
  }),
  (Wt.prototype = Object.create(jt.prototype)),
  (Wt.prototype.constructor = Wt),
  (qt.prototype = Object.create(jt.prototype)),
  (qt.prototype.constructor = qt),
  (Xt.prototype = Object.create(jt.prototype)),
  (Xt.prototype.constructor = Xt),
  (Yt.prototype = Object.create(jt.prototype)),
  (Yt.prototype.constructor = Yt),
  (Zt.prototype = Object.create(jt.prototype)),
  (Zt.prototype.constructor = Zt),
  (Jt.prototype = Object.create(jt.prototype)),
  (Jt.prototype.constructor = Jt),
  (Kt.prototype = Object.create(jt.prototype)),
  (Kt.prototype.constructor = Kt),
  (Qt.prototype = Object.create(jt.prototype)),
  (Qt.prototype.constructor = Qt),
  ($t.prototype = Object.create(jt.prototype)),
  ($t.prototype.constructor = $t);
class te {
  constructor() {
    (this.vertices = []),
      (this.normals = []),
      (this.colors = []),
      (this.uvs = []),
      (this.uvs2 = []),
      (this.groups = []),
      (this.morphTargets = {}),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.verticesNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }
  computeGroups(t) {
    const e = [];
    let n, i, r;
    const o = t.faces;
    for (i = 0; i < o.length; i++) {
      const t = o[i];
      t.materialIndex !== r &&
        ((r = t.materialIndex),
        void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)),
        (n = { start: 3 * i, materialIndex: r }));
    }
    void 0 !== n && ((n.count = 3 * i - n.start), e.push(n)), (this.groups = e);
  }
  fromGeometry(t) {
    const e = t.faces,
      n = t.vertices,
      i = t.faceVertexUvs,
      r = i[0] && i[0].length > 0,
      o = i[1] && i[1].length > 0,
      a = t.morphTargets,
      c = a.length;
    let l;
    if (c > 0) {
      l = [];
      for (let t = 0; t < c; t++) l[t] = { name: a[t].name, data: [] };
      this.morphTargets.position = l;
    }
    const h = t.morphNormals,
      u = h.length;
    let d;
    if (u > 0) {
      d = [];
      for (let t = 0; t < u; t++) d[t] = { name: h[t].name, data: [] };
      this.morphTargets.normal = d;
    }
    const p = t.skinIndices,
      f = t.skinWeights,
      m = p.length === n.length,
      g = f.length === n.length;
    n.length > 0 &&
      0 === e.length &&
      console.error(
        "THREE.DirectGeometry: Faceless geometries are not supported."
      );
    for (let t = 0; t < e.length; t++) {
      const v = e[t];
      this.vertices.push(n[v.a], n[v.b], n[v.c]);
      const y = v.vertexNormals;
      if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
      else {
        const t = v.normal;
        this.normals.push(t, t, t);
      }
      const x = v.vertexColors;
      if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
      else {
        const t = v.color;
        this.colors.push(t, t, t);
      }
      if (!0 === r) {
        const e = i[0][t];
        void 0 !== e
          ? this.uvs.push(e[0], e[1], e[2])
          : (console.warn(
              "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
              t
            ),
            this.uvs.push(new s(), new s(), new s()));
      }
      if (!0 === o) {
        const e = i[1][t];
        void 0 !== e
          ? this.uvs2.push(e[0], e[1], e[2])
          : (console.warn(
              "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
              t
            ),
            this.uvs2.push(new s(), new s(), new s()));
      }
      for (let t = 0; t < c; t++) {
        const e = a[t].vertices;
        l[t].data.push(e[v.a], e[v.b], e[v.c]);
      }
      for (let e = 0; e < u; e++) {
        const n = h[e].vertexNormals[t];
        d[e].data.push(n.a, n.b, n.c);
      }
      m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]),
        g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]);
    }
    return (
      this.computeGroups(t),
      (this.verticesNeedUpdate = t.verticesNeedUpdate),
      (this.normalsNeedUpdate = t.normalsNeedUpdate),
      (this.colorsNeedUpdate = t.colorsNeedUpdate),
      (this.uvsNeedUpdate = t.uvsNeedUpdate),
      (this.groupsNeedUpdate = t.groupsNeedUpdate),
      null !== t.boundingSphere &&
        (this.boundingSphere = t.boundingSphere.clone()),
      null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
      this
    );
  }
}
function ee(t) {
  if (0 === t.length) return -1 / 0;
  let e = t[0];
  for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
  return e;
}
let ne = 1;
const ie = new j(),
  re = new mt(),
  oe = new g(),
  se = new x(),
  ae = new x(),
  ce = new g();
function le() {
  Object.defineProperty(this, "id", { value: (ne += 2) }),
    (this.uuid = o.generateUUID()),
    (this.name = ""),
    (this.type = "BufferGeometry"),
    (this.index = null),
    (this.attributes = {}),
    (this.morphAttributes = {}),
    (this.morphTargetsRelative = !1),
    (this.groups = []),
    (this.boundingBox = null),
    (this.boundingSphere = null),
    (this.drawRange = { start: 0, count: 1 / 0 }),
    (this.userData = {});
}
le.prototype = Object.assign(Object.create(n.prototype), {
  constructor: le,
  isBufferGeometry: !0,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (t) {
    Array.isArray(t)
      ? (this.index = new (ee(t) > 65535 ? Kt : Zt)(t, 1))
      : (this.index = t);
  },
  getAttribute: function (t) {
    return this.attributes[t];
  },
  setAttribute: function (t, e) {
    return (this.attributes[t] = e), this;
  },
  deleteAttribute: function (t) {
    return delete this.attributes[t], this;
  },
  addGroup: function (t, e, n) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: void 0 !== n ? n : 0,
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (t, e) {
    (this.drawRange.start = t), (this.drawRange.count = e);
  },
  applyMatrix4: function (t) {
    const e = this.attributes.position;
    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
    const n = this.attributes.normal;
    if (void 0 !== n) {
      const e = new a().getNormalMatrix(t);
      n.applyNormalMatrix(e), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  },
  rotateX: function (t) {
    return ie.makeRotationX(t), this.applyMatrix4(ie), this;
  },
  rotateY: function (t) {
    return ie.makeRotationY(t), this.applyMatrix4(ie), this;
  },
  rotateZ: function (t) {
    return ie.makeRotationZ(t), this.applyMatrix4(ie), this;
  },
  translate: function (t, e, n) {
    return ie.makeTranslation(t, e, n), this.applyMatrix4(ie), this;
  },
  scale: function (t, e, n) {
    return ie.makeScale(t, e, n), this.applyMatrix4(ie), this;
  },
  lookAt: function (t) {
    return re.lookAt(t), re.updateMatrix(), this.applyMatrix4(re.matrix), this;
  },
  center: function () {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(oe).negate(),
      this.translate(oe.x, oe.y, oe.z),
      this
    );
  },
  setFromObject: function (t) {
    const e = t.geometry;
    if (t.isPoints || t.isLine) {
      const t = new Qt(3 * e.vertices.length, 3),
        n = new Qt(3 * e.colors.length, 3);
      if (
        (this.setAttribute("position", t.copyVector3sArray(e.vertices)),
        this.setAttribute("color", n.copyColorsArray(e.colors)),
        e.lineDistances && e.lineDistances.length === e.vertices.length)
      ) {
        const t = new Qt(e.lineDistances.length, 1);
        this.setAttribute("lineDistance", t.copyArray(e.lineDistances));
      }
      null !== e.boundingSphere &&
        (this.boundingSphere = e.boundingSphere.clone()),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone());
    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
    return this;
  },
  setFromPoints: function (t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n];
      e.push(i.x, i.y, i.z || 0);
    }
    return this.setAttribute("position", new Qt(e, 3)), this;
  },
  updateFromObject: function (t) {
    let e = t.geometry;
    if (t.isMesh) {
      let t = e.__directGeometry;
      if (
        (!0 === e.elementsNeedUpdate &&
          ((t = void 0), (e.elementsNeedUpdate = !1)),
        void 0 === t)
      )
        return this.fromGeometry(e);
      (t.verticesNeedUpdate = e.verticesNeedUpdate),
        (t.normalsNeedUpdate = e.normalsNeedUpdate),
        (t.colorsNeedUpdate = e.colorsNeedUpdate),
        (t.uvsNeedUpdate = e.uvsNeedUpdate),
        (t.groupsNeedUpdate = e.groupsNeedUpdate),
        (e.verticesNeedUpdate = !1),
        (e.normalsNeedUpdate = !1),
        (e.colorsNeedUpdate = !1),
        (e.uvsNeedUpdate = !1),
        (e.groupsNeedUpdate = !1),
        (e = t);
    }
    if (!0 === e.verticesNeedUpdate) {
      const t = this.attributes.position;
      void 0 !== t && (t.copyVector3sArray(e.vertices), (t.needsUpdate = !0)),
        (e.verticesNeedUpdate = !1);
    }
    if (!0 === e.normalsNeedUpdate) {
      const t = this.attributes.normal;
      void 0 !== t && (t.copyVector3sArray(e.normals), (t.needsUpdate = !0)),
        (e.normalsNeedUpdate = !1);
    }
    if (!0 === e.colorsNeedUpdate) {
      const t = this.attributes.color;
      void 0 !== t && (t.copyColorsArray(e.colors), (t.needsUpdate = !0)),
        (e.colorsNeedUpdate = !1);
    }
    if (e.uvsNeedUpdate) {
      const t = this.attributes.uv;
      void 0 !== t && (t.copyVector2sArray(e.uvs), (t.needsUpdate = !0)),
        (e.uvsNeedUpdate = !1);
    }
    if (e.lineDistancesNeedUpdate) {
      const t = this.attributes.lineDistance;
      void 0 !== t && (t.copyArray(e.lineDistances), (t.needsUpdate = !0)),
        (e.lineDistancesNeedUpdate = !1);
    }
    return (
      e.groupsNeedUpdate &&
        (e.computeGroups(t.geometry),
        (this.groups = e.groups),
        (e.groupsNeedUpdate = !1)),
      this
    );
  },
  fromGeometry: function (t) {
    return (
      (t.__directGeometry = new te().fromGeometry(t)),
      this.fromDirectGeometry(t.__directGeometry)
    );
  },
  fromDirectGeometry: function (t) {
    const e = new Float32Array(3 * t.vertices.length);
    if (
      (this.setAttribute(
        "position",
        new jt(e, 3).copyVector3sArray(t.vertices)
      ),
      t.normals.length > 0)
    ) {
      const e = new Float32Array(3 * t.normals.length);
      this.setAttribute("normal", new jt(e, 3).copyVector3sArray(t.normals));
    }
    if (t.colors.length > 0) {
      const e = new Float32Array(3 * t.colors.length);
      this.setAttribute("color", new jt(e, 3).copyColorsArray(t.colors));
    }
    if (t.uvs.length > 0) {
      const e = new Float32Array(2 * t.uvs.length);
      this.setAttribute("uv", new jt(e, 2).copyVector2sArray(t.uvs));
    }
    if (t.uvs2.length > 0) {
      const e = new Float32Array(2 * t.uvs2.length);
      this.setAttribute("uv2", new jt(e, 2).copyVector2sArray(t.uvs2));
    }
    this.groups = t.groups;
    for (const e in t.morphTargets) {
      const n = [],
        i = t.morphTargets[e];
      for (let t = 0, e = i.length; t < e; t++) {
        const e = i[t],
          r = new Qt(3 * e.data.length, 3);
        (r.name = e.name), n.push(r.copyVector3sArray(e.data));
      }
      this.morphAttributes[e] = n;
    }
    if (t.skinIndices.length > 0) {
      const e = new Qt(4 * t.skinIndices.length, 4);
      this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices));
    }
    if (t.skinWeights.length > 0) {
      const e = new Qt(4 * t.skinWeights.length, 4);
      this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights));
    }
    return (
      null !== t.boundingSphere &&
        (this.boundingSphere = t.boundingSphere.clone()),
      null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
      this
    );
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new x());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingBox.set(
          new g(-1 / 0, -1 / 0, -1 / 0),
          new g(1 / 0, 1 / 0, 1 / 0)
        )
      );
    if (void 0 !== t) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t];
          se.setFromBufferAttribute(n),
            this.morphTargetsRelative
              ? (ce.addVectors(this.boundingBox.min, se.min),
                this.boundingBox.expandByPoint(ce),
                ce.addVectors(this.boundingBox.max, se.max),
                this.boundingBox.expandByPoint(ce))
              : (this.boundingBox.expandByPoint(se.min),
                this.boundingBox.expandByPoint(se.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new D());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingSphere.set(new g(), 1 / 0)
      );
    if (t) {
      const n = this.boundingSphere.center;
      if ((se.setFromBufferAttribute(t), e))
        for (let t = 0, n = e.length; t < n; t++) {
          const n = e[t];
          ae.setFromBufferAttribute(n),
            this.morphTargetsRelative
              ? (ce.addVectors(se.min, ae.min),
                se.expandByPoint(ce),
                ce.addVectors(se.max, ae.max),
                se.expandByPoint(ce))
              : (se.expandByPoint(ae.min), se.expandByPoint(ae.max));
        }
      se.getCenter(n);
      let i = 0;
      for (let e = 0, r = t.count; e < r; e++)
        ce.fromBufferAttribute(t, e),
          (i = Math.max(i, n.distanceToSquared(ce)));
      if (e)
        for (let r = 0, o = e.length; r < o; r++) {
          const o = e[r],
            s = this.morphTargetsRelative;
          for (let e = 0, r = o.count; e < r; e++)
            ce.fromBufferAttribute(o, e),
              s && (oe.fromBufferAttribute(t, e), ce.add(oe)),
              (i = Math.max(i, n.distanceToSquared(ce)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  },
  computeFaceNormals: function () {},
  computeVertexNormals: function () {
    const t = this.index,
      e = this.getAttribute("position");
    if (void 0 !== e) {
      let n = this.getAttribute("normal");
      if (void 0 === n)
        (n = new jt(new Float32Array(3 * e.count), 3)),
          this.setAttribute("normal", n);
      else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
      const i = new g(),
        r = new g(),
        o = new g(),
        s = new g(),
        a = new g(),
        c = new g(),
        l = new g(),
        h = new g();
      if (t)
        for (let u = 0, d = t.count; u < d; u += 3) {
          const d = t.getX(u + 0),
            p = t.getX(u + 1),
            f = t.getX(u + 2);
          i.fromBufferAttribute(e, d),
            r.fromBufferAttribute(e, p),
            o.fromBufferAttribute(e, f),
            l.subVectors(o, r),
            h.subVectors(i, r),
            l.cross(h),
            s.fromBufferAttribute(n, d),
            a.fromBufferAttribute(n, p),
            c.fromBufferAttribute(n, f),
            s.add(l),
            a.add(l),
            c.add(l),
            n.setXYZ(d, s.x, s.y, s.z),
            n.setXYZ(p, a.x, a.y, a.z),
            n.setXYZ(f, c.x, c.y, c.z);
        }
      else
        for (let t = 0, s = e.count; t < s; t += 3)
          i.fromBufferAttribute(e, t + 0),
            r.fromBufferAttribute(e, t + 1),
            o.fromBufferAttribute(e, t + 2),
            l.subVectors(o, r),
            h.subVectors(i, r),
            l.cross(h),
            n.setXYZ(t + 0, l.x, l.y, l.z),
            n.setXYZ(t + 1, l.x, l.y, l.z),
            n.setXYZ(t + 2, l.x, l.y, l.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  },
  merge: function (t, e) {
    if (!t || !t.isBufferGeometry)
      return void console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
    void 0 === e &&
      ((e = 0),
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      ));
    const n = this.attributes;
    for (const i in n) {
      if (void 0 === t.attributes[i]) continue;
      const r = n[i].array,
        o = t.attributes[i],
        s = o.array,
        a = o.itemSize * e,
        c = Math.min(s.length, r.length - a);
      for (let t = 0, e = a; t < c; t++, e++) r[e] = s[t];
    }
    return this;
  },
  normalizeNormals: function () {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      ce.fromBufferAttribute(t, e),
        ce.normalize(),
        t.setXYZ(e, ce.x, ce.y, ce.z);
  },
  toNonIndexed: function () {
    function t(t, e) {
      const n = t.array,
        i = t.itemSize,
        r = t.normalized,
        o = new n.constructor(e.length * i);
      let s = 0,
        a = 0;
      for (let t = 0, r = e.length; t < r; t++) {
        s = e[t] * i;
        for (let t = 0; t < i; t++) o[a++] = n[s++];
      }
      return new jt(o, i, r);
    }
    if (null === this.index)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."
        ),
        this
      );
    const e = new le(),
      n = this.index.array,
      i = this.attributes;
    for (const r in i) {
      const o = t(i[r], n);
      e.setAttribute(r, o);
    }
    const r = this.morphAttributes;
    for (const i in r) {
      const o = [],
        s = r[i];
      for (let e = 0, i = s.length; e < i; e++) {
        const i = t(s[e], n);
        o.push(i);
      }
      e.morphAttributes[i] = o;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let t = 0, n = o.length; t < n; t++) {
      const n = o[t];
      e.addGroup(n.start, n.count, n.materialIndex);
    }
    return e;
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      "" !== this.name && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      const e = this.parameters;
      for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    null !== e &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      });
    const n = this.attributes;
    for (const e in n) {
      const i = n[e],
        r = i.toJSON(t.data);
      "" !== i.name && (r.name = i.name), (t.data.attributes[e] = r);
    }
    const i = {};
    let r = !1;
    for (const e in this.morphAttributes) {
      const n = this.morphAttributes[e],
        o = [];
      for (let e = 0, i = n.length; e < i; e++) {
        const i = n[e],
          r = i.toJSON(t.data);
        "" !== i.name && (r.name = i.name), o.push(r);
      }
      o.length > 0 && ((i[e] = o), (r = !0));
    }
    r &&
      ((t.data.morphAttributes = i),
      (t.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const s = this.boundingSphere;
    return (
      null !== s &&
        (t.data.boundingSphere = {
          center: s.center.toArray(),
          radius: s.radius,
        }),
      t
    );
  },
  clone: function () {
    return new le().copy(this);
  },
  copy: function (t) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const e = {};
    this.name = t.name;
    const n = t.index;
    null !== n && this.setIndex(n.clone(e));
    const i = t.attributes;
    for (const t in i) {
      const n = i[t];
      this.setAttribute(t, n.clone(e));
    }
    const r = t.morphAttributes;
    for (const t in r) {
      const n = [],
        i = r[t];
      for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
      this.morphAttributes[t] = n;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let t = 0, e = o.length; t < e; t++) {
      const e = o[t];
      this.addGroup(e.start, e.count, e.materialIndex);
    }
    const s = t.boundingBox;
    null !== s && (this.boundingBox = s.clone());
    const a = t.boundingSphere;
    return (
      null !== a && (this.boundingSphere = a.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
const he = new j(),
  ue = new V(),
  de = new D(),
  pe = new g(),
  fe = new g(),
  me = new g(),
  ge = new g(),
  ve = new g(),
  ye = new g(),
  xe = new g(),
  be = new g(),
  _e = new g(),
  we = new s(),
  Me = new s(),
  Se = new s(),
  Te = new g(),
  Ee = new g();
function Ae(t, e) {
  mt.call(this),
    (this.type = "Mesh"),
    (this.geometry = void 0 !== t ? t : new le()),
    (this.material = void 0 !== e ? e : new Ht()),
    this.updateMorphTargets();
}
function Le(t, e, n, i, r, o, s, a) {
  let c;
  if (
    ((c =
      1 === e.side
        ? i.intersectTriangle(s, o, r, !0, a)
        : i.intersectTriangle(r, o, s, 2 !== e.side, a)),
    null === c)
  )
    return null;
  Ee.copy(a), Ee.applyMatrix4(t.matrixWorld);
  const l = n.ray.origin.distanceTo(Ee);
  return l < n.near || l > n.far
    ? null
    : { distance: l, point: Ee.clone(), object: t };
}
function Re(t, e, n, i, r, o, a, c, l, h, u, d) {
  pe.fromBufferAttribute(r, h),
    fe.fromBufferAttribute(r, u),
    me.fromBufferAttribute(r, d);
  const p = t.morphTargetInfluences;
  if (e.morphTargets && o && p) {
    xe.set(0, 0, 0), be.set(0, 0, 0), _e.set(0, 0, 0);
    for (let t = 0, e = o.length; t < e; t++) {
      const e = p[t],
        n = o[t];
      0 !== e &&
        (ge.fromBufferAttribute(n, h),
        ve.fromBufferAttribute(n, u),
        ye.fromBufferAttribute(n, d),
        a
          ? (xe.addScaledVector(ge, e),
            be.addScaledVector(ve, e),
            _e.addScaledVector(ye, e))
          : (xe.addScaledVector(ge.sub(pe), e),
            be.addScaledVector(ve.sub(fe), e),
            _e.addScaledVector(ye.sub(me), e)));
    }
    pe.add(xe), fe.add(be), me.add(_e);
  }
  t.isSkinnedMesh &&
    (t.boneTransform(h, pe), t.boneTransform(u, fe), t.boneTransform(d, me));
  const f = Le(t, e, n, i, pe, fe, me, Te);
  if (f) {
    c &&
      (we.fromBufferAttribute(c, h),
      Me.fromBufferAttribute(c, u),
      Se.fromBufferAttribute(c, d),
      (f.uv = Pt.getUV(Te, pe, fe, me, we, Me, Se, new s()))),
      l &&
        (we.fromBufferAttribute(l, h),
        Me.fromBufferAttribute(l, u),
        Se.fromBufferAttribute(l, d),
        (f.uv2 = Pt.getUV(Te, pe, fe, me, we, Me, Se, new s())));
    const t = new Ft(h, u, d);
    Pt.getNormal(pe, fe, me, t.normal), (f.face = t);
  }
  return f;
}
Ae.prototype = Object.assign(Object.create(mt.prototype), {
  constructor: Ae,
  isMesh: !0,
  copy: function (t) {
    return (
      mt.prototype.copy.call(this, t),
      void 0 !== t.morphTargetInfluences &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      void 0 !== t.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary
        )),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  },
  updateMorphTargets: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const t = e[n[0]];
        if (void 0 !== t) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[n] = e);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  },
  raycast: function (t, e) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    if (void 0 === i) return;
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      de.copy(n.boundingSphere),
      de.applyMatrix4(r),
      !1 === t.ray.intersectsSphere(de))
    )
      return;
    if (
      (he.getInverse(r),
      ue.copy(t.ray).applyMatrix4(he),
      null !== n.boundingBox && !1 === ue.intersectsBox(n.boundingBox))
    )
      return;
    let o;
    if (n.isBufferGeometry) {
      const r = n.index,
        s = n.attributes.position,
        a = n.morphAttributes.position,
        c = n.morphTargetsRelative,
        l = n.attributes.uv,
        h = n.attributes.uv2,
        u = n.groups,
        d = n.drawRange;
      if (null !== r)
        if (Array.isArray(i))
          for (let n = 0, p = u.length; n < p; n++) {
            const p = u[n],
              f = i[p.materialIndex];
            for (
              let n = Math.max(p.start, d.start),
                i = Math.min(p.start + p.count, d.start + d.count);
              n < i;
              n += 3
            ) {
              const i = r.getX(n),
                u = r.getX(n + 1),
                d = r.getX(n + 2);
              (o = Re(this, f, t, ue, s, a, c, l, h, i, u, d)),
                o &&
                  ((o.faceIndex = Math.floor(n / 3)),
                  (o.face.materialIndex = p.materialIndex),
                  e.push(o));
            }
          }
        else {
          for (
            let n = Math.max(0, d.start),
              u = Math.min(r.count, d.start + d.count);
            n < u;
            n += 3
          ) {
            const u = r.getX(n),
              d = r.getX(n + 1),
              p = r.getX(n + 2);
            (o = Re(this, i, t, ue, s, a, c, l, h, u, d, p)),
              o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
          }
        }
      else if (void 0 !== s)
        if (Array.isArray(i))
          for (let n = 0, r = u.length; n < r; n++) {
            const r = u[n],
              p = i[r.materialIndex];
            for (
              let n = Math.max(r.start, d.start),
                i = Math.min(r.start + r.count, d.start + d.count);
              n < i;
              n += 3
            ) {
              (o = Re(this, p, t, ue, s, a, c, l, h, n, n + 1, n + 2)),
                o &&
                  ((o.faceIndex = Math.floor(n / 3)),
                  (o.face.materialIndex = r.materialIndex),
                  e.push(o));
            }
          }
        else {
          for (
            let n = Math.max(0, d.start),
              r = Math.min(s.count, d.start + d.count);
            n < r;
            n += 3
          ) {
            (o = Re(this, i, t, ue, s, a, c, l, h, n, n + 1, n + 2)),
              o && ((o.faceIndex = Math.floor(n / 3)), e.push(o));
          }
        }
    } else if (n.isGeometry) {
      const r = Array.isArray(i),
        a = n.vertices,
        c = n.faces;
      let l;
      const h = n.faceVertexUvs[0];
      h.length > 0 && (l = h);
      for (let n = 0, h = c.length; n < h; n++) {
        const h = c[n],
          u = r ? i[h.materialIndex] : i;
        if (void 0 === u) continue;
        const d = a[h.a],
          p = a[h.b],
          f = a[h.c];
        if (((o = Le(this, u, t, ue, d, p, f, Te)), o)) {
          if (l && l[n]) {
            const t = l[n];
            we.copy(t[0]),
              Me.copy(t[1]),
              Se.copy(t[2]),
              (o.uv = Pt.getUV(Te, d, p, f, we, Me, Se, new s()));
          }
          (o.face = h), (o.faceIndex = n), e.push(o);
        }
      }
    }
  },
});
let Pe = 0;
const Ce = new j(),
  Oe = new mt(),
  Ne = new g();
function Ie() {
  Object.defineProperty(this, "id", { value: (Pe += 2) }),
    (this.uuid = o.generateUUID()),
    (this.name = ""),
    (this.type = "Geometry"),
    (this.vertices = []),
    (this.colors = []),
    (this.faces = []),
    (this.faceVertexUvs = [[]]),
    (this.morphTargets = []),
    (this.morphNormals = []),
    (this.skinWeights = []),
    (this.skinIndices = []),
    (this.lineDistances = []),
    (this.boundingBox = null),
    (this.boundingSphere = null),
    (this.elementsNeedUpdate = !1),
    (this.verticesNeedUpdate = !1),
    (this.uvsNeedUpdate = !1),
    (this.normalsNeedUpdate = !1),
    (this.colorsNeedUpdate = !1),
    (this.lineDistancesNeedUpdate = !1),
    (this.groupsNeedUpdate = !1);
}
Ie.prototype = Object.assign(Object.create(n.prototype), {
  constructor: Ie,
  isGeometry: !0,
  applyMatrix4: function (t) {
    const e = new a().getNormalMatrix(t);
    for (let e = 0, n = this.vertices.length; e < n; e++) {
      this.vertices[e].applyMatrix4(t);
    }
    for (let t = 0, n = this.faces.length; t < n; t++) {
      const n = this.faces[t];
      n.normal.applyMatrix3(e).normalize();
      for (let t = 0, i = n.vertexNormals.length; t < i; t++)
        n.vertexNormals[t].applyMatrix3(e).normalize();
    }
    return (
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      (this.verticesNeedUpdate = !0),
      (this.normalsNeedUpdate = !0),
      this
    );
  },
  rotateX: function (t) {
    return Ce.makeRotationX(t), this.applyMatrix4(Ce), this;
  },
  rotateY: function (t) {
    return Ce.makeRotationY(t), this.applyMatrix4(Ce), this;
  },
  rotateZ: function (t) {
    return Ce.makeRotationZ(t), this.applyMatrix4(Ce), this;
  },
  translate: function (t, e, n) {
    return Ce.makeTranslation(t, e, n), this.applyMatrix4(Ce), this;
  },
  scale: function (t, e, n) {
    return Ce.makeScale(t, e, n), this.applyMatrix4(Ce), this;
  },
  lookAt: function (t) {
    return Oe.lookAt(t), Oe.updateMatrix(), this.applyMatrix4(Oe.matrix), this;
  },
  fromBufferGeometry: function (t) {
    const e = this,
      n = null !== t.index ? t.index : void 0,
      i = t.attributes;
    if (void 0 === i.position)
      return (
        console.error(
          "THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."
        ),
        this
      );
    const r = i.position,
      o = i.normal,
      a = i.color,
      c = i.uv,
      l = i.uv2;
    void 0 !== l && (this.faceVertexUvs[1] = []);
    for (let t = 0; t < r.count; t++)
      e.vertices.push(new g().fromBufferAttribute(r, t)),
        void 0 !== a && e.colors.push(new zt().fromBufferAttribute(a, t));
    function h(t, n, i, r) {
      const h =
          void 0 === a
            ? []
            : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
        u =
          void 0 === o
            ? []
            : [
                new g().fromBufferAttribute(o, t),
                new g().fromBufferAttribute(o, n),
                new g().fromBufferAttribute(o, i),
              ],
        d = new Ft(t, n, i, u, h, r);
      e.faces.push(d),
        void 0 !== c &&
          e.faceVertexUvs[0].push([
            new s().fromBufferAttribute(c, t),
            new s().fromBufferAttribute(c, n),
            new s().fromBufferAttribute(c, i),
          ]),
        void 0 !== l &&
          e.faceVertexUvs[1].push([
            new s().fromBufferAttribute(l, t),
            new s().fromBufferAttribute(l, n),
            new s().fromBufferAttribute(l, i),
          ]);
    }
    const u = t.groups;
    if (u.length > 0)
      for (let t = 0; t < u.length; t++) {
        const e = u[t],
          i = e.start;
        for (let t = i, r = i + e.count; t < r; t += 3)
          void 0 !== n
            ? h(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex)
            : h(t, t + 1, t + 2, e.materialIndex);
      }
    else if (void 0 !== n)
      for (let t = 0; t < n.count; t += 3)
        h(n.getX(t), n.getX(t + 1), n.getX(t + 2));
    else for (let t = 0; t < r.count; t += 3) h(t, t + 1, t + 2);
    return (
      this.computeFaceNormals(),
      null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
      null !== t.boundingSphere &&
        (this.boundingSphere = t.boundingSphere.clone()),
      this
    );
  },
  center: function () {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ne).negate(),
      this.translate(Ne.x, Ne.y, Ne.z),
      this
    );
  },
  normalize: function () {
    this.computeBoundingSphere();
    const t = this.boundingSphere.center,
      e = this.boundingSphere.radius,
      n = 0 === e ? 1 : 1 / e,
      i = new j();
    return (
      i.set(
        n,
        0,
        0,
        -n * t.x,
        0,
        n,
        0,
        -n * t.y,
        0,
        0,
        n,
        -n * t.z,
        0,
        0,
        0,
        1
      ),
      this.applyMatrix4(i),
      this
    );
  },
  computeFaceNormals: function () {
    const t = new g(),
      e = new g();
    for (let n = 0, i = this.faces.length; n < i; n++) {
      const i = this.faces[n],
        r = this.vertices[i.a],
        o = this.vertices[i.b],
        s = this.vertices[i.c];
      t.subVectors(s, o),
        e.subVectors(r, o),
        t.cross(e),
        t.normalize(),
        i.normal.copy(t);
    }
  },
  computeVertexNormals: function (t) {
    void 0 === t && (t = !0);
    const e = new Array(this.vertices.length);
    for (let t = 0, n = this.vertices.length; t < n; t++) e[t] = new g();
    if (t) {
      const t = new g(),
        n = new g();
      for (let i = 0, r = this.faces.length; i < r; i++) {
        const r = this.faces[i],
          o = this.vertices[r.a],
          s = this.vertices[r.b],
          a = this.vertices[r.c];
        t.subVectors(a, s),
          n.subVectors(o, s),
          t.cross(n),
          e[r.a].add(t),
          e[r.b].add(t),
          e[r.c].add(t);
      }
    } else {
      this.computeFaceNormals();
      for (let t = 0, n = this.faces.length; t < n; t++) {
        const n = this.faces[t];
        e[n.a].add(n.normal), e[n.b].add(n.normal), e[n.c].add(n.normal);
      }
    }
    for (let t = 0, n = this.vertices.length; t < n; t++) e[t].normalize();
    for (let t = 0, n = this.faces.length; t < n; t++) {
      const n = this.faces[t],
        i = n.vertexNormals;
      3 === i.length
        ? (i[0].copy(e[n.a]), i[1].copy(e[n.b]), i[2].copy(e[n.c]))
        : ((i[0] = e[n.a].clone()),
          (i[1] = e[n.b].clone()),
          (i[2] = e[n.c].clone()));
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeFlatVertexNormals: function () {
    this.computeFaceNormals();
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t],
        n = e.vertexNormals;
      3 === n.length
        ? (n[0].copy(e.normal), n[1].copy(e.normal), n[2].copy(e.normal))
        : ((n[0] = e.normal.clone()),
          (n[1] = e.normal.clone()),
          (n[2] = e.normal.clone()));
    }
    this.faces.length > 0 && (this.normalsNeedUpdate = !0);
  },
  computeMorphNormals: function () {
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t];
      e.__originalFaceNormal
        ? e.__originalFaceNormal.copy(e.normal)
        : (e.__originalFaceNormal = e.normal.clone()),
        e.__originalVertexNormals || (e.__originalVertexNormals = []);
      for (let t = 0, n = e.vertexNormals.length; t < n; t++)
        e.__originalVertexNormals[t]
          ? e.__originalVertexNormals[t].copy(e.vertexNormals[t])
          : (e.__originalVertexNormals[t] = e.vertexNormals[t].clone());
    }
    const t = new Ie();
    t.faces = this.faces;
    for (let e = 0, n = this.morphTargets.length; e < n; e++) {
      if (!this.morphNormals[e]) {
        (this.morphNormals[e] = {}),
          (this.morphNormals[e].faceNormals = []),
          (this.morphNormals[e].vertexNormals = []);
        const t = this.morphNormals[e].faceNormals,
          n = this.morphNormals[e].vertexNormals;
        for (let e = 0, i = this.faces.length; e < i; e++) {
          const e = new g(),
            i = { a: new g(), b: new g(), c: new g() };
          t.push(e), n.push(i);
        }
      }
      const n = this.morphNormals[e];
      (t.vertices = this.morphTargets[e].vertices),
        t.computeFaceNormals(),
        t.computeVertexNormals();
      for (let t = 0, e = this.faces.length; t < e; t++) {
        const e = this.faces[t],
          i = n.faceNormals[t],
          r = n.vertexNormals[t];
        i.copy(e.normal),
          r.a.copy(e.vertexNormals[0]),
          r.b.copy(e.vertexNormals[1]),
          r.c.copy(e.vertexNormals[2]);
      }
    }
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t];
      (e.normal = e.__originalFaceNormal),
        (e.vertexNormals = e.__originalVertexNormals);
    }
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new x()),
      this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new D()),
      this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (t, e, n) {
    if (!t || !t.isGeometry)
      return void console.error(
        "THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
        t
      );
    let i;
    const r = this.vertices.length,
      o = this.vertices,
      s = t.vertices,
      c = this.faces,
      l = t.faces,
      h = this.colors,
      u = t.colors;
    void 0 === n && (n = 0), void 0 !== e && (i = new a().getNormalMatrix(e));
    for (let t = 0, n = s.length; t < n; t++) {
      const n = s[t].clone();
      void 0 !== e && n.applyMatrix4(e), o.push(n);
    }
    for (let t = 0, e = u.length; t < e; t++) h.push(u[t].clone());
    for (let t = 0, e = l.length; t < e; t++) {
      const e = l[t];
      let o, s;
      const a = e.vertexNormals,
        h = e.vertexColors,
        u = new Ft(e.a + r, e.b + r, e.c + r);
      u.normal.copy(e.normal),
        void 0 !== i && u.normal.applyMatrix3(i).normalize();
      for (let t = 0, e = a.length; t < e; t++)
        (o = a[t].clone()),
          void 0 !== i && o.applyMatrix3(i).normalize(),
          u.vertexNormals.push(o);
      u.color.copy(e.color);
      for (let t = 0, e = h.length; t < e; t++)
        (s = h[t]), u.vertexColors.push(s.clone());
      (u.materialIndex = e.materialIndex + n), c.push(u);
    }
    for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
      const n = t.faceVertexUvs[e];
      void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
      for (let t = 0, i = n.length; t < i; t++) {
        const i = n[t],
          r = [];
        for (let t = 0, e = i.length; t < e; t++) r.push(i[t].clone());
        this.faceVertexUvs[e].push(r);
      }
    }
  },
  mergeMesh: function (t) {
    t && t.isMesh
      ? (t.matrixAutoUpdate && t.updateMatrix(),
        this.merge(t.geometry, t.matrix))
      : console.error(
          "THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",
          t
        );
  },
  mergeVertices: function () {
    const t = {},
      e = [],
      n = [],
      i = Math.pow(10, 4);
    for (let r = 0, o = this.vertices.length; r < o; r++) {
      const o = this.vertices[r],
        s =
          Math.round(o.x * i) +
          "_" +
          Math.round(o.y * i) +
          "_" +
          Math.round(o.z * i);
      void 0 === t[s]
        ? ((t[s] = r), e.push(this.vertices[r]), (n[r] = e.length - 1))
        : (n[r] = n[t[s]]);
    }
    const r = [];
    for (let t = 0, e = this.faces.length; t < e; t++) {
      const e = this.faces[t];
      (e.a = n[e.a]), (e.b = n[e.b]), (e.c = n[e.c]);
      const i = [e.a, e.b, e.c];
      for (let e = 0; e < 3; e++)
        if (i[e] === i[(e + 1) % 3]) {
          r.push(t);
          break;
        }
    }
    for (let t = r.length - 1; t >= 0; t--) {
      const e = r[t];
      this.faces.splice(e, 1);
      for (let t = 0, n = this.faceVertexUvs.length; t < n; t++)
        this.faceVertexUvs[t].splice(e, 1);
    }
    const o = this.vertices.length - e.length;
    return (this.vertices = e), o;
  },
  setFromPoints: function (t) {
    this.vertices = [];
    for (let e = 0, n = t.length; e < n; e++) {
      const n = t[e];
      this.vertices.push(new g(n.x, n.y, n.z || 0));
    }
    return this;
  },
  sortFacesByMaterialIndex: function () {
    const t = this.faces,
      e = t.length;
    for (let n = 0; n < e; n++) t[n]._id = n;
    t.sort(function (t, e) {
      return t.materialIndex - e.materialIndex;
    });
    const n = this.faceVertexUvs[0],
      i = this.faceVertexUvs[1];
    let r, o;
    n && n.length === e && (r = []), i && i.length === e && (o = []);
    for (let s = 0; s < e; s++) {
      const e = t[s]._id;
      r && r.push(n[e]), o && o.push(i[e]);
    }
    r && (this.faceVertexUvs[0] = r), o && (this.faceVertexUvs[1] = o);
  },
  toJSON: function () {
    const t = {
      metadata: {
        version: 4.5,
        type: "Geometry",
        generator: "Geometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      "" !== this.name && (t.name = this.name),
      void 0 !== this.parameters)
    ) {
      const e = this.parameters;
      for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
      return t;
    }
    const e = [];
    for (let t = 0; t < this.vertices.length; t++) {
      const n = this.vertices[t];
      e.push(n.x, n.y, n.z);
    }
    const n = [],
      i = [],
      r = {},
      o = [],
      s = {},
      a = [],
      c = {};
    for (let t = 0; t < this.faces.length; t++) {
      const e = this.faces[t],
        i = !0,
        r = !1,
        o = void 0 !== this.faceVertexUvs[0][t],
        s = e.normal.length() > 0,
        a = e.vertexNormals.length > 0,
        c = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b,
        p = e.vertexColors.length > 0;
      let f = 0;
      if (
        ((f = l(f, 0, 0)),
        (f = l(f, 1, i)),
        (f = l(f, 2, r)),
        (f = l(f, 3, o)),
        (f = l(f, 4, s)),
        (f = l(f, 5, a)),
        (f = l(f, 6, c)),
        (f = l(f, 7, p)),
        n.push(f),
        n.push(e.a, e.b, e.c),
        n.push(e.materialIndex),
        o)
      ) {
        const e = this.faceVertexUvs[0][t];
        n.push(d(e[0]), d(e[1]), d(e[2]));
      }
      if ((s && n.push(h(e.normal)), a)) {
        const t = e.vertexNormals;
        n.push(h(t[0]), h(t[1]), h(t[2]));
      }
      if ((c && n.push(u(e.color)), p)) {
        const t = e.vertexColors;
        n.push(u(t[0]), u(t[1]), u(t[2]));
      }
    }
    function l(t, e, n) {
      return n ? t | (1 << e) : t & ~(1 << e);
    }
    function h(t) {
      const e = t.x.toString() + t.y.toString() + t.z.toString();
      return (
        void 0 !== r[e] || ((r[e] = i.length / 3), i.push(t.x, t.y, t.z)), r[e]
      );
    }
    function u(t) {
      const e = t.r.toString() + t.g.toString() + t.b.toString();
      return void 0 !== s[e] || ((s[e] = o.length), o.push(t.getHex())), s[e];
    }
    function d(t) {
      const e = t.x.toString() + t.y.toString();
      return void 0 !== c[e] || ((c[e] = a.length / 2), a.push(t.x, t.y)), c[e];
    }
    return (
      (t.data = {}),
      (t.data.vertices = e),
      (t.data.normals = i),
      o.length > 0 && (t.data.colors = o),
      a.length > 0 && (t.data.uvs = [a]),
      (t.data.faces = n),
      t
    );
  },
  clone: function () {
    return new Ie().copy(this);
  },
  copy: function (t) {
    (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.name = t.name);
    const e = t.vertices;
    for (let t = 0, n = e.length; t < n; t++) this.vertices.push(e[t].clone());
    const n = t.colors;
    for (let t = 0, e = n.length; t < e; t++) this.colors.push(n[t].clone());
    const i = t.faces;
    for (let t = 0, e = i.length; t < e; t++) this.faces.push(i[t].clone());
    for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
      const n = t.faceVertexUvs[e];
      void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
      for (let t = 0, i = n.length; t < i; t++) {
        const i = n[t],
          r = [];
        for (let t = 0, e = i.length; t < e; t++) {
          const e = i[t];
          r.push(e.clone());
        }
        this.faceVertexUvs[e].push(r);
      }
    }
    const r = t.morphTargets;
    for (let t = 0, e = r.length; t < e; t++) {
      const e = {};
      if (((e.name = r[t].name), void 0 !== r[t].vertices)) {
        e.vertices = [];
        for (let n = 0, i = r[t].vertices.length; n < i; n++)
          e.vertices.push(r[t].vertices[n].clone());
      }
      if (void 0 !== r[t].normals) {
        e.normals = [];
        for (let n = 0, i = r[t].normals.length; n < i; n++)
          e.normals.push(r[t].normals[n].clone());
      }
      this.morphTargets.push(e);
    }
    const o = t.morphNormals;
    for (let t = 0, e = o.length; t < e; t++) {
      const e = {};
      if (void 0 !== o[t].vertexNormals) {
        e.vertexNormals = [];
        for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
          const i = o[t].vertexNormals[n],
            r = {};
          (r.a = i.a.clone()),
            (r.b = i.b.clone()),
            (r.c = i.c.clone()),
            e.vertexNormals.push(r);
        }
      }
      if (void 0 !== o[t].faceNormals) {
        e.faceNormals = [];
        for (let n = 0, i = o[t].faceNormals.length; n < i; n++)
          e.faceNormals.push(o[t].faceNormals[n].clone());
      }
      this.morphNormals.push(e);
    }
    const s = t.skinWeights;
    for (let t = 0, e = s.length; t < e; t++)
      this.skinWeights.push(s[t].clone());
    const a = t.skinIndices;
    for (let t = 0, e = a.length; t < e; t++)
      this.skinIndices.push(a[t].clone());
    const c = t.lineDistances;
    for (let t = 0, e = c.length; t < e; t++) this.lineDistances.push(c[t]);
    const l = t.boundingBox;
    null !== l && (this.boundingBox = l.clone());
    const h = t.boundingSphere;
    return (
      null !== h && (this.boundingSphere = h.clone()),
      (this.elementsNeedUpdate = t.elementsNeedUpdate),
      (this.verticesNeedUpdate = t.verticesNeedUpdate),
      (this.uvsNeedUpdate = t.uvsNeedUpdate),
      (this.normalsNeedUpdate = t.normalsNeedUpdate),
      (this.colorsNeedUpdate = t.colorsNeedUpdate),
      (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
      (this.groupsNeedUpdate = t.groupsNeedUpdate),
      this
    );
  },
  dispose: function () {
    this.dispatchEvent({ type: "dispose" });
  },
});
class De extends Ie {
  constructor(t, e, n, i, r, o) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o,
      }),
      this.fromBufferGeometry(new Be(t, e, n, i, r, o)),
      this.mergeVertices();
  }
}
class Be extends le {
  constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) {
    super(),
      (this.type = "BoxBufferGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o,
      });
    const s = this;
    (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
    const a = [],
      c = [],
      l = [],
      h = [];
    let u = 0,
      d = 0;
    function p(t, e, n, i, r, o, p, f, m, v, y) {
      const x = o / m,
        b = p / v,
        _ = o / 2,
        w = p / 2,
        M = f / 2,
        S = m + 1,
        T = v + 1;
      let E = 0,
        A = 0;
      const L = new g();
      for (let o = 0; o < T; o++) {
        const s = o * b - w;
        for (let a = 0; a < S; a++) {
          const u = a * x - _;
          (L[t] = u * i),
            (L[e] = s * r),
            (L[n] = M),
            c.push(L.x, L.y, L.z),
            (L[t] = 0),
            (L[e] = 0),
            (L[n] = f > 0 ? 1 : -1),
            l.push(L.x, L.y, L.z),
            h.push(a / m),
            h.push(1 - o / v),
            (E += 1);
        }
      }
      for (let t = 0; t < v; t++)
        for (let e = 0; e < m; e++) {
          const n = u + e + S * t,
            i = u + e + S * (t + 1),
            r = u + (e + 1) + S * (t + 1),
            o = u + (e + 1) + S * t;
          a.push(n, i, o), a.push(i, r, o), (A += 6);
        }
      s.addGroup(d, A, y), (d += A), (u += E);
    }
    p("z", "y", "x", -1, -1, n, e, t, o, r, 0),
      p("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
      p("x", "z", "y", 1, 1, t, n, e, i, o, 2),
      p("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
      p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
      p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
      this.setIndex(a),
      this.setAttribute("position", new Qt(c, 3)),
      this.setAttribute("normal", new Qt(l, 3)),
      this.setAttribute("uv", new Qt(h, 2));
  }
}
function ze(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const i in t[n]) {
      const r = t[n][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture)
        ? (e[n][i] = r.clone())
        : Array.isArray(r)
        ? (e[n][i] = r.slice())
        : (e[n][i] = r);
    }
  }
  return e;
}
function Fe(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const i = ze(t[n]);
    for (const t in i) e[t] = i[t];
  }
  return e;
}
const Ue = { clone: ze, merge: Fe };
function Ge(t) {
  Gt.call(this),
    (this.type = "ShaderMaterial"),
    (this.defines = {}),
    (this.uniforms = {}),
    (this.vertexShader =
      "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
    (this.fragmentShader =
      "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
    (this.linewidth = 1),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.fog = !1),
    (this.lights = !1),
    (this.clipping = !1),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    (this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1,
    }),
    (this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0],
    }),
    (this.index0AttributeName = void 0),
    (this.uniformsNeedUpdate = !1),
    (this.glslVersion = null),
    void 0 !== t &&
      (void 0 !== t.attributes &&
        console.error(
          "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
        ),
      this.setValues(t));
}
function He() {
  mt.call(this),
    (this.type = "Camera"),
    (this.matrixWorldInverse = new j()),
    (this.projectionMatrix = new j()),
    (this.projectionMatrixInverse = new j());
}
function ke(t, e, n, i) {
  He.call(this),
    (this.type = "PerspectiveCamera"),
    (this.fov = void 0 !== t ? t : 50),
    (this.zoom = 1),
    (this.near = void 0 !== n ? n : 0.1),
    (this.far = void 0 !== i ? i : 2e3),
    (this.focus = 10),
    (this.aspect = void 0 !== e ? e : 1),
    (this.view = null),
    (this.filmGauge = 35),
    (this.filmOffset = 0),
    this.updateProjectionMatrix();
}
(Ge.prototype = Object.create(Gt.prototype)),
  (Ge.prototype.constructor = Ge),
  (Ge.prototype.isShaderMaterial = !0),
  (Ge.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = ze(t.uniforms)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    );
  }),
  (Ge.prototype.toJSON = function (t) {
    const e = Gt.prototype.toJSON.call(this, t);
    (e.glslVersion = this.glslVersion), (e.uniforms = {});
    for (const n in this.uniforms) {
      const i = this.uniforms[n].value;
      i && i.isTexture
        ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
        : i && i.isColor
        ? (e.uniforms[n] = { type: "c", value: i.getHex() })
        : i && i.isVector2
        ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
        : i && i.isVector3
        ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
        : i && i.isVector4
        ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
        : i && i.isMatrix3
        ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
        : i && i.isMatrix4
        ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
        : (e.uniforms[n] = { value: i });
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader);
    const n = {};
    for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
    return Object.keys(n).length > 0 && (e.extensions = n), e;
  }),
  (He.prototype = Object.assign(Object.create(mt.prototype), {
    constructor: He,
    isCamera: !0,
    copy: function (t, e) {
      return (
        mt.prototype.copy.call(this, t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        this
      );
    },
    getWorldDirection: function (t) {
      void 0 === t &&
        (console.warn(
          "THREE.Camera: .getWorldDirection() target is now required"
        ),
        (t = new g())),
        this.updateMatrixWorld(!0);
      const e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function (t) {
      mt.prototype.updateMatrixWorld.call(this, t),
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function (t, e) {
      mt.prototype.updateWorldMatrix.call(this, t, e),
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
  })),
  (ke.prototype = Object.assign(Object.create(He.prototype), {
    constructor: ke,
    isPerspectiveCamera: !0,
    copy: function (t, e) {
      return (
        He.prototype.copy.call(this, t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    },
    setFocalLength: function (t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      (this.fov = 2 * o.RAD2DEG * Math.atan(e)), this.updateProjectionMatrix();
    },
    getFocalLength: function () {
      const t = Math.tan(0.5 * o.DEG2RAD * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    },
    getEffectiveFOV: function () {
      return (
        2 *
        o.RAD2DEG *
        Math.atan(Math.tan(0.5 * o.DEG2RAD * this.fov) / this.zoom)
      );
    },
    getFilmWidth: function () {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function () {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function (t, e, n, i, r, o) {
      (this.aspect = t / e),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = o),
        this.updateProjectionMatrix();
    },
    clearViewOffset: function () {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function () {
      const t = this.near;
      let e = (t * Math.tan(0.5 * o.DEG2RAD * this.fov)) / this.zoom,
        n = 2 * e,
        i = this.aspect * n,
        r = -0.5 * i;
      const s = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = s.fullWidth,
          o = s.fullHeight;
        (r += (s.offsetX * i) / t),
          (e -= (s.offsetY * n) / o),
          (i *= s.width / t),
          (n *= s.height / o);
      }
      const a = this.filmOffset;
      0 !== a && (r += (t * a) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function (t) {
      const e = mt.prototype.toJSON.call(this, t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    },
  }));
function Ve(t, e, n) {
  if (
    (mt.call(this),
    (this.type = "CubeCamera"),
    !0 !== n.isWebGLCubeRenderTarget)
  )
    return void console.error(
      "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
    );
  this.renderTarget = n;
  const i = new ke(90, 1, t, e);
  (i.layers = this.layers),
    i.up.set(0, -1, 0),
    i.lookAt(new g(1, 0, 0)),
    this.add(i);
  const r = new ke(90, 1, t, e);
  (r.layers = this.layers),
    r.up.set(0, -1, 0),
    r.lookAt(new g(-1, 0, 0)),
    this.add(r);
  const o = new ke(90, 1, t, e);
  (o.layers = this.layers),
    o.up.set(0, 0, 1),
    o.lookAt(new g(0, 1, 0)),
    this.add(o);
  const s = new ke(90, 1, t, e);
  (s.layers = this.layers),
    s.up.set(0, 0, -1),
    s.lookAt(new g(0, -1, 0)),
    this.add(s);
  const a = new ke(90, 1, t, e);
  (a.layers = this.layers),
    a.up.set(0, -1, 0),
    a.lookAt(new g(0, 0, 1)),
    this.add(a);
  const c = new ke(90, 1, t, e);
  (c.layers = this.layers),
    c.up.set(0, -1, 0),
    c.lookAt(new g(0, 0, -1)),
    this.add(c),
    (this.update = function (t, e) {
      null === this.parent && this.updateMatrixWorld();
      const l = t.xr.enabled,
        h = t.getRenderTarget();
      t.xr.enabled = !1;
      const u = n.texture.generateMipmaps;
      (n.texture.generateMipmaps = !1),
        t.setRenderTarget(n, 0),
        t.render(e, i),
        t.setRenderTarget(n, 1),
        t.render(e, r),
        t.setRenderTarget(n, 2),
        t.render(e, o),
        t.setRenderTarget(n, 3),
        t.render(e, s),
        t.setRenderTarget(n, 4),
        t.render(e, a),
        (n.texture.generateMipmaps = u),
        t.setRenderTarget(n, 5),
        t.render(e, c),
        t.setRenderTarget(h),
        (t.xr.enabled = l);
    }),
    (this.clear = function (t, e, i, r) {
      const o = t.getRenderTarget();
      for (let o = 0; o < 6; o++) t.setRenderTarget(n, o), t.clear(e, i, r);
      t.setRenderTarget(o);
    });
}
function je(t, e, n) {
  Number.isInteger(e) &&
    (console.warn(
      "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
    ),
    (e = n)),
    p.call(this, t, t, e),
    (this.texture.isWebGLCubeRenderTargetTexture = !0);
}
function We(t, e, n, i, r, o, s, a, c, l, h, d) {
  u.call(this, null, o, s, a, c, l, i, r, h, d),
    (this.image = { data: t || null, width: e || 1, height: n || 1 }),
    (this.magFilter = void 0 !== c ? c : 1003),
    (this.minFilter = void 0 !== l ? l : 1003),
    (this.generateMipmaps = !1),
    (this.flipY = !1),
    (this.unpackAlignment = 1),
    (this.needsUpdate = !0);
}
(Ve.prototype = Object.create(mt.prototype)),
  (Ve.prototype.constructor = Ve),
  (je.prototype = Object.create(p.prototype)),
  (je.prototype.constructor = je),
  (je.prototype.isWebGLCubeRenderTarget = !0),
  (je.prototype.fromEquirectangularTexture = function (t, e) {
    (this.texture.type = e.type),
      (this.texture.format = 1023),
      (this.texture.encoding = e.encoding),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader:
          "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
        fragmentShader:
          "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",
      },
      i = new Be(5, 5, 5),
      r = new Ge({
        name: "CubemapFromEquirect",
        uniforms: ze(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: 1,
        blending: 0,
      });
    r.uniforms.tEquirect.value = e;
    const o = new Ae(i, r),
      s = e.minFilter;
    1008 === e.minFilter && (e.minFilter = 1006);
    return (
      new Ve(1, 10, this).update(t, o),
      (e.minFilter = s),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }),
  (We.prototype = Object.create(u.prototype)),
  (We.prototype.constructor = We),
  (We.prototype.isDataTexture = !0);
const qe = new D(),
  Xe = new g();
class Ye {
  constructor(t, e, n, i, r, o) {
    this.planes = [
      void 0 !== t ? t : new xt(),
      void 0 !== e ? e : new xt(),
      void 0 !== n ? n : new xt(),
      void 0 !== i ? i : new xt(),
      void 0 !== r ? r : new xt(),
      void 0 !== o ? o : new xt(),
    ];
  }
  set(t, e, n, i, r, o) {
    const s = this.planes;
    return (
      s[0].copy(t),
      s[1].copy(e),
      s[2].copy(n),
      s[3].copy(i),
      s[4].copy(r),
      s[5].copy(o),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
    return this;
  }
  setFromProjectionMatrix(t) {
    const e = this.planes,
      n = t.elements,
      i = n[0],
      r = n[1],
      o = n[2],
      s = n[3],
      a = n[4],
      c = n[5],
      l = n[6],
      h = n[7],
      u = n[8],
      d = n[9],
      p = n[10],
      f = n[11],
      m = n[12],
      g = n[13],
      v = n[14],
      y = n[15];
    return (
      e[0].setComponents(s - i, h - a, f - u, y - m).normalize(),
      e[1].setComponents(s + i, h + a, f + u, y + m).normalize(),
      e[2].setComponents(s + r, h + c, f + d, y + g).normalize(),
      e[3].setComponents(s - r, h - c, f - d, y - g).normalize(),
      e[4].setComponents(s - o, h - l, f - p, y - v).normalize(),
      e[5].setComponents(s + o, h + l, f + p, y + v).normalize(),
      this
    );
  }
  intersectsObject(t) {
    const e = t.geometry;
    return (
      null === e.boundingSphere && e.computeBoundingSphere(),
      qe.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
      this.intersectsSphere(qe)
    );
  }
  intersectsSprite(t) {
    return (
      qe.center.set(0, 0, 0),
      (qe.radius = 0.7071067811865476),
      qe.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(qe)
    );
  }
  intersectsSphere(t) {
    const e = this.planes,
      n = t.center,
      i = -t.radius;
    for (let t = 0; t < 6; t++) {
      if (e[t].distanceToPoint(n) < i) return !1;
    }
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = e[n];
      if (
        ((Xe.x = i.normal.x > 0 ? t.max.x : t.min.x),
        (Xe.y = i.normal.y > 0 ? t.max.y : t.min.y),
        (Xe.z = i.normal.z > 0 ? t.max.z : t.min.z),
        i.distanceToPoint(Xe) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
    return !0;
  }
}
function Ze() {
  let t = null,
    e = !1,
    n = null,
    i = null;
  function r(e, o) {
    n(e, o), (i = t.requestAnimationFrame(r));
  }
  return {
    start: function () {
      !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (t) {
      n = t;
    },
    setContext: function (e) {
      t = e;
    },
  };
}
function Je(t, e) {
  const n = e.isWebGL2,
    i = new WeakMap();
  return {
    get: function (t) {
      return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
    },
    remove: function (e) {
      e.isInterleavedBufferAttribute && (e = e.data);
      const n = i.get(e);
      n && (t.deleteBuffer(n.buffer), i.delete(e));
    },
    update: function (e, r) {
      if (e.isGLBufferAttribute) {
        var o = i.get(e);
        return void (
          (!o || o.version < e.version) &&
          i.set(e, {
            buffer: e.buffer,
            type: e.type,
            bytesPerElement: e.elementSize,
            version: e.version,
          })
        );
      }
      e.isInterleavedBufferAttribute && (e = e.data);
      const s = i.get(e);
      void 0 === s
        ? i.set(
            e,
            (function (e, n) {
              const i = e.array,
                r = e.usage,
                o = t.createBuffer();
              t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
              let s = 5126;
              return (
                i instanceof Float32Array
                  ? (s = 5126)
                  : i instanceof Float64Array
                  ? console.warn(
                      "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                    )
                  : i instanceof Uint16Array
                  ? (s = 5123)
                  : i instanceof Int16Array
                  ? (s = 5122)
                  : i instanceof Uint32Array
                  ? (s = 5125)
                  : i instanceof Int32Array
                  ? (s = 5124)
                  : i instanceof Int8Array
                  ? (s = 5120)
                  : i instanceof Uint8Array && (s = 5121),
                {
                  buffer: o,
                  type: s,
                  bytesPerElement: i.BYTES_PER_ELEMENT,
                  version: e.version,
                }
              );
            })(e, r)
          )
        : s.version < e.version &&
          (!(function (e, i, r) {
            const o = i.array,
              s = i.updateRange;
            t.bindBuffer(r, e),
              -1 === s.count
                ? t.bufferSubData(r, 0, o)
                : (n
                    ? t.bufferSubData(
                        r,
                        s.offset * o.BYTES_PER_ELEMENT,
                        o,
                        s.offset,
                        s.count
                      )
                    : t.bufferSubData(
                        r,
                        s.offset * o.BYTES_PER_ELEMENT,
                        o.subarray(s.offset, s.offset + s.count)
                      ),
                  (s.count = -1));
          })(s.buffer, e, r),
          (s.version = e.version));
    },
  };
}
class Ke extends Ie {
  constructor(t, e, n, i) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i,
      }),
      this.fromBufferGeometry(new Qe(t, e, n, i)),
      this.mergeVertices();
  }
}
class Qe extends le {
  constructor(t, e, n, i) {
    super(),
      (this.type = "PlaneBufferGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i,
      });
    const r = (t = t || 1) / 2,
      o = (e = e || 1) / 2,
      s = Math.floor(n) || 1,
      a = Math.floor(i) || 1,
      c = s + 1,
      l = a + 1,
      h = t / s,
      u = e / a,
      d = [],
      p = [],
      f = [],
      m = [];
    for (let t = 0; t < l; t++) {
      const e = t * u - o;
      for (let n = 0; n < c; n++) {
        const i = n * h - r;
        p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a);
      }
    }
    for (let t = 0; t < a; t++)
      for (let e = 0; e < s; e++) {
        const n = e + c * t,
          i = e + c * (t + 1),
          r = e + 1 + c * (t + 1),
          o = e + 1 + c * t;
        d.push(n, i, o), d.push(i, r, o);
      }
    this.setIndex(d),
      this.setAttribute("position", new Qt(p, 3)),
      this.setAttribute("normal", new Qt(f, 3)),
      this.setAttribute("uv", new Qt(m, 2));
  }
}
const $e = {
    alphamap_fragment:
      "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment:
      "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment:
      "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
    aomap_fragment:
      "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
    aomap_pars_fragment:
      "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );",
    beginnormal_vertex:
      "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs:
      "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
    bumpmap_pars_fragment:
      "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment:
      "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    clipping_planes_pars_fragment:
      "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex:
      "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex:
      "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
    color_pars_vertex:
      "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_vertex:
      "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    common:
      "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
    cube_uv_reflection_fragment:
      "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    defaultnormal_vertex:
      "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    displacementmap_pars_vertex:
      "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    displacementmap_vertex:
      "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment:
      "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment:
      "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    encodings_pars_fragment:
      "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
    envmap_fragment:
      "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_common_pars_fragment:
      "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    envmap_pars_fragment:
      "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex:
      "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    envmap_physical_pars_fragment:
      "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
    envmap_vertex:
      "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
    fog_fragment:
      "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment:
      "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment:
      "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
    lightmap_fragment:
      "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
    lightmap_pars_fragment:
      "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex:
      "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
    lights_pars_begin:
      "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
    lights_toon_fragment:
      "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment:
      "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
    lights_phong_fragment:
      "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment:
      "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
    lights_physical_fragment:
      "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
    lights_physical_pars_fragment:
      "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin:
      "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps:
      "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
    lights_fragment_end:
      "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment:
      "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment:
      "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex:
      "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    logdepthbuf_vertex:
      "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
    map_fragment:
      "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    map_particle_fragment:
      "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment:
      "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment:
      "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment:
      "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphnormal_vertex:
      "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
    morphtarget_pars_vertex:
      "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
    morphtarget_vertex:
      "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
    normal_fragment_begin:
      "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps:
      "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
    normalmap_pars_fragment:
      "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
    clearcoat_normal_fragment_begin:
      "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps:
      "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
    clearcoat_pars_fragment:
      "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
    packing:
      "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment:
      "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex:
      "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment:
      "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment:
      "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment:
      "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment:
      "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment:
      "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex:
      "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    shadowmap_vertex:
      "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
    shadowmask_pars_fragment:
      "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex:
      "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex:
      "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
    skinning_vertex:
      "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex:
      "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment:
      "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment:
      "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment:
      "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment:
      "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmissionmap_fragment:
      "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
    transmissionmap_pars_fragment:
      "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
    uv_pars_fragment:
      "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
    uv_pars_vertex:
      "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
    uv_vertex:
      "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment:
      "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
    uv2_pars_vertex:
      "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
    uv2_vertex:
      "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
    worldpos_vertex:
      "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
    background_frag:
      "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    background_vert:
      "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    cube_frag:
      "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    cube_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    depth_frag:
      "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    depth_vert:
      "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    distanceRGBA_frag:
      "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    distanceRGBA_vert:
      "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    equirect_frag:
      "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    equirect_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    linedashed_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    linedashed_vert:
      "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshbasic_vert:
      "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag:
      "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert:
      "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshmatcap_frag:
      "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshmatcap_vert:
      "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshtoon_frag:
      "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshtoon_vert:
      "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphong_frag:
      "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphong_vert:
      "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphysical_frag:
      "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert:
      "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    normal_frag:
      "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
    normal_vert:
      "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    points_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    points_vert:
      "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag:
      "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    shadow_vert:
      "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert:
      "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
  },
  tn = {
    common: {
      diffuse: { value: new zt(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new a() },
      uv2Transform: { value: new a() },
      alphaMap: { value: null },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new s(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new zt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new zt(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      uvTransform: { value: new a() },
    },
    sprite: {
      diffuse: { value: new zt(15658734) },
      opacity: { value: 1 },
      center: { value: new s(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      uvTransform: { value: new a() },
    },
  },
  en = {
    basic: {
      uniforms: Fe([
        tn.common,
        tn.specularmap,
        tn.envmap,
        tn.aomap,
        tn.lightmap,
        tn.fog,
      ]),
      vertexShader: $e.meshbasic_vert,
      fragmentShader: $e.meshbasic_frag,
    },
    lambert: {
      uniforms: Fe([
        tn.common,
        tn.specularmap,
        tn.envmap,
        tn.aomap,
        tn.lightmap,
        tn.emissivemap,
        tn.fog,
        tn.lights,
        { emissive: { value: new zt(0) } },
      ]),
      vertexShader: $e.meshlambert_vert,
      fragmentShader: $e.meshlambert_frag,
    },
    phong: {
      uniforms: Fe([
        tn.common,
        tn.specularmap,
        tn.envmap,
        tn.aomap,
        tn.lightmap,
        tn.emissivemap,
        tn.bumpmap,
        tn.normalmap,
        tn.displacementmap,
        tn.fog,
        tn.lights,
        {
          emissive: { value: new zt(0) },
          specular: { value: new zt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: $e.meshphong_vert,
      fragmentShader: $e.meshphong_frag,
    },
    standard: {
      uniforms: Fe([
        tn.common,
        tn.envmap,
        tn.aomap,
        tn.lightmap,
        tn.emissivemap,
        tn.bumpmap,
        tn.normalmap,
        tn.displacementmap,
        tn.roughnessmap,
        tn.metalnessmap,
        tn.fog,
        tn.lights,
        {
          emissive: { value: new zt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: $e.meshphysical_vert,
      fragmentShader: $e.meshphysical_frag,
    },
    toon: {
      uniforms: Fe([
        tn.common,
        tn.aomap,
        tn.lightmap,
        tn.emissivemap,
        tn.bumpmap,
        tn.normalmap,
        tn.displacementmap,
        tn.gradientmap,
        tn.fog,
        tn.lights,
        { emissive: { value: new zt(0) } },
      ]),
      vertexShader: $e.meshtoon_vert,
      fragmentShader: $e.meshtoon_frag,
    },
    matcap: {
      uniforms: Fe([
        tn.common,
        tn.bumpmap,
        tn.normalmap,
        tn.displacementmap,
        tn.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: $e.meshmatcap_vert,
      fragmentShader: $e.meshmatcap_frag,
    },
    points: {
      uniforms: Fe([tn.points, tn.fog]),
      vertexShader: $e.points_vert,
      fragmentShader: $e.points_frag,
    },
    dashed: {
      uniforms: Fe([
        tn.common,
        tn.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: $e.linedashed_vert,
      fragmentShader: $e.linedashed_frag,
    },
    depth: {
      uniforms: Fe([tn.common, tn.displacementmap]),
      vertexShader: $e.depth_vert,
      fragmentShader: $e.depth_frag,
    },
    normal: {
      uniforms: Fe([
        tn.common,
        tn.bumpmap,
        tn.normalmap,
        tn.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: $e.normal_vert,
      fragmentShader: $e.normal_frag,
    },
    sprite: {
      uniforms: Fe([tn.sprite, tn.fog]),
      vertexShader: $e.sprite_vert,
      fragmentShader: $e.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new a() }, t2D: { value: null } },
      vertexShader: $e.background_vert,
      fragmentShader: $e.background_frag,
    },
    cube: {
      uniforms: Fe([tn.envmap, { opacity: { value: 1 } }]),
      vertexShader: $e.cube_vert,
      fragmentShader: $e.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: $e.equirect_vert,
      fragmentShader: $e.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Fe([
        tn.common,
        tn.displacementmap,
        {
          referencePosition: { value: new g() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: $e.distanceRGBA_vert,
      fragmentShader: $e.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Fe([
        tn.lights,
        tn.fog,
        { color: { value: new zt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: $e.shadow_vert,
      fragmentShader: $e.shadow_frag,
    },
  };
function nn(t, e, n, i, r) {
  const o = new zt(0);
  let s,
    a,
    c = 0,
    l = null,
    h = 0,
    u = null;
  function d(t, e) {
    n.buffers.color.setClear(t.r, t.g, t.b, e, r);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (t, e) {
      o.set(t), (c = void 0 !== e ? e : 1), d(o, c);
    },
    getClearAlpha: function () {
      return c;
    },
    setClearAlpha: function (t) {
      (c = t), d(o, c);
    },
    render: function (n, r, p, f) {
      let m = !0 === r.isScene ? r.background : null;
      m && m.isTexture && (m = e.get(m));
      const g = t.xr,
        v = g.getSession && g.getSession();
      v && "additive" === v.environmentBlendMode && (m = null),
        null === m ? d(o, c) : m && m.isColor && (d(m, 1), (f = !0)),
        (t.autoClear || f) &&
          t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        m &&
        (m.isCubeTexture ||
          m.isWebGLCubeRenderTarget ||
          m.isWebGLCubeRenderTargetTexture ||
          306 === m.mapping)
          ? (void 0 === a &&
              ((a = new Ae(
                new Be(1, 1, 1),
                new Ge({
                  name: "BackgroundCubeMaterial",
                  uniforms: ze(en.cube.uniforms),
                  vertexShader: en.cube.vertexShader,
                  fragmentShader: en.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              a.geometry.deleteAttribute("normal"),
              a.geometry.deleteAttribute("uv"),
              (a.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(a.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              i.update(a)),
            m.isWebGLCubeRenderTarget && (m = m.texture),
            (a.material.uniforms.envMap.value = m),
            (a.material.uniforms.flipEnvMap.value = m.isCubeTexture ? -1 : 1),
            (l === m && h === m.version && u === t.toneMapping) ||
              ((a.material.needsUpdate = !0),
              (l = m),
              (h = m.version),
              (u = t.toneMapping)),
            n.unshift(a, a.geometry, a.material, 0, 0, null))
          : m &&
            m.isTexture &&
            (void 0 === s &&
              ((s = new Ae(
                new Qe(2, 2),
                new Ge({
                  name: "BackgroundMaterial",
                  uniforms: ze(en.background.uniforms),
                  vertexShader: en.background.vertexShader,
                  fragmentShader: en.background.fragmentShader,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              s.geometry.deleteAttribute("normal"),
              Object.defineProperty(s.material, "map", {
                get: function () {
                  return this.uniforms.t2D.value;
                },
              }),
              i.update(s)),
            (s.material.uniforms.t2D.value = m),
            !0 === m.matrixAutoUpdate && m.updateMatrix(),
            s.material.uniforms.uvTransform.value.copy(m.matrix),
            (l === m && h === m.version && u === t.toneMapping) ||
              ((s.material.needsUpdate = !0),
              (l = m),
              (h = m.version),
              (u = t.toneMapping)),
            n.unshift(s, s.geometry, s.material, 0, 0, null));
    },
  };
}
function rn(t, e, n, i) {
  const r = t.getParameter(34921),
    o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    s = i.isWebGL2 || null !== o,
    a = {},
    c = d(null);
  let l = c;
  function h(e) {
    return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e);
  }
  function u(e) {
    return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e);
  }
  function d(t) {
    const e = [],
      n = [],
      i = [];
    for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: e,
      enabledAttributes: n,
      attributeDivisors: i,
      object: t,
      attributes: {},
      index: null,
    };
  }
  function p() {
    const t = l.newAttributes;
    for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
  }
  function f(t) {
    m(t, 0);
  }
  function m(n, r) {
    const o = l.newAttributes,
      s = l.enabledAttributes,
      a = l.attributeDivisors;
    if (
      ((o[n] = 1),
      0 === s[n] && (t.enableVertexAttribArray(n), (s[n] = 1)),
      a[n] !== r)
    ) {
      (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
        i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
      ](n, r),
        (a[n] = r);
    }
  }
  function g() {
    const e = l.newAttributes,
      n = l.enabledAttributes;
    for (let i = 0, r = n.length; i < r; i++)
      n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
  }
  function v(e, n, r, o, s, a) {
    !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
      ? t.vertexAttribPointer(e, n, r, o, s, a)
      : t.vertexAttribIPointer(e, n, r, s, a);
  }
  function y() {
    x(), l !== c && ((l = c), h(l.object));
  }
  function x() {
    (c.geometry = null), (c.program = null), (c.wireframe = !1);
  }
  return {
    setup: function (r, c, u, y, x) {
      let b = !1;
      if (s) {
        const e = (function (e, n, r) {
          const s = !0 === r.wireframe;
          let c = a[e.id];
          void 0 === c && ((c = {}), (a[e.id] = c));
          let l = c[n.id];
          void 0 === l && ((l = {}), (c[n.id] = l));
          let h = l[s];
          void 0 === h &&
            ((h = d(
              i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()
            )),
            (l[s] = h));
          return h;
        })(y, u, c);
        l !== e && ((l = e), h(l.object)),
          (b = (function (t, e) {
            const n = l.attributes,
              i = t.attributes;
            if (Object.keys(n).length !== Object.keys(i).length) return !0;
            for (const t in i) {
              const e = n[t],
                r = i[t];
              if (void 0 === e) return !0;
              if (e.attribute !== r) return !0;
              if (e.data !== r.data) return !0;
            }
            return l.index !== e;
          })(y, x)),
          b &&
            (function (t, e) {
              const n = {},
                i = t.attributes;
              for (const t in i) {
                const e = i[t],
                  r = {};
                (r.attribute = e), e.data && (r.data = e.data), (n[t] = r);
              }
              (l.attributes = n), (l.index = e);
            })(y, x);
      } else {
        const t = !0 === c.wireframe;
        (l.geometry === y.id && l.program === u.id && l.wireframe === t) ||
          ((l.geometry = y.id),
          (l.program = u.id),
          (l.wireframe = t),
          (b = !0));
      }
      !0 === r.isInstancedMesh && (b = !0),
        null !== x && n.update(x, 34963),
        b &&
          (!(function (r, o, s, a) {
            if (
              !1 === i.isWebGL2 &&
              (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
              null === e.get("ANGLE_instanced_arrays")
            )
              return;
            p();
            const c = a.attributes,
              l = s.getAttributes(),
              h = o.defaultAttributeValues;
            for (const e in l) {
              const i = l[e];
              if (i >= 0) {
                const o = c[e];
                if (void 0 !== o) {
                  const e = o.normalized,
                    r = o.itemSize,
                    s = n.get(o);
                  if (void 0 === s) continue;
                  const c = s.buffer,
                    l = s.type,
                    h = s.bytesPerElement;
                  if (o.isInterleavedBufferAttribute) {
                    const n = o.data,
                      s = n.stride,
                      u = o.offset;
                    n && n.isInstancedInterleavedBuffer
                      ? (m(i, n.meshPerAttribute),
                        void 0 === a._maxInstanceCount &&
                          (a._maxInstanceCount = n.meshPerAttribute * n.count))
                      : f(i),
                      t.bindBuffer(34962, c),
                      v(i, r, l, e, s * h, u * h);
                  } else
                    o.isInstancedBufferAttribute
                      ? (m(i, o.meshPerAttribute),
                        void 0 === a._maxInstanceCount &&
                          (a._maxInstanceCount = o.meshPerAttribute * o.count))
                      : f(i),
                      t.bindBuffer(34962, c),
                      v(i, r, l, e, 0, 0);
                } else if ("instanceMatrix" === e) {
                  const e = n.get(r.instanceMatrix);
                  if (void 0 === e) continue;
                  const o = e.buffer,
                    s = e.type;
                  m(i + 0, 1),
                    m(i + 1, 1),
                    m(i + 2, 1),
                    m(i + 3, 1),
                    t.bindBuffer(34962, o),
                    t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
                    t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
                    t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
                    t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48);
                } else if ("instanceColor" === e) {
                  const e = n.get(r.instanceColor);
                  if (void 0 === e) continue;
                  const o = e.buffer,
                    s = e.type;
                  m(i, 1),
                    t.bindBuffer(34962, o),
                    t.vertexAttribPointer(i, 3, s, !1, 12, 0);
                } else if (void 0 !== h) {
                  const n = h[e];
                  if (void 0 !== n)
                    switch (n.length) {
                      case 2:
                        t.vertexAttrib2fv(i, n);
                        break;
                      case 3:
                        t.vertexAttrib3fv(i, n);
                        break;
                      case 4:
                        t.vertexAttrib4fv(i, n);
                        break;
                      default:
                        t.vertexAttrib1fv(i, n);
                    }
                }
              }
            }
            g();
          })(r, c, u, y),
          null !== x && t.bindBuffer(34963, n.get(x).buffer));
    },
    reset: y,
    resetDefaultState: x,
    dispose: function () {
      y();
      for (const t in a) {
        const e = a[t];
        for (const t in e) {
          const n = e[t];
          for (const t in n) u(n[t].object), delete n[t];
          delete e[t];
        }
        delete a[t];
      }
    },
    releaseStatesOfGeometry: function (t) {
      if (void 0 === a[t.id]) return;
      const e = a[t.id];
      for (const t in e) {
        const n = e[t];
        for (const t in n) u(n[t].object), delete n[t];
        delete e[t];
      }
      delete a[t.id];
    },
    releaseStatesOfProgram: function (t) {
      for (const e in a) {
        const n = a[e];
        if (void 0 === n[t.id]) continue;
        const i = n[t.id];
        for (const t in i) u(i[t].object), delete i[t];
        delete n[t.id];
      }
    },
    initAttributes: p,
    enableAttribute: f,
    disableUnusedAttributes: g,
  };
}
function on(t, e, n, i) {
  const r = i.isWebGL2;
  let o;
  (this.setMode = function (t) {
    o = t;
  }),
    (this.render = function (e, i) {
      t.drawArrays(o, e, i), n.update(i, o, 1);
    }),
    (this.renderInstances = function (i, s, a) {
      if (0 === a) return;
      let c, l;
      if (r) (c = t), (l = "drawArraysInstanced");
      else if (
        ((c = e.get("ANGLE_instanced_arrays")),
        (l = "drawArraysInstancedANGLE"),
        null === c)
      )
        return void console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
      c[l](o, i, s, a), n.update(s, o, a);
    });
}
function sn(t, e, n) {
  let i;
  function r(e) {
    if ("highp" === e) {
      if (
        t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        t.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      e = "mediump";
    }
    return "mediump" === e &&
      t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      t.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const o =
    ("undefined" != typeof WebGL2RenderingContext &&
      t instanceof WebGL2RenderingContext) ||
    ("undefined" != typeof WebGL2ComputeRenderingContext &&
      t instanceof WebGL2ComputeRenderingContext);
  let s = void 0 !== n.precision ? n.precision : "highp";
  const a = r(s);
  a !== s &&
    (console.warn(
      "THREE.WebGLRenderer:",
      s,
      "not supported, using",
      a,
      "instead."
    ),
    (s = a));
  const c = !0 === n.logarithmicDepthBuffer,
    l = t.getParameter(34930),
    h = t.getParameter(35660),
    u = t.getParameter(3379),
    d = t.getParameter(34076),
    p = t.getParameter(34921),
    f = t.getParameter(36347),
    m = t.getParameter(36348),
    g = t.getParameter(36349),
    v = h > 0,
    y = o || !!e.get("OES_texture_float");
  return {
    isWebGL2: o,
    getMaxAnisotropy: function () {
      if (void 0 !== i) return i;
      const n = e.get("EXT_texture_filter_anisotropic");
      return (
        (i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0),
        i
      );
    },
    getMaxPrecision: r,
    precision: s,
    logarithmicDepthBuffer: c,
    maxTextures: l,
    maxVertexTextures: h,
    maxTextureSize: u,
    maxCubemapSize: d,
    maxAttributes: p,
    maxVertexUniforms: f,
    maxVaryings: m,
    maxFragmentUniforms: g,
    vertexTextures: v,
    floatFragmentTextures: y,
    floatVertexTextures: v && y,
    maxSamples: o ? t.getParameter(36183) : 0,
  };
}
function an(t) {
  const e = this;
  let n = null,
    i = 0,
    r = !1,
    o = !1;
  const s = new xt(),
    c = new a(),
    l = { value: null, needsUpdate: !1 };
  function h() {
    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function u(t, n, i, r) {
    const o = null !== t ? t.length : 0;
    let a = null;
    if (0 !== o) {
      if (((a = l.value), !0 !== r || null === a)) {
        const e = i + 4 * o,
          r = n.matrixWorldInverse;
        c.getNormalMatrix(r),
          (null === a || a.length < e) && (a = new Float32Array(e));
        for (let e = 0, n = i; e !== o; ++e, n += 4)
          s.copy(t[e]).applyMatrix4(r, c),
            s.normal.toArray(a, n),
            (a[n + 3] = s.constant);
      }
      (l.value = a), (l.needsUpdate = !0);
    }
    return (e.numPlanes = o), (e.numIntersection = 0), a;
  }
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (t, e, o) {
      const s = 0 !== t.length || e || 0 !== i || r;
      return (r = e), (n = u(t, o, 0)), (i = t.length), s;
    }),
    (this.beginShadows = function () {
      (o = !0), u(null);
    }),
    (this.endShadows = function () {
      (o = !1), h();
    }),
    (this.setState = function (e, s, a) {
      const c = e.clippingPlanes,
        d = e.clipIntersection,
        p = e.clipShadows,
        f = t.get(e);
      if (!r || null === c || 0 === c.length || (o && !p)) o ? u(null) : h();
      else {
        const t = o ? 0 : i,
          e = 4 * t;
        let r = f.clippingState || null;
        (l.value = r), (r = u(c, s, e, a));
        for (let t = 0; t !== e; ++t) r[t] = n[t];
        (f.clippingState = r),
          (this.numIntersection = d ? this.numPlanes : 0),
          (this.numPlanes += t);
      }
    });
}
function cn(t) {
  let e = new WeakMap();
  function n(t, e) {
    return 303 === e ? (t.mapping = 301) : 304 === e && (t.mapping = 302), t;
  }
  return {
    get: function (i) {
      if (i && i.isTexture) {
        const r = i.mapping;
        if (303 === r || 304 === r) {
          if (e.has(i)) {
            return n(e.get(i).texture, i.mapping);
          }
          {
            const r = i.image;
            if (r && r.height > 0) {
              const o = t.getRenderList(),
                s = t.getRenderTarget(),
                a = t.getRenderState(),
                c = new je(r.height / 2);
              return (
                c.fromEquirectangularTexture(t, i),
                e.set(i, c),
                t.setRenderTarget(s),
                t.setRenderList(o),
                t.setRenderState(a),
                n(c.texture, i.mapping)
              );
            }
            return null;
          }
        }
      }
      return i;
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function ln(t) {
  const e = {};
  return {
    has: function (n) {
      if (void 0 !== e[n]) return null !== e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i =
            t.getExtension("WEBGL_depth_texture") ||
            t.getExtension("MOZ_WEBGL_depth_texture") ||
            t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i =
            t.getExtension("EXT_texture_filter_anisotropic") ||
            t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i =
            t.getExtension("WEBGL_compressed_texture_s3tc") ||
            t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i =
            t.getExtension("WEBGL_compressed_texture_pvrtc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = t.getExtension(n);
      }
      return (e[n] = i), null !== i;
    },
    get: function (t) {
      return (
        this.has(t) ||
          console.warn(
            "THREE.WebGLRenderer: " + t + " extension not supported."
          ),
        e[t]
      );
    },
  };
}
function hn(t, e, n, i) {
  const r = new WeakMap(),
    o = new WeakMap();
  function s(t) {
    const a = t.target,
      c = r.get(a);
    null !== c.index && e.remove(c.index);
    for (const t in c.attributes) e.remove(c.attributes[t]);
    a.removeEventListener("dispose", s), r.delete(a);
    const l = o.get(c);
    l && (e.remove(l), o.delete(c)),
      i.releaseStatesOfGeometry(a),
      !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
      n.memory.geometries--;
  }
  function a(t) {
    const n = [],
      i = t.index,
      r = t.attributes.position;
    let s = 0;
    if (null !== i) {
      const t = i.array;
      s = i.version;
      for (let e = 0, i = t.length; e < i; e += 3) {
        const i = t[e + 0],
          r = t[e + 1],
          o = t[e + 2];
        n.push(i, r, r, o, o, i);
      }
    } else {
      const t = r.array;
      s = r.version;
      for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
        const t = e + 0,
          i = e + 1,
          r = e + 2;
        n.push(t, i, i, r, r, t);
      }
    }
    const a = new (ee(n) > 65535 ? Kt : Zt)(n, 1);
    a.version = s;
    const c = o.get(t);
    c && e.remove(c), o.set(t, a);
  }
  return {
    get: function (t, e) {
      let i = r.get(e);
      return (
        i ||
        (e.addEventListener("dispose", s),
        e.isBufferGeometry
          ? (i = e)
          : e.isGeometry &&
            (void 0 === e._bufferGeometry &&
              (e._bufferGeometry = new le().setFromObject(t)),
            (i = e._bufferGeometry)),
        r.set(e, i),
        n.memory.geometries++,
        i)
      );
    },
    update: function (t) {
      const n = t.attributes;
      for (const t in n) e.update(n[t], 34962);
      const i = t.morphAttributes;
      for (const t in i) {
        const n = i[t];
        for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
      }
    },
    getWireframeAttribute: function (t) {
      const e = o.get(t);
      if (e) {
        const n = t.index;
        null !== n && e.version < n.version && a(t);
      } else a(t);
      return o.get(t);
    },
  };
}
function un(t, e, n, i) {
  const r = i.isWebGL2;
  let o, s, a;
  (this.setMode = function (t) {
    o = t;
  }),
    (this.setIndex = function (t) {
      (s = t.type), (a = t.bytesPerElement);
    }),
    (this.render = function (e, i) {
      t.drawElements(o, i, s, e * a), n.update(i, o, 1);
    }),
    (this.renderInstances = function (i, c, l) {
      if (0 === l) return;
      let h, u;
      if (r) (h = t), (u = "drawElementsInstanced");
      else if (
        ((h = e.get("ANGLE_instanced_arrays")),
        (u = "drawElementsInstancedANGLE"),
        null === h)
      )
        return void console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
      h[u](o, c, s, i * a, l), n.update(c, o, l);
    });
}
function dn(t) {
  const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return {
    memory: { geometries: 0, textures: 0 },
    render: e,
    programs: null,
    autoReset: !0,
    reset: function () {
      e.frame++,
        (e.calls = 0),
        (e.triangles = 0),
        (e.points = 0),
        (e.lines = 0);
    },
    update: function (t, n, i) {
      switch ((e.calls++, n)) {
        case 4:
          e.triangles += i * (t / 3);
          break;
        case 1:
          e.lines += i * (t / 2);
          break;
        case 3:
          e.lines += i * (t - 1);
          break;
        case 2:
          e.lines += i * t;
          break;
        case 0:
          e.points += i * t;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n);
      }
    },
  };
}
function pn(t, e) {
  return t[0] - e[0];
}
function fn(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function mn(t) {
  const e = {},
    n = new Float32Array(8),
    i = [];
  for (let t = 0; t < 8; t++) i[t] = [t, 0];
  return {
    update: function (r, o, s, a) {
      const c = r.morphTargetInfluences,
        l = void 0 === c ? 0 : c.length;
      let h = e[o.id];
      if (void 0 === h) {
        h = [];
        for (let t = 0; t < l; t++) h[t] = [t, 0];
        e[o.id] = h;
      }
      for (let t = 0; t < l; t++) {
        const e = h[t];
        (e[0] = t), (e[1] = c[t]);
      }
      h.sort(fn);
      for (let t = 0; t < 8; t++)
        t < l && h[t][1]
          ? ((i[t][0] = h[t][0]), (i[t][1] = h[t][1]))
          : ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
      i.sort(pn);
      const u = s.morphTargets && o.morphAttributes.position,
        d = s.morphNormals && o.morphAttributes.normal;
      let p = 0;
      for (let t = 0; t < 8; t++) {
        const e = i[t],
          r = e[0],
          s = e[1];
        r !== Number.MAX_SAFE_INTEGER && s
          ? (u &&
              o.getAttribute("morphTarget" + t) !== u[r] &&
              o.setAttribute("morphTarget" + t, u[r]),
            d &&
              o.getAttribute("morphNormal" + t) !== d[r] &&
              o.setAttribute("morphNormal" + t, d[r]),
            (n[t] = s),
            (p += s))
          : (u &&
              void 0 !== o.getAttribute("morphTarget" + t) &&
              o.deleteAttribute("morphTarget" + t),
            d &&
              void 0 !== o.getAttribute("morphNormal" + t) &&
              o.deleteAttribute("morphNormal" + t),
            (n[t] = 0));
      }
      const f = o.morphTargetsRelative ? 1 : 1 - p;
      a.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
        a.getUniforms().setValue(t, "morphTargetInfluences", n);
    },
  };
}
function gn(t, e, n, i) {
  let r = new WeakMap();
  return {
    update: function (t) {
      const o = i.render.frame,
        s = t.geometry,
        a = e.get(t, s);
      return (
        r.get(a) !== o &&
          (s.isGeometry && a.updateFromObject(t), e.update(a), r.set(a, o)),
        t.isInstancedMesh &&
          (n.update(t.instanceMatrix, 34962),
          null !== t.instanceColor && n.update(t.instanceColor, 34962)),
        a
      );
    },
    dispose: function () {
      r = new WeakMap();
    },
  };
}
function vn(t, e, n, i, r, o, s, a, c, l) {
  (t = void 0 !== t ? t : []),
    (e = void 0 !== e ? e : 301),
    (s = void 0 !== s ? s : 1022),
    u.call(this, t, e, n, i, r, o, s, a, c, l),
    (this.flipY = !1);
}
function yn(t, e, n, i) {
  u.call(this, null),
    (this.image = {
      data: t || null,
      width: e || 1,
      height: n || 1,
      depth: i || 1,
    }),
    (this.magFilter = 1003),
    (this.minFilter = 1003),
    (this.wrapR = 1001),
    (this.generateMipmaps = !1),
    (this.flipY = !1),
    (this.needsUpdate = !0);
}
function xn(t, e, n, i) {
  u.call(this, null),
    (this.image = {
      data: t || null,
      width: e || 1,
      height: n || 1,
      depth: i || 1,
    }),
    (this.magFilter = 1003),
    (this.minFilter = 1003),
    (this.wrapR = 1001),
    (this.generateMipmaps = !1),
    (this.flipY = !1),
    (this.needsUpdate = !0);
}
(en.physical = {
  uniforms: Fe([
    en.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new s(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: new zt(0) },
      transmission: { value: 0 },
      transmissionMap: { value: null },
    },
  ]),
  vertexShader: $e.meshphysical_vert,
  fragmentShader: $e.meshphysical_frag,
}),
  (vn.prototype = Object.create(u.prototype)),
  (vn.prototype.constructor = vn),
  (vn.prototype.isCubeTexture = !0),
  Object.defineProperty(vn.prototype, "images", {
    get: function () {
      return this.image;
    },
    set: function (t) {
      this.image = t;
    },
  }),
  (yn.prototype = Object.create(u.prototype)),
  (yn.prototype.constructor = yn),
  (yn.prototype.isDataTexture2DArray = !0),
  (xn.prototype = Object.create(u.prototype)),
  (xn.prototype.constructor = xn),
  (xn.prototype.isDataTexture3D = !0);
const bn = new u(),
  _n = new yn(),
  wn = new xn(),
  Mn = new vn(),
  Sn = [],
  Tn = [],
  En = new Float32Array(16),
  An = new Float32Array(9),
  Ln = new Float32Array(4);
function Rn(t, e, n) {
  const i = t[0];
  if (i <= 0 || i > 0) return t;
  const r = e * n;
  let o = Sn[r];
  if ((void 0 === o && ((o = new Float32Array(r)), (Sn[r] = o)), 0 !== e)) {
    i.toArray(o, 0);
    for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(o, r);
  }
  return o;
}
function Pn(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function Cn(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
}
function On(t, e) {
  let n = Tn[e];
  void 0 === n && ((n = new Int32Array(e)), (Tn[e] = n));
  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
  return n;
}
function Nn(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function In(t, e) {
  const n = this.cache;
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y) ||
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (Pn(n, e)) return;
    t.uniform2fv(this.addr, e), Cn(n, e);
  }
}
function Dn(t, e) {
  const n = this.cache;
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (void 0 !== e.r)
    (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if (Pn(n, e)) return;
    t.uniform3fv(this.addr, e), Cn(n, e);
  }
}
function Bn(t, e) {
  const n = this.cache;
  if (void 0 !== e.x)
    (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (Pn(n, e)) return;
    t.uniform4fv(this.addr, e), Cn(n, e);
  }
}
function zn(t, e) {
  const n = this.cache,
    i = e.elements;
  if (void 0 === i) {
    if (Pn(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Cn(n, e);
  } else {
    if (Pn(n, i)) return;
    Ln.set(i), t.uniformMatrix2fv(this.addr, !1, Ln), Cn(n, i);
  }
}
function Fn(t, e) {
  const n = this.cache,
    i = e.elements;
  if (void 0 === i) {
    if (Pn(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Cn(n, e);
  } else {
    if (Pn(n, i)) return;
    An.set(i), t.uniformMatrix3fv(this.addr, !1, An), Cn(n, i);
  }
}
function Un(t, e) {
  const n = this.cache,
    i = e.elements;
  if (void 0 === i) {
    if (Pn(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Cn(n, e);
  } else {
    if (Pn(n, i)) return;
    En.set(i), t.uniformMatrix4fv(this.addr, !1, En), Cn(n, i);
  }
}
function Gn(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.safeSetTexture2D(e || bn, r);
}
function Hn(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture2DArray(e || _n, r);
}
function kn(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture3D(e || wn, r);
}
function Vn(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.safeSetTextureCube(e || Mn, r);
}
function jn(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function Wn(t, e) {
  const n = this.cache;
  Pn(n, e) || (t.uniform2iv(this.addr, e), Cn(n, e));
}
function qn(t, e) {
  const n = this.cache;
  Pn(n, e) || (t.uniform3iv(this.addr, e), Cn(n, e));
}
function Xn(t, e) {
  const n = this.cache;
  Pn(n, e) || (t.uniform4iv(this.addr, e), Cn(n, e));
}
function Yn(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function Zn(t, e) {
  t.uniform1fv(this.addr, e);
}
function Jn(t, e) {
  t.uniform1iv(this.addr, e);
}
function Kn(t, e) {
  t.uniform2iv(this.addr, e);
}
function Qn(t, e) {
  t.uniform3iv(this.addr, e);
}
function $n(t, e) {
  t.uniform4iv(this.addr, e);
}
function ti(t, e) {
  const n = Rn(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function ei(t, e) {
  const n = Rn(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function ni(t, e) {
  const n = Rn(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function ii(t, e) {
  const n = Rn(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function ri(t, e) {
  const n = Rn(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function oi(t, e) {
  const n = Rn(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function si(t, e, n) {
  const i = e.length,
    r = On(n, i);
  t.uniform1iv(this.addr, r);
  for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || bn, r[t]);
}
function ai(t, e, n) {
  const i = e.length,
    r = On(n, i);
  t.uniform1iv(this.addr, r);
  for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Mn, r[t]);
}
function ci(t, e, n) {
  (this.id = t),
    (this.addr = n),
    (this.cache = []),
    (this.setValue = (function (t) {
      switch (t) {
        case 5126:
          return Nn;
        case 35664:
          return In;
        case 35665:
          return Dn;
        case 35666:
          return Bn;
        case 35674:
          return zn;
        case 35675:
          return Fn;
        case 35676:
          return Un;
        case 5124:
        case 35670:
          return jn;
        case 35667:
        case 35671:
          return Wn;
        case 35668:
        case 35672:
          return qn;
        case 35669:
        case 35673:
          return Xn;
        case 5125:
          return Yn;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Gn;
        case 35679:
        case 36299:
        case 36307:
          return kn;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Vn;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Hn;
      }
    })(e.type));
}
function li(t, e, n) {
  (this.id = t),
    (this.addr = n),
    (this.cache = []),
    (this.size = e.size),
    (this.setValue = (function (t) {
      switch (t) {
        case 5126:
          return Zn;
        case 35664:
          return ti;
        case 35665:
          return ei;
        case 35666:
          return ni;
        case 35674:
          return ii;
        case 35675:
          return ri;
        case 35676:
          return oi;
        case 5124:
        case 35670:
          return Jn;
        case 35667:
        case 35671:
          return Kn;
        case 35668:
        case 35672:
          return Qn;
        case 35669:
        case 35673:
          return $n;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return si;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return ai;
      }
    })(e.type));
}
function hi(t) {
  (this.id = t), (this.seq = []), (this.map = {});
}
(li.prototype.updateCache = function (t) {
  const e = this.cache;
  t instanceof Float32Array &&
    e.length !== t.length &&
    (this.cache = new Float32Array(t.length)),
    Cn(e, t);
}),
  (hi.prototype.setValue = function (t, e, n) {
    const i = this.seq;
    for (let r = 0, o = i.length; r !== o; ++r) {
      const o = i[r];
      o.setValue(t, e[o.id], n);
    }
  });
const ui = /([\w\d_]+)(\])?(\[|\.)?/g;
function di(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function pi(t, e, n) {
  const i = t.name,
    r = i.length;
  for (ui.lastIndex = 0; ; ) {
    const o = ui.exec(i),
      s = ui.lastIndex;
    let a = o[1];
    const c = "]" === o[2],
      l = o[3];
    if ((c && (a |= 0), void 0 === l || ("[" === l && s + 2 === r))) {
      di(n, void 0 === l ? new ci(a, t, e) : new li(a, t, e));
      break;
    }
    {
      let t = n.map[a];
      void 0 === t && ((t = new hi(a)), di(n, t)), (n = t);
    }
  }
}
function fi(t, e) {
  (this.seq = []), (this.map = {});
  const n = t.getProgramParameter(e, 35718);
  for (let i = 0; i < n; ++i) {
    const n = t.getActiveUniform(e, i);
    pi(n, t.getUniformLocation(e, n.name), this);
  }
}
function mi(t, e, n) {
  const i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}
(fi.prototype.setValue = function (t, e, n, i) {
  const r = this.map[e];
  void 0 !== r && r.setValue(t, n, i);
}),
  (fi.prototype.setOptional = function (t, e, n) {
    const i = e[n];
    void 0 !== i && this.setValue(t, n, i);
  }),
  (fi.upload = function (t, e, n, i) {
    for (let r = 0, o = e.length; r !== o; ++r) {
      const o = e[r],
        s = n[o.id];
      !1 !== s.needsUpdate && o.setValue(t, s.value, i);
    }
  }),
  (fi.seqWithValue = function (t, e) {
    const n = [];
    for (let i = 0, r = t.length; i !== r; ++i) {
      const r = t[i];
      r.id in e && n.push(r);
    }
    return n;
  });
let gi = 0;
function vi(t) {
  switch (t) {
    case 3e3:
      return ["Linear", "( value )"];
    case 3001:
      return ["sRGB", "( value )"];
    case 3002:
      return ["RGBE", "( value )"];
    case 3004:
      return ["RGBM", "( value, 7.0 )"];
    case 3005:
      return ["RGBM", "( value, 16.0 )"];
    case 3006:
      return ["RGBD", "( value, 256.0 )"];
    case 3007:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case 3003:
      return ["LogLuv", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
        ["Linear", "( value )"]
      );
  }
}
function yi(t, e, n) {
  const i = t.getShaderParameter(e, 35713),
    r = t.getShaderInfoLog(e).trim();
  if (i && "" === r) return "";
  return (
    "THREE.WebGLShader: gl.getShaderInfoLog() " +
    n +
    "\n" +
    r +
    (function (t) {
      const e = t.split("\n");
      for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
      return e.join("\n");
    })(t.getShaderSource(e))
  );
}
function xi(t, e) {
  const n = vi(e);
  return (
    "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
  );
}
function bi(t, e) {
  const n = vi(e);
  return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function _i(t, e) {
  let n;
  switch (e) {
    case 1:
      n = "Linear";
      break;
    case 2:
      n = "Reinhard";
      break;
    case 3:
      n = "OptimizedCineon";
      break;
    case 4:
      n = "ACESFilmic";
      break;
    case 5:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function wi(t) {
  return "" !== t;
}
function Mi(t, e) {
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Si(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const Ti = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ei(t) {
  return t.replace(Ti, Ai);
}
function Ai(t, e) {
  const n = $e[e];
  if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
  return Ei(n);
}
const Li =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  Ri =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Pi(t) {
  return t.replace(Ri, Oi).replace(Li, Ci);
}
function Ci(t, e, n, i) {
  return (
    console.warn(
      "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
    ),
    Oi(t, e, n, i)
  );
}
function Oi(t, e, n, i) {
  let r = "";
  for (let t = parseInt(e); t < parseInt(n); t++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, t);
  return r;
}
function Ni(t) {
  let e =
    "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
  return (
    "highp" === t.precision
      ? (e += "\n#define HIGH_PRECISION")
      : "mediump" === t.precision
      ? (e += "\n#define MEDIUM_PRECISION")
      : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
    e
  );
}
function Ii(t, e, n, i) {
  const r = t.getContext(),
    o = n.defines;
  let s = n.vertexShader,
    a = n.fragmentShader;
  const c = (function (t) {
      let e = "SHADOWMAP_TYPE_BASIC";
      return (
        1 === t.shadowMapType
          ? (e = "SHADOWMAP_TYPE_PCF")
          : 2 === t.shadowMapType
          ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
          : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
        e
      );
    })(n),
    l = (function (t) {
      let e = "ENVMAP_TYPE_CUBE";
      if (t.envMap)
        switch (t.envMapMode) {
          case 301:
          case 302:
            e = "ENVMAP_TYPE_CUBE";
            break;
          case 306:
          case 307:
            e = "ENVMAP_TYPE_CUBE_UV";
        }
      return e;
    })(n),
    h = (function (t) {
      let e = "ENVMAP_MODE_REFLECTION";
      if (t.envMap)
        switch (t.envMapMode) {
          case 302:
          case 307:
            e = "ENVMAP_MODE_REFRACTION";
        }
      return e;
    })(n),
    u = (function (t) {
      let e = "ENVMAP_BLENDING_NONE";
      if (t.envMap)
        switch (t.combine) {
          case 0:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case 1:
            e = "ENVMAP_BLENDING_MIX";
            break;
          case 2:
            e = "ENVMAP_BLENDING_ADD";
        }
      return e;
    })(n),
    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
    p = n.isWebGL2
      ? ""
      : (function (t) {
          return [
            t.extensionDerivatives ||
            t.envMapCubeUV ||
            t.bumpMap ||
            t.tangentSpaceNormalMap ||
            t.clearcoatNormalMap ||
            t.flatShading ||
            "physical" === t.shaderID
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
            t.rendererExtensionFragDepth
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (t.extensionShaderTextureLOD || t.envMap) &&
            t.rendererExtensionShaderTextureLod
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : "",
          ]
            .filter(wi)
            .join("\n");
        })(n),
    f = (function (t) {
      const e = [];
      for (const n in t) {
        const i = t[n];
        !1 !== i && e.push("#define " + n + " " + i);
      }
      return e.join("\n");
    })(o),
    m = r.createProgram();
  let g,
    v,
    y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
  n.isRawShaderMaterial
    ? ((g = [f].filter(wi).join("\n")),
      g.length > 0 && (g += "\n"),
      (v = [p, f].filter(wi).join("\n")),
      v.length > 0 && (v += "\n"))
    : ((g = [
        Ni(n),
        "#define SHADER_NAME " + n.shaderName,
        f,
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + d,
        "#define MAX_BONES " + n.maxBones,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + h : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMap && n.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        n.normalMap && n.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.displacementMap && n.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.vertexTangents ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexUvs ? "#define USE_UV" : "",
        n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.useVertexTexture ? "#define BONE_TEXTURE" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && !1 === n.flatShading
          ? "#define USE_MORPHNORMALS"
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + c : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "\tattribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "\tattribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "\tattribute vec4 tangent;",
        "#endif",
        "#ifdef USE_COLOR",
        "\tattribute vec3 color;",
        "#endif",
        "#ifdef USE_MORPHTARGETS",
        "\tattribute vec3 morphTarget0;",
        "\tattribute vec3 morphTarget1;",
        "\tattribute vec3 morphTarget2;",
        "\tattribute vec3 morphTarget3;",
        "\t#ifdef USE_MORPHNORMALS",
        "\t\tattribute vec3 morphNormal0;",
        "\t\tattribute vec3 morphNormal1;",
        "\t\tattribute vec3 morphNormal2;",
        "\t\tattribute vec3 morphNormal3;",
        "\t#else",
        "\t\tattribute vec3 morphTarget4;",
        "\t\tattribute vec3 morphTarget5;",
        "\t\tattribute vec3 morphTarget6;",
        "\t\tattribute vec3 morphTarget7;",
        "\t#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "\tattribute vec4 skinIndex;",
        "\tattribute vec4 skinWeight;",
        "#endif",
        "\n",
      ]
        .filter(wi)
        .join("\n")),
      (v = [
        p,
        Ni(n),
        "#define SHADER_NAME " + n.shaderName,
        f,
        n.alphaTest
          ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0")
          : "",
        "#define GAMMA_FACTOR " + d,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + l : "",
        n.envMap ? "#define " + h : "",
        n.envMap ? "#define " + u : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMap && n.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        n.normalMap && n.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.vertexTangents ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
        n.vertexUvs ? "#define USE_UV" : "",
        n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + c : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        (n.extensionShaderTextureLOD || n.envMap) &&
        n.rendererExtensionShaderTextureLod
          ? "#define TEXTURE_LOD_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
        0 !== n.toneMapping ? $e.tonemapping_pars_fragment : "",
        0 !== n.toneMapping ? _i("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        $e.encodings_pars_fragment,
        n.map ? xi("mapTexelToLinear", n.mapEncoding) : "",
        n.matcap ? xi("matcapTexelToLinear", n.matcapEncoding) : "",
        n.envMap ? xi("envMapTexelToLinear", n.envMapEncoding) : "",
        n.emissiveMap
          ? xi("emissiveMapTexelToLinear", n.emissiveMapEncoding)
          : "",
        n.lightMap ? xi("lightMapTexelToLinear", n.lightMapEncoding) : "",
        bi("linearToOutputTexel", n.outputEncoding),
        n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        "\n",
      ]
        .filter(wi)
        .join("\n"))),
    (s = Ei(s)),
    (s = Mi(s, n)),
    (s = Si(s, n)),
    (a = Ei(a)),
    (a = Mi(a, n)),
    (a = Si(a, n)),
    (s = Pi(s)),
    (a = Pi(a)),
    n.isWebGL2 &&
      !0 !== n.isRawShaderMaterial &&
      ((y = "#version 300 es\n"),
      (g =
        [
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join("\n") +
        "\n" +
        g),
      (v =
        [
          "#define varying in",
          "300 es" === n.glslVersion ? "" : "out highp vec4 pc_fragColor;",
          "300 es" === n.glslVersion ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join("\n") +
        "\n" +
        v));
  const x = y + v + a,
    b = mi(r, 35633, y + g + s),
    _ = mi(r, 35632, x);
  if (
    (r.attachShader(m, b),
    r.attachShader(m, _),
    void 0 !== n.index0AttributeName
      ? r.bindAttribLocation(m, 0, n.index0AttributeName)
      : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
    r.linkProgram(m),
    t.debug.checkShaderErrors)
  ) {
    const t = r.getProgramInfoLog(m).trim(),
      e = r.getShaderInfoLog(b).trim(),
      n = r.getShaderInfoLog(_).trim();
    let i = !0,
      o = !0;
    if (!1 === r.getProgramParameter(m, 35714)) {
      i = !1;
      const e = yi(r, b, "vertex"),
        n = yi(r, _, "fragment");
      console.error(
        "THREE.WebGLProgram: shader error: ",
        r.getError(),
        "35715",
        r.getProgramParameter(m, 35715),
        "gl.getProgramInfoLog",
        t,
        e,
        n
      );
    } else
      "" !== t
        ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
        : ("" !== e && "" !== n) || (o = !1);
    o &&
      (this.diagnostics = {
        runnable: i,
        programLog: t,
        vertexShader: { log: e, prefix: g },
        fragmentShader: { log: n, prefix: v },
      });
  }
  let w, M;
  return (
    r.deleteShader(b),
    r.deleteShader(_),
    (this.getUniforms = function () {
      return void 0 === w && (w = new fi(r, m)), w;
    }),
    (this.getAttributes = function () {
      return (
        void 0 === M &&
          (M = (function (t, e) {
            const n = {},
              i = t.getProgramParameter(e, 35721);
            for (let r = 0; r < i; r++) {
              const i = t.getActiveAttrib(e, r).name;
              n[i] = t.getAttribLocation(e, i);
            }
            return n;
          })(r, m)),
        M
      );
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(m),
        (this.program = void 0);
    }),
    (this.name = n.shaderName),
    (this.id = gi++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = b),
    (this.fragmentShader = _),
    this
  );
}
function Di(t, e, n, i, r, o) {
  const s = [],
    a = i.isWebGL2,
    c = i.logarithmicDepthBuffer,
    l = i.floatVertexTextures,
    h = i.maxVertexUniforms,
    u = i.vertexTextures;
  let d = i.precision;
  const p = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    },
    f = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "instancingColor",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "combine",
      "vertexColors",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "maxMorphTargets",
      "maxMorphNormals",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "alphaTest",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "sheen",
      "transmissionMap",
    ];
  function m(t) {
    let e;
    return (
      t
        ? t.isTexture
          ? (e = t.encoding)
          : t.isWebGLRenderTarget &&
            (console.warn(
              "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
            ),
            (e = t.texture.encoding))
        : (e = 3e3),
      e
    );
  }
  return {
    getParameters: function (r, s, f, g, v) {
      const y = g.fog,
        x = r.isMeshStandardMaterial ? g.environment : null,
        b = e.get(r.envMap || x),
        _ = p[r.type],
        w = v.isSkinnedMesh
          ? (function (t) {
              const e = t.skeleton.bones;
              if (l) return 1024;
              {
                const t = h,
                  n = Math.floor((t - 20) / 4),
                  i = Math.min(n, e.length);
                return i < e.length
                  ? (console.warn(
                      "THREE.WebGLRenderer: Skeleton has " +
                        e.length +
                        " bones. This GPU supports " +
                        i +
                        "."
                    ),
                    0)
                  : i;
              }
            })(v)
          : 0;
      let M, S;
      if (
        (null !== r.precision &&
          ((d = i.getMaxPrecision(r.precision)),
          d !== r.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              r.precision,
              "not supported, using",
              d,
              "instead."
            )),
        _)
      ) {
        const t = en[_];
        (M = t.vertexShader), (S = t.fragmentShader);
      } else (M = r.vertexShader), (S = r.fragmentShader);
      const T = t.getRenderTarget();
      return {
        isWebGL2: a,
        shaderID: _,
        shaderName: r.type,
        vertexShader: M,
        fragmentShader: S,
        defines: r.defines,
        isRawShaderMaterial: !0 === r.isRawShaderMaterial,
        glslVersion: r.glslVersion,
        precision: d,
        instancing: !0 === v.isInstancedMesh,
        instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
        supportsVertexTextures: u,
        outputEncoding: null !== T ? m(T.texture) : t.outputEncoding,
        map: !!r.map,
        mapEncoding: m(r.map),
        matcap: !!r.matcap,
        matcapEncoding: m(r.matcap),
        envMap: !!b,
        envMapMode: b && b.mapping,
        envMapEncoding: m(b),
        envMapCubeUV: !!b && (306 === b.mapping || 307 === b.mapping),
        lightMap: !!r.lightMap,
        lightMapEncoding: m(r.lightMap),
        aoMap: !!r.aoMap,
        emissiveMap: !!r.emissiveMap,
        emissiveMapEncoding: m(r.emissiveMap),
        bumpMap: !!r.bumpMap,
        normalMap: !!r.normalMap,
        objectSpaceNormalMap: 1 === r.normalMapType,
        tangentSpaceNormalMap: 0 === r.normalMapType,
        clearcoatMap: !!r.clearcoatMap,
        clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
        clearcoatNormalMap: !!r.clearcoatNormalMap,
        displacementMap: !!r.displacementMap,
        roughnessMap: !!r.roughnessMap,
        metalnessMap: !!r.metalnessMap,
        specularMap: !!r.specularMap,
        alphaMap: !!r.alphaMap,
        gradientMap: !!r.gradientMap,
        sheen: !!r.sheen,
        transmissionMap: !!r.transmissionMap,
        combine: r.combine,
        vertexTangents: r.normalMap && r.vertexTangents,
        vertexColors: r.vertexColors,
        vertexUvs: !!(
          r.map ||
          r.bumpMap ||
          r.normalMap ||
          r.specularMap ||
          r.alphaMap ||
          r.emissiveMap ||
          r.roughnessMap ||
          r.metalnessMap ||
          r.clearcoatMap ||
          r.clearcoatRoughnessMap ||
          r.clearcoatNormalMap ||
          r.displacementMap ||
          r.transmissionMap
        ),
        uvsVertexOnly: !(
          r.map ||
          r.bumpMap ||
          r.normalMap ||
          r.specularMap ||
          r.alphaMap ||
          r.emissiveMap ||
          r.roughnessMap ||
          r.metalnessMap ||
          r.clearcoatNormalMap ||
          r.transmissionMap ||
          !r.displacementMap
        ),
        fog: !!y,
        useFog: r.fog,
        fogExp2: y && y.isFogExp2,
        flatShading: r.flatShading,
        sizeAttenuation: r.sizeAttenuation,
        logarithmicDepthBuffer: c,
        skinning: r.skinning && w > 0,
        maxBones: w,
        useVertexTexture: l,
        morphTargets: r.morphTargets,
        morphNormals: r.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: s.directional.length,
        numPointLights: s.point.length,
        numSpotLights: s.spot.length,
        numRectAreaLights: s.rectArea.length,
        numHemiLights: s.hemi.length,
        numDirLightShadows: s.directionalShadowMap.length,
        numPointLightShadows: s.pointShadowMap.length,
        numSpotLightShadows: s.spotShadowMap.length,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: r.dithering,
        shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: r.toneMapped ? t.toneMapping : 0,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: r.premultipliedAlpha,
        alphaTest: r.alphaTest,
        doubleSided: 2 === r.side,
        flipSided: 1 === r.side,
        depthPacking: void 0 !== r.depthPacking && r.depthPacking,
        index0AttributeName: r.index0AttributeName,
        extensionDerivatives: r.extensions && r.extensions.derivatives,
        extensionFragDepth: r.extensions && r.extensions.fragDepth,
        extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
        extensionShaderTextureLOD:
          r.extensions && r.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
        customProgramCacheKey: r.customProgramCacheKey(),
      };
    },
    getProgramCacheKey: function (e) {
      const n = [];
      if (
        (e.shaderID
          ? n.push(e.shaderID)
          : (n.push(e.fragmentShader), n.push(e.vertexShader)),
        void 0 !== e.defines)
      )
        for (const t in e.defines) n.push(t), n.push(e.defines[t]);
      if (!1 === e.isRawShaderMaterial) {
        for (let t = 0; t < f.length; t++) n.push(e[f[t]]);
        n.push(t.outputEncoding), n.push(t.gammaFactor);
      }
      return n.push(e.customProgramCacheKey), n.join();
    },
    getUniforms: function (t) {
      const e = p[t.type];
      let n;
      if (e) {
        const t = en[e];
        n = Ue.clone(t.uniforms);
      } else n = t.uniforms;
      return n;
    },
    acquireProgram: function (e, n) {
      let i;
      for (let t = 0, e = s.length; t < e; t++) {
        const e = s[t];
        if (e.cacheKey === n) {
          (i = e), ++i.usedTimes;
          break;
        }
      }
      return void 0 === i && ((i = new Ii(t, n, e, r)), s.push(i)), i;
    },
    releaseProgram: function (t) {
      if (0 == --t.usedTimes) {
        const e = s.indexOf(t);
        (s[e] = s[s.length - 1]), s.pop(), t.destroy();
      }
    },
    programs: s,
  };
}
function Bi() {
  let t = new WeakMap();
  return {
    get: function (e) {
      let n = t.get(e);
      return void 0 === n && ((n = {}), t.set(e, n)), n;
    },
    remove: function (e) {
      t.delete(e);
    },
    update: function (e, n, i) {
      t.get(e)[n] = i;
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
function zi(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.program !== e.program
    ? t.program.id - e.program.id
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function Fi(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function Ui(t) {
  const e = [];
  let n = 0;
  const i = [],
    r = [],
    o = { id: -1 };
  function s(i, r, s, a, c, l) {
    let h = e[n];
    const u = t.get(s);
    return (
      void 0 === h
        ? ((h = {
            id: i.id,
            object: i,
            geometry: r,
            material: s,
            program: u.program || o,
            groupOrder: a,
            renderOrder: i.renderOrder,
            z: c,
            group: l,
          }),
          (e[n] = h))
        : ((h.id = i.id),
          (h.object = i),
          (h.geometry = r),
          (h.material = s),
          (h.program = u.program || o),
          (h.groupOrder = a),
          (h.renderOrder = i.renderOrder),
          (h.z = c),
          (h.group = l)),
      n++,
      h
    );
  }
  return {
    opaque: i,
    transparent: r,
    init: function () {
      (n = 0), (i.length = 0), (r.length = 0);
    },
    push: function (t, e, n, o, a, c) {
      const l = s(t, e, n, o, a, c);
      (!0 === n.transparent ? r : i).push(l);
    },
    unshift: function (t, e, n, o, a, c) {
      const l = s(t, e, n, o, a, c);
      (!0 === n.transparent ? r : i).unshift(l);
    },
    finish: function () {
      for (let t = n, i = e.length; t < i; t++) {
        const n = e[t];
        if (null === n.id) break;
        (n.id = null),
          (n.object = null),
          (n.geometry = null),
          (n.material = null),
          (n.program = null),
          (n.group = null);
      }
    },
    sort: function (t, e) {
      i.length > 1 && i.sort(t || zi), r.length > 1 && r.sort(e || Fi);
    },
  };
}
function Gi(t) {
  let e = new WeakMap();
  return {
    get: function (n, i) {
      const r = e.get(n);
      let o;
      return (
        void 0 === r
          ? ((o = new Ui(t)), e.set(n, new WeakMap()), e.get(n).set(i, o))
          : ((o = r.get(i)), void 0 === o && ((o = new Ui(t)), r.set(i, o))),
        o
      );
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function Hi() {
  const t = {};
  return {
    get: function (e) {
      if (void 0 !== t[e.id]) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = { direction: new g(), color: new zt() };
          break;
        case "SpotLight":
          n = {
            position: new g(),
            direction: new g(),
            color: new zt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = { position: new g(), color: new zt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          n = { direction: new g(), skyColor: new zt(), groundColor: new zt() };
          break;
        case "RectAreaLight":
          n = {
            color: new zt(),
            position: new g(),
            halfWidth: new g(),
            halfHeight: new g(),
          };
      }
      return (t[e.id] = n), n;
    },
  };
}
let ki = 0;
function Vi(t, e) {
  return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
function ji() {
  const t = new Hi(),
    e = (function () {
      const t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case "DirectionalLight":
            case "SpotLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new s(),
              };
              break;
            case "PointLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new s(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3,
              };
          }
          return (t[e.id] = n), n;
        },
      };
    })(),
    n = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    };
  for (let t = 0; t < 9; t++) n.probe.push(new g());
  const i = new g(),
    r = new j(),
    o = new j();
  return {
    setup: function (s, a, c) {
      let l = 0,
        h = 0,
        u = 0;
      for (let t = 0; t < 9; t++) n.probe[t].set(0, 0, 0);
      let d = 0,
        p = 0,
        f = 0,
        m = 0,
        g = 0,
        v = 0,
        y = 0,
        x = 0;
      const b = c.matrixWorldInverse;
      s.sort(Vi);
      for (let a = 0, c = s.length; a < c; a++) {
        const c = s[a],
          _ = c.color,
          w = c.intensity,
          M = c.distance,
          S = c.shadow && c.shadow.map ? c.shadow.map.texture : null;
        if (c.isAmbientLight) (l += _.r * w), (h += _.g * w), (u += _.b * w);
        else if (c.isLightProbe)
          for (let t = 0; t < 9; t++)
            n.probe[t].addScaledVector(c.sh.coefficients[t], w);
        else if (c.isDirectionalLight) {
          const r = t.get(c);
          if (
            (r.color.copy(c.color).multiplyScalar(c.intensity),
            r.direction.setFromMatrixPosition(c.matrixWorld),
            i.setFromMatrixPosition(c.target.matrixWorld),
            r.direction.sub(i),
            r.direction.transformDirection(b),
            c.castShadow)
          ) {
            const t = c.shadow,
              i = e.get(c);
            (i.shadowBias = t.bias),
              (i.shadowNormalBias = t.normalBias),
              (i.shadowRadius = t.radius),
              (i.shadowMapSize = t.mapSize),
              (n.directionalShadow[d] = i),
              (n.directionalShadowMap[d] = S),
              (n.directionalShadowMatrix[d] = c.shadow.matrix),
              v++;
          }
          (n.directional[d] = r), d++;
        } else if (c.isSpotLight) {
          const r = t.get(c);
          if (
            (r.position.setFromMatrixPosition(c.matrixWorld),
            r.position.applyMatrix4(b),
            r.color.copy(_).multiplyScalar(w),
            (r.distance = M),
            r.direction.setFromMatrixPosition(c.matrixWorld),
            i.setFromMatrixPosition(c.target.matrixWorld),
            r.direction.sub(i),
            r.direction.transformDirection(b),
            (r.coneCos = Math.cos(c.angle)),
            (r.penumbraCos = Math.cos(c.angle * (1 - c.penumbra))),
            (r.decay = c.decay),
            c.castShadow)
          ) {
            const t = c.shadow,
              i = e.get(c);
            (i.shadowBias = t.bias),
              (i.shadowNormalBias = t.normalBias),
              (i.shadowRadius = t.radius),
              (i.shadowMapSize = t.mapSize),
              (n.spotShadow[f] = i),
              (n.spotShadowMap[f] = S),
              (n.spotShadowMatrix[f] = c.shadow.matrix),
              x++;
          }
          (n.spot[f] = r), f++;
        } else if (c.isRectAreaLight) {
          const e = t.get(c);
          e.color.copy(_).multiplyScalar(w),
            e.position.setFromMatrixPosition(c.matrixWorld),
            e.position.applyMatrix4(b),
            o.identity(),
            r.copy(c.matrixWorld),
            r.premultiply(b),
            o.extractRotation(r),
            e.halfWidth.set(0.5 * c.width, 0, 0),
            e.halfHeight.set(0, 0.5 * c.height, 0),
            e.halfWidth.applyMatrix4(o),
            e.halfHeight.applyMatrix4(o),
            (n.rectArea[m] = e),
            m++;
        } else if (c.isPointLight) {
          const i = t.get(c);
          if (
            (i.position.setFromMatrixPosition(c.matrixWorld),
            i.position.applyMatrix4(b),
            i.color.copy(c.color).multiplyScalar(c.intensity),
            (i.distance = c.distance),
            (i.decay = c.decay),
            c.castShadow)
          ) {
            const t = c.shadow,
              i = e.get(c);
            (i.shadowBias = t.bias),
              (i.shadowNormalBias = t.normalBias),
              (i.shadowRadius = t.radius),
              (i.shadowMapSize = t.mapSize),
              (i.shadowCameraNear = t.camera.near),
              (i.shadowCameraFar = t.camera.far),
              (n.pointShadow[p] = i),
              (n.pointShadowMap[p] = S),
              (n.pointShadowMatrix[p] = c.shadow.matrix),
              y++;
          }
          (n.point[p] = i), p++;
        } else if (c.isHemisphereLight) {
          const e = t.get(c);
          e.direction.setFromMatrixPosition(c.matrixWorld),
            e.direction.transformDirection(b),
            e.direction.normalize(),
            e.skyColor.copy(c.color).multiplyScalar(w),
            e.groundColor.copy(c.groundColor).multiplyScalar(w),
            (n.hemi[g] = e),
            g++;
        }
      }
      m > 0 && ((n.rectAreaLTC1 = tn.LTC_1), (n.rectAreaLTC2 = tn.LTC_2)),
        (n.ambient[0] = l),
        (n.ambient[1] = h),
        (n.ambient[2] = u);
      const _ = n.hash;
      (_.directionalLength === d &&
        _.pointLength === p &&
        _.spotLength === f &&
        _.rectAreaLength === m &&
        _.hemiLength === g &&
        _.numDirectionalShadows === v &&
        _.numPointShadows === y &&
        _.numSpotShadows === x) ||
        ((n.directional.length = d),
        (n.spot.length = f),
        (n.rectArea.length = m),
        (n.point.length = p),
        (n.hemi.length = g),
        (n.directionalShadow.length = v),
        (n.directionalShadowMap.length = v),
        (n.pointShadow.length = y),
        (n.pointShadowMap.length = y),
        (n.spotShadow.length = x),
        (n.spotShadowMap.length = x),
        (n.directionalShadowMatrix.length = v),
        (n.pointShadowMatrix.length = y),
        (n.spotShadowMatrix.length = x),
        (_.directionalLength = d),
        (_.pointLength = p),
        (_.spotLength = f),
        (_.rectAreaLength = m),
        (_.hemiLength = g),
        (_.numDirectionalShadows = v),
        (_.numPointShadows = y),
        (_.numSpotShadows = x),
        (n.version = ki++));
    },
    state: n,
  };
}
function Wi() {
  const t = new ji(),
    e = [],
    n = [];
  return {
    init: function () {
      (e.length = 0), (n.length = 0);
    },
    state: { lightsArray: e, shadowsArray: n, lights: t },
    setupLights: function (i) {
      t.setup(e, n, i);
    },
    pushLight: function (t) {
      e.push(t);
    },
    pushShadow: function (t) {
      n.push(t);
    },
  };
}
function qi() {
  let t = new WeakMap();
  return {
    get: function (e, n) {
      let i;
      return (
        !1 === t.has(e)
          ? ((i = new Wi()), t.set(e, new WeakMap()), t.get(e).set(n, i))
          : !1 === t.get(e).has(n)
          ? ((i = new Wi()), t.get(e).set(n, i))
          : (i = t.get(e).get(n)),
        i
      );
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
function Xi(t) {
  Gt.call(this),
    (this.type = "MeshDepthMaterial"),
    (this.depthPacking = 3200),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.map = null),
    (this.alphaMap = null),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.fog = !1),
    this.setValues(t);
}
function Yi(t) {
  Gt.call(this),
    (this.type = "MeshDistanceMaterial"),
    (this.referencePosition = new g()),
    (this.nearDistance = 1),
    (this.farDistance = 1e3),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.map = null),
    (this.alphaMap = null),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.fog = !1),
    this.setValues(t);
}
(Xi.prototype = Object.create(Gt.prototype)),
  (Xi.prototype.constructor = Xi),
  (Xi.prototype.isMeshDepthMaterial = !0),
  (Xi.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      (this.depthPacking = t.depthPacking),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    );
  }),
  (Yi.prototype = Object.create(Gt.prototype)),
  (Yi.prototype.constructor = Yi),
  (Yi.prototype.isMeshDistanceMaterial = !0),
  (Yi.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.referencePosition.copy(t.referencePosition),
      (this.nearDistance = t.nearDistance),
      (this.farDistance = t.farDistance),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    );
  });
function Zi(t, e, n) {
  let i = new Ye();
  const r = new s(),
    o = new s(),
    a = new d(),
    c = [],
    l = [],
    h = {},
    u = { 0: 1, 1: 0, 2: 2 },
    f = new Ge({
      defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new s() },
        radius: { value: 4 },
      },
      vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
      fragmentShader:
        "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
    }),
    m = f.clone();
  m.defines.HORIZONAL_PASS = 1;
  const g = new le();
  g.setAttribute(
    "position",
    new jt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const v = new Ae(g, f),
    y = this;
  function x(n, i) {
    const r = e.update(v);
    (f.uniforms.shadow_pass.value = n.map.texture),
      (f.uniforms.resolution.value = n.mapSize),
      (f.uniforms.radius.value = n.radius),
      t.setRenderTarget(n.mapPass),
      t.clear(),
      t.renderBufferDirect(i, null, r, f, v, null),
      (m.uniforms.shadow_pass.value = n.mapPass.texture),
      (m.uniforms.resolution.value = n.mapSize),
      (m.uniforms.radius.value = n.radius),
      t.setRenderTarget(n.map),
      t.clear(),
      t.renderBufferDirect(i, null, r, m, v, null);
  }
  function b(t, e, n) {
    const i = (t << 0) | (e << 1) | (n << 2);
    let r = c[i];
    return (
      void 0 === r &&
        ((r = new Xi({ depthPacking: 3201, morphTargets: t, skinning: e })),
        (c[i] = r)),
      r
    );
  }
  function _(t, e, n) {
    const i = (t << 0) | (e << 1) | (n << 2);
    let r = l[i];
    return (
      void 0 === r &&
        ((r = new Yi({ morphTargets: t, skinning: e })), (l[i] = r)),
      r
    );
  }
  function w(e, n, i, r, o, s, a) {
    let c = null,
      l = b,
      d = e.customDepthMaterial;
    if (
      (!0 === r.isPointLight && ((l = _), (d = e.customDistanceMaterial)),
      void 0 === d)
    ) {
      let t = !1;
      !0 === i.morphTargets &&
        (t =
          n.morphAttributes &&
          n.morphAttributes.position &&
          n.morphAttributes.position.length > 0);
      let r = !1;
      !0 === e.isSkinnedMesh &&
        (!0 === i.skinning
          ? (r = !0)
          : console.warn(
              "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
              e
            ));
      c = l(t, r, !0 === e.isInstancedMesh);
    } else c = d;
    if (
      t.localClippingEnabled &&
      !0 === i.clipShadows &&
      0 !== i.clippingPlanes.length
    ) {
      const t = c.uuid,
        e = i.uuid;
      let n = h[t];
      void 0 === n && ((n = {}), (h[t] = n));
      let r = n[e];
      void 0 === r && ((r = c.clone()), (n[e] = r)), (c = r);
    }
    return (
      (c.visible = i.visible),
      (c.wireframe = i.wireframe),
      (c.side =
        3 === a
          ? null !== i.shadowSide
            ? i.shadowSide
            : i.side
          : null !== i.shadowSide
          ? i.shadowSide
          : u[i.side]),
      (c.clipShadows = i.clipShadows),
      (c.clippingPlanes = i.clippingPlanes),
      (c.clipIntersection = i.clipIntersection),
      (c.wireframeLinewidth = i.wireframeLinewidth),
      (c.linewidth = i.linewidth),
      !0 === r.isPointLight &&
        !0 === c.isMeshDistanceMaterial &&
        (c.referencePosition.setFromMatrixPosition(r.matrixWorld),
        (c.nearDistance = o),
        (c.farDistance = s)),
      c
    );
  }
  function M(n, r, o, s, a) {
    if (!1 === n.visible) return;
    if (
      n.layers.test(r.layers) &&
      (n.isMesh || n.isLine || n.isPoints) &&
      (n.castShadow || (n.receiveShadow && 3 === a)) &&
      (!n.frustumCulled || i.intersectsObject(n))
    ) {
      n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
      const i = e.update(n),
        r = n.material;
      if (Array.isArray(r)) {
        const e = i.groups;
        for (let c = 0, l = e.length; c < l; c++) {
          const l = e[c],
            h = r[l.materialIndex];
          if (h && h.visible) {
            const e = w(n, i, h, s, o.near, o.far, a);
            t.renderBufferDirect(o, null, i, e, n, l);
          }
        }
      } else if (r.visible) {
        const e = w(n, i, r, s, o.near, o.far, a);
        t.renderBufferDirect(o, null, i, e, n, null);
      }
    }
    const c = n.children;
    for (let t = 0, e = c.length; t < e; t++) M(c[t], r, o, s, a);
  }
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = 1),
    (this.render = function (e, s, c) {
      if (!1 === y.enabled) return;
      if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
      if (0 === e.length) return;
      const l = t.getRenderTarget(),
        h = t.getActiveCubeFace(),
        u = t.getActiveMipmapLevel(),
        d = t.state;
      d.setBlending(0),
        d.buffers.color.setClear(1, 1, 1, 1),
        d.buffers.depth.setTest(!0),
        d.setScissorTest(!1);
      for (let l = 0, h = e.length; l < h; l++) {
        const h = e[l],
          u = h.shadow;
        if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
        if (void 0 === u) {
          console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
          continue;
        }
        r.copy(u.mapSize);
        const f = u.getFrameExtents();
        if (
          (r.multiply(f),
          o.copy(u.mapSize),
          (r.x > n || r.y > n) &&
            (r.x > n &&
              ((o.x = Math.floor(n / f.x)),
              (r.x = o.x * f.x),
              (u.mapSize.x = o.x)),
            r.y > n &&
              ((o.y = Math.floor(n / f.y)),
              (r.y = o.y * f.y),
              (u.mapSize.y = o.y))),
          null === u.map && !u.isPointLightShadow && 3 === this.type)
        ) {
          const t = { minFilter: 1006, magFilter: 1006, format: 1023 };
          (u.map = new p(r.x, r.y, t)),
            (u.map.texture.name = h.name + ".shadowMap"),
            (u.mapPass = new p(r.x, r.y, t)),
            u.camera.updateProjectionMatrix();
        }
        if (null === u.map) {
          const t = { minFilter: 1003, magFilter: 1003, format: 1023 };
          (u.map = new p(r.x, r.y, t)),
            (u.map.texture.name = h.name + ".shadowMap"),
            u.camera.updateProjectionMatrix();
        }
        t.setRenderTarget(u.map), t.clear();
        const m = u.getViewportCount();
        for (let t = 0; t < m; t++) {
          const e = u.getViewport(t);
          a.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
            d.viewport(a),
            u.updateMatrices(h, t),
            (i = u.getFrustum()),
            M(s, c, u.camera, h, this.type);
        }
        u.isPointLightShadow || 3 !== this.type || x(u, c),
          (u.needsUpdate = !1);
      }
      (y.needsUpdate = !1), t.setRenderTarget(l, h, u);
    });
}
function Ji(t, e, n) {
  const i = n.isWebGL2;
  const r = new (function () {
      let e = !1;
      const n = new d();
      let i = null;
      const r = new d(0, 0, 0, 0);
      return {
        setMask: function (n) {
          i === n || e || (t.colorMask(n, n, n, n), (i = n));
        },
        setLocked: function (t) {
          e = t;
        },
        setClear: function (e, i, o, s, a) {
          !0 === a && ((e *= s), (i *= s), (o *= s)),
            n.set(e, i, o, s),
            !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n));
        },
        reset: function () {
          (e = !1), (i = null), r.set(-1, 0, 0, 0);
        },
      };
    })(),
    o = new (function () {
      let e = !1,
        n = null,
        i = null,
        r = null;
      return {
        setTest: function (t) {
          t ? I(2929) : D(2929);
        },
        setMask: function (i) {
          n === i || e || (t.depthMask(i), (n = i));
        },
        setFunc: function (e) {
          if (i !== e) {
            if (e)
              switch (e) {
                case 0:
                  t.depthFunc(512);
                  break;
                case 1:
                  t.depthFunc(519);
                  break;
                case 2:
                  t.depthFunc(513);
                  break;
                case 3:
                  t.depthFunc(515);
                  break;
                case 4:
                  t.depthFunc(514);
                  break;
                case 5:
                  t.depthFunc(518);
                  break;
                case 6:
                  t.depthFunc(516);
                  break;
                case 7:
                  t.depthFunc(517);
                  break;
                default:
                  t.depthFunc(515);
              }
            else t.depthFunc(515);
            i = e;
          }
        },
        setLocked: function (t) {
          e = t;
        },
        setClear: function (e) {
          r !== e && (t.clearDepth(e), (r = e));
        },
        reset: function () {
          (e = !1), (n = null), (i = null), (r = null);
        },
      };
    })(),
    s = new (function () {
      let e = !1,
        n = null,
        i = null,
        r = null,
        o = null,
        s = null,
        a = null,
        c = null,
        l = null;
      return {
        setTest: function (t) {
          e || (t ? I(2960) : D(2960));
        },
        setMask: function (i) {
          n === i || e || (t.stencilMask(i), (n = i));
        },
        setFunc: function (e, n, s) {
          (i === e && r === n && o === s) ||
            (t.stencilFunc(e, n, s), (i = e), (r = n), (o = s));
        },
        setOp: function (e, n, i) {
          (s === e && a === n && c === i) ||
            (t.stencilOp(e, n, i), (s = e), (a = n), (c = i));
        },
        setLocked: function (t) {
          e = t;
        },
        setClear: function (e) {
          l !== e && (t.clearStencil(e), (l = e));
        },
        reset: function () {
          (e = !1),
            (n = null),
            (i = null),
            (r = null),
            (o = null),
            (s = null),
            (a = null),
            (c = null),
            (l = null);
        },
      };
    })();
  let a = {},
    c = null,
    l = null,
    h = null,
    u = null,
    p = null,
    f = null,
    m = null,
    g = null,
    v = null,
    y = !1,
    x = null,
    b = null,
    _ = null,
    w = null,
    M = null;
  const S = t.getParameter(35661);
  let T = !1,
    E = 0;
  const A = t.getParameter(7938);
  -1 !== A.indexOf("WebGL")
    ? ((E = parseFloat(/^WebGL\ ([0-9])/.exec(A)[1])), (T = E >= 1))
    : -1 !== A.indexOf("OpenGL ES") &&
      ((E = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(A)[1])), (T = E >= 2));
  let L = null,
    R = {};
  const P = new d(),
    C = new d();
  function O(e, n, i) {
    const r = new Uint8Array(4),
      o = t.createTexture();
    t.bindTexture(e, o),
      t.texParameteri(e, 10241, 9728),
      t.texParameteri(e, 10240, 9728);
    for (let e = 0; e < i; e++)
      t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
    return o;
  }
  const N = {};
  function I(e) {
    !0 !== a[e] && (t.enable(e), (a[e] = !0));
  }
  function D(e) {
    !1 !== a[e] && (t.disable(e), (a[e] = !1));
  }
  (N[3553] = O(3553, 3553, 1)),
    (N[34067] = O(34067, 34069, 6)),
    r.setClear(0, 0, 0, 1),
    o.setClear(1),
    s.setClear(0),
    I(2929),
    o.setFunc(3),
    U(!1),
    G(1),
    I(2884),
    F(0);
  const B = { 100: 32774, 101: 32778, 102: 32779 };
  if (i) (B[103] = 32775), (B[104] = 32776);
  else {
    const t = e.get("EXT_blend_minmax");
    null !== t && ((B[103] = t.MIN_EXT), (B[104] = t.MAX_EXT));
  }
  const z = {
    200: 0,
    201: 1,
    202: 768,
    204: 770,
    210: 776,
    208: 774,
    206: 772,
    203: 769,
    205: 771,
    209: 775,
    207: 773,
  };
  function F(e, n, i, r, o, s, a, c) {
    if (0 !== e) {
      if ((l || (I(3042), (l = !0)), 5 === e))
        (o = o || n),
          (s = s || i),
          (a = a || r),
          (n === u && o === m) ||
            (t.blendEquationSeparate(B[n], B[o]), (u = n), (m = o)),
          (i === p && r === f && s === g && a === v) ||
            (t.blendFuncSeparate(z[i], z[r], z[s], z[a]),
            (p = i),
            (f = r),
            (g = s),
            (v = a)),
          (h = e),
          (y = null);
      else if (e !== h || c !== y) {
        if (
          ((100 === u && 100 === m) ||
            (t.blendEquation(32774), (u = 100), (m = 100)),
          c)
        )
          switch (e) {
            case 1:
              t.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              t.blendFunc(1, 1);
              break;
            case 3:
              t.blendFuncSeparate(0, 0, 769, 771);
              break;
            case 4:
              t.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
          }
        else
          switch (e) {
            case 1:
              t.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              t.blendFunc(770, 1);
              break;
            case 3:
              t.blendFunc(0, 769);
              break;
            case 4:
              t.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
          }
        (p = null), (f = null), (g = null), (v = null), (h = e), (y = c);
      }
    } else l && (D(3042), (l = !1));
  }
  function U(e) {
    x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (x = e));
  }
  function G(e) {
    0 !== e
      ? (I(2884),
        e !== b &&
          (1 === e
            ? t.cullFace(1029)
            : 2 === e
            ? t.cullFace(1028)
            : t.cullFace(1032)))
      : D(2884),
      (b = e);
  }
  function H(e, n, i) {
    e
      ? (I(32823),
        (w === n && M === i) || (t.polygonOffset(n, i), (w = n), (M = i)))
      : D(32823);
  }
  function k(e) {
    void 0 === e && (e = 33984 + S - 1),
      L !== e && (t.activeTexture(e), (L = e));
  }
  return {
    buffers: { color: r, depth: o, stencil: s },
    enable: I,
    disable: D,
    useProgram: function (e) {
      return c !== e && (t.useProgram(e), (c = e), !0);
    },
    setBlending: F,
    setMaterial: function (t, e) {
      2 === t.side ? D(2884) : I(2884);
      let n = 1 === t.side;
      e && (n = !n),
        U(n),
        1 === t.blending && !1 === t.transparent
          ? F(0)
          : F(
              t.blending,
              t.blendEquation,
              t.blendSrc,
              t.blendDst,
              t.blendEquationAlpha,
              t.blendSrcAlpha,
              t.blendDstAlpha,
              t.premultipliedAlpha
            ),
        o.setFunc(t.depthFunc),
        o.setTest(t.depthTest),
        o.setMask(t.depthWrite),
        r.setMask(t.colorWrite);
      const i = t.stencilWrite;
      s.setTest(i),
        i &&
          (s.setMask(t.stencilWriteMask),
          s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
          s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
        H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
    },
    setFlipSided: U,
    setCullFace: G,
    setLineWidth: function (e) {
      e !== _ && (T && t.lineWidth(e), (_ = e));
    },
    setPolygonOffset: H,
    setScissorTest: function (t) {
      t ? I(3089) : D(3089);
    },
    activeTexture: k,
    bindTexture: function (e, n) {
      null === L && k();
      let i = R[L];
      void 0 === i && ((i = { type: void 0, texture: void 0 }), (R[L] = i)),
        (i.type === e && i.texture === n) ||
          (t.bindTexture(e, n || N[e]), (i.type = e), (i.texture = n));
    },
    unbindTexture: function () {
      const e = R[L];
      void 0 !== e &&
        void 0 !== e.type &&
        (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0));
    },
    compressedTexImage2D: function () {
      try {
        t.compressedTexImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage2D: function () {
      try {
        t.texImage2D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage3D: function () {
      try {
        t.texImage3D.apply(t, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    scissor: function (e) {
      !1 === P.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), P.copy(e));
    },
    viewport: function (e) {
      !1 === C.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), C.copy(e));
    },
    reset: function () {
      (a = {}),
        (L = null),
        (R = {}),
        (c = null),
        (h = null),
        (x = null),
        (b = null),
        r.reset(),
        o.reset(),
        s.reset();
    },
  };
}
function Ki(t, e, n, i, r, s, a) {
  const c = r.isWebGL2,
    l = r.maxTextures,
    h = r.maxCubemapSize,
    u = r.maxTextureSize,
    d = r.maxSamples,
    p = new WeakMap();
  let f,
    m = !1;
  try {
    m =
      "undefined" != typeof OffscreenCanvas &&
      null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (t) {}
  function g(t, e) {
    return m
      ? new OffscreenCanvas(t, e)
      : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function v(t, e, n, i) {
    let r = 1;
    if (
      ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
      r < 1 || !0 === e)
    ) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const i = e ? o.floorPowerOfTwo : Math.floor,
          s = i(r * t.width),
          a = i(r * t.height);
        void 0 === f && (f = g(s, a));
        const c = n ? g(s, a) : f;
        (c.width = s), (c.height = a);
        return (
          c.getContext("2d").drawImage(t, 0, 0, s, a),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              t.width +
              "x" +
              t.height +
              ") to (" +
              s +
              "x" +
              a +
              ")."
          ),
          c
        );
      }
      return (
        "data" in t &&
          console.warn(
            "THREE.WebGLRenderer: Image in DataTexture is too big (" +
              t.width +
              "x" +
              t.height +
              ")."
          ),
        t
      );
    }
    return t;
  }
  function y(t) {
    return o.isPowerOfTwo(t.width) && o.isPowerOfTwo(t.height);
  }
  function x(t, e) {
    return (
      t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
    );
  }
  function b(e, n, r, o) {
    t.generateMipmap(e);
    i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E;
  }
  function _(n, i, r) {
    if (!1 === c) return i;
    if (null !== n) {
      if (void 0 !== t[n]) return t[n];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          n +
          "'"
      );
    }
    let o = i;
    return (
      6403 === i &&
        (5126 === r && (o = 33326),
        5131 === r && (o = 33325),
        5121 === r && (o = 33321)),
      6407 === i &&
        (5126 === r && (o = 34837),
        5131 === r && (o = 34843),
        5121 === r && (o = 32849)),
      6408 === i &&
        (5126 === r && (o = 34836),
        5131 === r && (o = 34842),
        5121 === r && (o = 32856)),
      (33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o) ||
        e.get("EXT_color_buffer_float"),
      o
    );
  }
  function w(t) {
    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
  }
  function M(e) {
    const n = e.target;
    n.removeEventListener("dispose", M),
      (function (e) {
        const n = i.get(e);
        if (void 0 === n.__webglInit) return;
        t.deleteTexture(n.__webglTexture), i.remove(e);
      })(n),
      n.isVideoTexture && p.delete(n),
      a.memory.textures--;
  }
  function S(e) {
    const n = e.target;
    n.removeEventListener("dispose", S),
      (function (e) {
        const n = i.get(e),
          r = i.get(e.texture);
        if (!e) return;
        void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
        e.depthTexture && e.depthTexture.dispose();
        if (e.isWebGLCubeRenderTarget)
          for (let e = 0; e < 6; e++)
            t.deleteFramebuffer(n.__webglFramebuffer[e]),
              n.__webglDepthbuffer &&
                t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
        else
          t.deleteFramebuffer(n.__webglFramebuffer),
            n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer),
            n.__webglMultisampledFramebuffer &&
              t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
            n.__webglColorRenderbuffer &&
              t.deleteRenderbuffer(n.__webglColorRenderbuffer),
            n.__webglDepthRenderbuffer &&
              t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
        i.remove(e.texture), i.remove(e);
      })(n),
      a.memory.textures--;
  }
  let T = 0;
  function E(t, e) {
    const r = i.get(t);
    if (
      (t.isVideoTexture &&
        (function (t) {
          const e = a.render.frame;
          p.get(t) !== e && (p.set(t, e), t.update());
        })(t),
      t.version > 0 && r.__version !== t.version)
    ) {
      const n = t.image;
      if (void 0 === n)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is undefined"
        );
      else {
        if (!1 !== n.complete) return void N(r, t, e);
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      }
    }
    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
  }
  function A(e, r) {
    if (6 !== e.image.length) return;
    const o = i.get(e);
    if (e.version > 0 && o.__version !== e.version) {
      O(o, e),
        n.activeTexture(33984 + r),
        n.bindTexture(34067, o.__webglTexture),
        t.pixelStorei(37440, e.flipY);
      const i = e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
        a = e.image[0] && e.image[0].isDataTexture,
        l = [];
      for (let t = 0; t < 6; t++)
        l[t] =
          i || a
            ? a
              ? e.image[t].image
              : e.image[t]
            : v(e.image[t], !1, !0, h);
      const u = l[0],
        d = y(u) || c,
        p = s.convert(e.format),
        f = s.convert(e.type),
        m = _(e.internalFormat, p, f);
      let g;
      if ((C(34067, e, d), i)) {
        for (let t = 0; t < 6; t++) {
          g = l[t].mipmaps;
          for (let i = 0; i < g.length; i++) {
            const r = g[i];
            1023 !== e.format && 1022 !== e.format
              ? null !== p
                ? n.compressedTexImage2D(
                    34069 + t,
                    i,
                    m,
                    r.width,
                    r.height,
                    0,
                    r.data
                  )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : n.texImage2D(
                  34069 + t,
                  i,
                  m,
                  r.width,
                  r.height,
                  0,
                  p,
                  f,
                  r.data
                );
          }
        }
        o.__maxMipLevel = g.length - 1;
      } else {
        g = e.mipmaps;
        for (let t = 0; t < 6; t++)
          if (a) {
            n.texImage2D(
              34069 + t,
              0,
              m,
              l[t].width,
              l[t].height,
              0,
              p,
              f,
              l[t].data
            );
            for (let e = 0; e < g.length; e++) {
              const i = g[e].image[t].image;
              n.texImage2D(
                34069 + t,
                e + 1,
                m,
                i.width,
                i.height,
                0,
                p,
                f,
                i.data
              );
            }
          } else {
            n.texImage2D(34069 + t, 0, m, p, f, l[t]);
            for (let e = 0; e < g.length; e++) {
              const i = g[e];
              n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]);
            }
          }
        o.__maxMipLevel = g.length;
      }
      x(e, d) && b(34067, e, u.width, u.height),
        (o.__version = e.version),
        e.onUpdate && e.onUpdate(e);
    } else n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture);
  }
  function L(t, e) {
    n.activeTexture(33984 + e), n.bindTexture(34067, i.get(t).__webglTexture);
  }
  const R = { 1e3: 10497, 1001: 33071, 1002: 33648 },
    P = {
      1003: 9728,
      1004: 9984,
      1005: 9986,
      1006: 9729,
      1007: 9985,
      1008: 9987,
    };
  function C(n, o, s) {
    s
      ? (t.texParameteri(n, 10242, R[o.wrapS]),
        t.texParameteri(n, 10243, R[o.wrapT]),
        (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, R[o.wrapR]),
        t.texParameteri(n, 10240, P[o.magFilter]),
        t.texParameteri(n, 10241, P[o.minFilter]))
      : (t.texParameteri(n, 10242, 33071),
        t.texParameteri(n, 10243, 33071),
        (32879 !== n && 35866 !== n) || t.texParameteri(n, 32882, 33071),
        (1001 === o.wrapS && 1001 === o.wrapT) ||
          console.warn(
            "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
          ),
        t.texParameteri(n, 10240, w(o.magFilter)),
        t.texParameteri(n, 10241, w(o.minFilter)),
        1003 !== o.minFilter &&
          1006 !== o.minFilter &&
          console.warn(
            "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
          ));
    const a = e.get("EXT_texture_filter_anisotropic");
    if (a) {
      if (1015 === o.type && null === e.get("OES_texture_float_linear")) return;
      if (
        1016 === o.type &&
        null === (c || e.get("OES_texture_half_float_linear"))
      )
        return;
      (o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
        (t.texParameterf(
          n,
          a.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(o.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(o).__currentAnisotropy = o.anisotropy));
    }
  }
  function O(e, n) {
    void 0 === e.__webglInit &&
      ((e.__webglInit = !0),
      n.addEventListener("dispose", M),
      (e.__webglTexture = t.createTexture()),
      a.memory.textures++);
  }
  function N(e, i, r) {
    let o = 3553;
    i.isDataTexture2DArray && (o = 35866),
      i.isDataTexture3D && (o = 32879),
      O(e, i),
      n.activeTexture(33984 + r),
      n.bindTexture(o, e.__webglTexture),
      t.pixelStorei(37440, i.flipY),
      t.pixelStorei(37441, i.premultiplyAlpha),
      t.pixelStorei(3317, i.unpackAlignment);
    const a =
        (function (t) {
          return (
            !c &&
            (1001 !== t.wrapS ||
              1001 !== t.wrapT ||
              (1003 !== t.minFilter && 1006 !== t.minFilter))
          );
        })(i) && !1 === y(i.image),
      l = v(i.image, a, !1, u),
      h = y(l) || c,
      d = s.convert(i.format);
    let p,
      f = s.convert(i.type),
      m = _(i.internalFormat, d, f);
    C(o, i, h);
    const g = i.mipmaps;
    if (i.isDepthTexture)
      (m = 6402),
        c
          ? (m =
              1015 === i.type
                ? 36012
                : 1014 === i.type
                ? 33190
                : 1020 === i.type
                ? 35056
                : 33189)
          : 1015 === i.type &&
            console.error(
              "WebGLRenderer: Floating point depth texture requires WebGL2."
            ),
        1026 === i.format &&
          6402 === m &&
          1012 !== i.type &&
          1014 !== i.type &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
          ),
          (i.type = 1012),
          (f = s.convert(i.type))),
        1027 === i.format &&
          6402 === m &&
          ((m = 34041),
          1020 !== i.type &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
            ),
            (i.type = 1020),
            (f = s.convert(i.type)))),
        n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null);
    else if (i.isDataTexture)
      if (g.length > 0 && h) {
        for (let t = 0, e = g.length; t < e; t++)
          (p = g[t]),
            n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
        (i.generateMipmaps = !1), (e.__maxMipLevel = g.length - 1);
      } else
        n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data),
          (e.__maxMipLevel = 0);
    else if (i.isCompressedTexture) {
      for (let t = 0, e = g.length; t < e; t++)
        (p = g[t]),
          1023 !== i.format && 1022 !== i.format
            ? null !== d
              ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data)
              : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                )
            : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
      e.__maxMipLevel = g.length - 1;
    } else if (i.isDataTexture2DArray)
      n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data),
        (e.__maxMipLevel = 0);
    else if (i.isDataTexture3D)
      n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data),
        (e.__maxMipLevel = 0);
    else if (g.length > 0 && h) {
      for (let t = 0, e = g.length; t < e; t++)
        (p = g[t]), n.texImage2D(3553, t, m, d, f, p);
      (i.generateMipmaps = !1), (e.__maxMipLevel = g.length - 1);
    } else n.texImage2D(3553, 0, m, d, f, l), (e.__maxMipLevel = 0);
    x(i, h) && b(o, i, l.width, l.height),
      (e.__version = i.version),
      i.onUpdate && i.onUpdate(i);
  }
  function I(e, r, o, a) {
    const c = s.convert(r.texture.format),
      l = s.convert(r.texture.type),
      h = _(r.texture.internalFormat, c, l);
    n.texImage2D(a, 0, h, r.width, r.height, 0, c, l, null),
      t.bindFramebuffer(36160, e),
      t.framebufferTexture2D(36160, o, a, i.get(r.texture).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function D(e, n, i) {
    if ((t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)) {
      let r = 33189;
      if (i) {
        const e = n.depthTexture;
        e &&
          e.isDepthTexture &&
          (1015 === e.type ? (r = 36012) : 1014 === e.type && (r = 33190));
        const i = z(n);
        t.renderbufferStorageMultisample(36161, i, r, n.width, n.height);
      } else t.renderbufferStorage(36161, r, n.width, n.height);
      t.framebufferRenderbuffer(36160, 36096, 36161, e);
    } else if (n.depthBuffer && n.stencilBuffer) {
      if (i) {
        const e = z(n);
        t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height);
      } else t.renderbufferStorage(36161, 34041, n.width, n.height);
      t.framebufferRenderbuffer(36160, 33306, 36161, e);
    } else {
      const e = s.convert(n.texture.format),
        r = s.convert(n.texture.type),
        o = _(n.texture.internalFormat, e, r);
      if (i) {
        const e = z(n);
        t.renderbufferStorageMultisample(36161, e, o, n.width, n.height);
      } else t.renderbufferStorage(36161, o, n.width, n.height);
    }
    t.bindRenderbuffer(36161, null);
  }
  function B(e) {
    const n = i.get(e),
      r = !0 === e.isWebGLCubeRenderTarget;
    if (e.depthTexture) {
      if (r)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      !(function (e, n) {
        if (n && n.isWebGLCubeRenderTarget)
          throw new Error(
            "Depth Texture with cube render targets is not supported"
          );
        if (
          (t.bindFramebuffer(36160, e),
          !n.depthTexture || !n.depthTexture.isDepthTexture)
        )
          throw new Error(
            "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
          );
        (i.get(n.depthTexture).__webglTexture &&
          n.depthTexture.image.width === n.width &&
          n.depthTexture.image.height === n.height) ||
          ((n.depthTexture.image.width = n.width),
          (n.depthTexture.image.height = n.height),
          (n.depthTexture.needsUpdate = !0)),
          E(n.depthTexture, 0);
        const r = i.get(n.depthTexture).__webglTexture;
        if (1026 === n.depthTexture.format)
          t.framebufferTexture2D(36160, 36096, 3553, r, 0);
        else {
          if (1027 !== n.depthTexture.format)
            throw new Error("Unknown depthTexture format");
          t.framebufferTexture2D(36160, 33306, 3553, r, 0);
        }
      })(n.__webglFramebuffer, e);
    } else if (r) {
      n.__webglDepthbuffer = [];
      for (let i = 0; i < 6; i++)
        t.bindFramebuffer(36160, n.__webglFramebuffer[i]),
          (n.__webglDepthbuffer[i] = t.createRenderbuffer()),
          D(n.__webglDepthbuffer[i], e, !1);
    } else
      t.bindFramebuffer(36160, n.__webglFramebuffer),
        (n.__webglDepthbuffer = t.createRenderbuffer()),
        D(n.__webglDepthbuffer, e, !1);
    t.bindFramebuffer(36160, null);
  }
  function z(t) {
    return c && t.isWebGLMultisampleRenderTarget ? Math.min(d, t.samples) : 0;
  }
  let F = !1,
    U = !1;
  (this.allocateTextureUnit = function () {
    const t = T;
    return (
      t >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            t +
            " texture units while this GPU supports only " +
            l
        ),
      (T += 1),
      t
    );
  }),
    (this.resetTextureUnits = function () {
      T = 0;
    }),
    (this.setTexture2D = E),
    (this.setTexture2DArray = function (t, e) {
      const r = i.get(t);
      t.version > 0 && r.__version !== t.version
        ? N(r, t, e)
        : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture));
    }),
    (this.setTexture3D = function (t, e) {
      const r = i.get(t);
      t.version > 0 && r.__version !== t.version
        ? N(r, t, e)
        : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture));
    }),
    (this.setTextureCube = A),
    (this.setTextureCubeDynamic = L),
    (this.setupRenderTarget = function (e) {
      const r = i.get(e),
        o = i.get(e.texture);
      e.addEventListener("dispose", S),
        (o.__webglTexture = t.createTexture()),
        a.memory.textures++;
      const l = !0 === e.isWebGLCubeRenderTarget,
        h = !0 === e.isWebGLMultisampleRenderTarget,
        u = y(e) || c;
      if (
        (!c ||
          1022 !== e.texture.format ||
          (1015 !== e.texture.type && 1016 !== e.texture.type) ||
          ((e.texture.format = 1023),
          console.warn(
            "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
          )),
        l)
      ) {
        r.__webglFramebuffer = [];
        for (let e = 0; e < 6; e++)
          r.__webglFramebuffer[e] = t.createFramebuffer();
      } else if (((r.__webglFramebuffer = t.createFramebuffer()), h))
        if (c) {
          (r.__webglMultisampledFramebuffer = t.createFramebuffer()),
            (r.__webglColorRenderbuffer = t.createRenderbuffer()),
            t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
          const n = s.convert(e.texture.format),
            i = s.convert(e.texture.type),
            o = _(e.texture.internalFormat, n, i),
            a = z(e);
          t.renderbufferStorageMultisample(36161, a, o, e.width, e.height),
            t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              36160,
              36064,
              36161,
              r.__webglColorRenderbuffer
            ),
            t.bindRenderbuffer(36161, null),
            e.depthBuffer &&
              ((r.__webglDepthRenderbuffer = t.createRenderbuffer()),
              D(r.__webglDepthRenderbuffer, e, !0)),
            t.bindFramebuffer(36160, null);
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
          );
      if (l) {
        n.bindTexture(34067, o.__webglTexture), C(34067, e.texture, u);
        for (let t = 0; t < 6; t++)
          I(r.__webglFramebuffer[t], e, 36064, 34069 + t);
        x(e.texture, u) && b(34067, e.texture, e.width, e.height),
          n.bindTexture(34067, null);
      } else
        n.bindTexture(3553, o.__webglTexture),
          C(3553, e.texture, u),
          I(r.__webglFramebuffer, e, 36064, 3553),
          x(e.texture, u) && b(3553, e.texture, e.width, e.height),
          n.bindTexture(3553, null);
      e.depthBuffer && B(e);
    }),
    (this.updateRenderTargetMipmap = function (t) {
      const e = t.texture;
      if (x(e, y(t) || c)) {
        const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
          o = i.get(e).__webglTexture;
        n.bindTexture(r, o), b(r, e, t.width, t.height), n.bindTexture(r, null);
      }
    }),
    (this.updateMultisampleRenderTarget = function (e) {
      if (e.isWebGLMultisampleRenderTarget)
        if (c) {
          const n = i.get(e);
          t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
            t.bindFramebuffer(36009, n.__webglFramebuffer);
          const r = e.width,
            o = e.height;
          let s = 16384;
          e.depthBuffer && (s |= 256),
            e.stencilBuffer && (s |= 1024),
            t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728),
            t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer);
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
          );
    }),
    (this.safeSetTexture2D = function (t, e) {
      t &&
        t.isWebGLRenderTarget &&
        (!1 === F &&
          (console.warn(
            "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
          ),
          (F = !0)),
        (t = t.texture)),
        E(t, e);
    }),
    (this.safeSetTextureCube = function (t, e) {
      t &&
        t.isWebGLCubeRenderTarget &&
        (!1 === U &&
          (console.warn(
            "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
          ),
          (U = !0)),
        (t = t.texture)),
        (t && t.isCubeTexture) ||
        (Array.isArray(t.image) && 6 === t.image.length)
          ? A(t, e)
          : L(t, e);
    });
}
function Qi(t, e, n) {
  const i = n.isWebGL2;
  return {
    convert: function (t) {
      let n;
      if (1009 === t) return 5121;
      if (1017 === t) return 32819;
      if (1018 === t) return 32820;
      if (1019 === t) return 33635;
      if (1010 === t) return 5120;
      if (1011 === t) return 5122;
      if (1012 === t) return 5123;
      if (1013 === t) return 5124;
      if (1014 === t) return 5125;
      if (1015 === t) return 5126;
      if (1016 === t)
        return i
          ? 5131
          : ((n = e.get("OES_texture_half_float")),
            null !== n ? n.HALF_FLOAT_OES : null);
      if (1021 === t) return 6406;
      if (1022 === t) return 6407;
      if (1023 === t) return 6408;
      if (1024 === t) return 6409;
      if (1025 === t) return 6410;
      if (1026 === t) return 6402;
      if (1027 === t) return 34041;
      if (1028 === t) return 6403;
      if (1029 === t) return 36244;
      if (1030 === t) return 33319;
      if (1031 === t) return 33320;
      if (1032 === t) return 36248;
      if (1033 === t) return 36249;
      if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
        if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n))
          return null;
        if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      }
      if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
        if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n))
          return null;
        if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (36196 === t)
        return (
          (n = e.get("WEBGL_compressed_texture_etc1")),
          null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
        );
      if (
        (37492 === t || 37496 === t) &&
        ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
      ) {
        if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
        if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC;
      }
      return 37808 === t ||
        37809 === t ||
        37810 === t ||
        37811 === t ||
        37812 === t ||
        37813 === t ||
        37814 === t ||
        37815 === t ||
        37816 === t ||
        37817 === t ||
        37818 === t ||
        37819 === t ||
        37820 === t ||
        37821 === t ||
        37840 === t ||
        37841 === t ||
        37842 === t ||
        37843 === t ||
        37844 === t ||
        37845 === t ||
        37846 === t ||
        37847 === t ||
        37848 === t ||
        37849 === t ||
        37850 === t ||
        37851 === t ||
        37852 === t ||
        37853 === t
        ? ((n = e.get("WEBGL_compressed_texture_astc")), null !== n ? t : null)
        : 36492 === t
        ? ((n = e.get("EXT_texture_compression_bptc")), null !== n ? t : null)
        : 1020 === t
        ? i
          ? 34042
          : ((n = e.get("WEBGL_depth_texture")),
            null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
        : void 0;
    },
  };
}
function $i(t) {
  ke.call(this), (this.cameras = t || []);
}
function tr() {
  mt.call(this), (this.type = "Group");
}
function er() {
  (this._targetRay = null), (this._grip = null), (this._hand = null);
}
function nr(t, e) {
  const n = this;
  let i = null,
    r = 1,
    o = null,
    s = "local-floor",
    a = null;
  const c = [],
    l = new Map(),
    h = new ke();
  h.layers.enable(1), (h.viewport = new d());
  const u = new ke();
  u.layers.enable(2), (u.viewport = new d());
  const p = [h, u],
    f = new $i();
  f.layers.enable(1), f.layers.enable(2);
  let m = null,
    v = null;
  function y(t) {
    const e = l.get(t.inputSource);
    e && e.dispatchEvent({ type: t.type });
  }
  function x() {
    l.forEach(function (t, e) {
      t.disconnect(e);
    }),
      l.clear(),
      t.setFramebuffer(null),
      t.setRenderTarget(t.getRenderTarget()),
      E.stop(),
      (n.isPresenting = !1),
      n.dispatchEvent({ type: "sessionend" });
  }
  function b(t) {
    (o = t),
      E.setContext(i),
      E.start(),
      (n.isPresenting = !0),
      n.dispatchEvent({ type: "sessionstart" });
  }
  function _(t) {
    const e = i.inputSources;
    for (let t = 0; t < c.length; t++) l.set(e[t], c[t]);
    for (let e = 0; e < t.removed.length; e++) {
      const n = t.removed[e],
        i = l.get(n);
      i && (i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n));
    }
    for (let e = 0; e < t.added.length; e++) {
      const n = t.added[e],
        i = l.get(n);
      i && i.dispatchEvent({ type: "connected", data: n });
    }
  }
  (this.enabled = !1),
    (this.isPresenting = !1),
    (this.getController = function (t) {
      let e = c[t];
      return (
        void 0 === e && ((e = new er()), (c[t] = e)), e.getTargetRaySpace()
      );
    }),
    (this.getControllerGrip = function (t) {
      let e = c[t];
      return void 0 === e && ((e = new er()), (c[t] = e)), e.getGripSpace();
    }),
    (this.getHand = function (t) {
      let e = c[t];
      return void 0 === e && ((e = new er()), (c[t] = e)), e.getHandSpace();
    }),
    (this.setFramebufferScaleFactor = function (t) {
      (r = t),
        !0 === n.isPresenting &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
    (this.setReferenceSpaceType = function (t) {
      (s = t),
        !0 === n.isPresenting &&
          console.warn(
            "THREE.WebXRManager: Cannot change reference space type while presenting."
          );
    }),
    (this.getReferenceSpace = function () {
      return o;
    }),
    (this.getSession = function () {
      return i;
    }),
    (this.setSession = function (t) {
      if (((i = t), null !== i)) {
        i.addEventListener("select", y),
          i.addEventListener("selectstart", y),
          i.addEventListener("selectend", y),
          i.addEventListener("squeeze", y),
          i.addEventListener("squeezestart", y),
          i.addEventListener("squeezeend", y),
          i.addEventListener("end", x);
        const t = e.getContextAttributes();
        !0 !== t.xrCompatible && e.makeXRCompatible();
        const n = {
            antialias: t.antialias,
            alpha: t.alpha,
            depth: t.depth,
            stencil: t.stencil,
            framebufferScaleFactor: r,
          },
          o = new XRWebGLLayer(i, e, n);
        i.updateRenderState({ baseLayer: o }),
          i.requestReferenceSpace(s).then(b),
          i.addEventListener("inputsourceschange", _);
      }
    });
  const w = new g(),
    M = new g();
  function S(t, e) {
    null === e
      ? t.matrixWorld.copy(t.matrix)
      : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
      t.matrixWorldInverse.getInverse(t.matrixWorld);
  }
  this.getCamera = function (t) {
    (f.near = u.near = h.near = t.near),
      (f.far = u.far = h.far = t.far),
      (m === f.near && v === f.far) ||
        (i.updateRenderState({ depthNear: f.near, depthFar: f.far }),
        (m = f.near),
        (v = f.far));
    const e = t.parent,
      n = f.cameras;
    S(f, e);
    for (let t = 0; t < n.length; t++) S(n[t], e);
    t.matrixWorld.copy(f.matrixWorld);
    const r = t.children;
    for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
    return (
      2 === n.length
        ? (function (t, e, n) {
            w.setFromMatrixPosition(e.matrixWorld),
              M.setFromMatrixPosition(n.matrixWorld);
            const i = w.distanceTo(M),
              r = e.projectionMatrix.elements,
              o = n.projectionMatrix.elements,
              s = r[14] / (r[10] - 1),
              a = r[14] / (r[10] + 1),
              c = (r[9] + 1) / r[5],
              l = (r[9] - 1) / r[5],
              h = (r[8] - 1) / r[0],
              u = (o[8] + 1) / o[0],
              d = s * h,
              p = s * u,
              f = i / (-h + u),
              m = f * -h;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
              t.translateX(m),
              t.translateZ(f),
              t.matrixWorld.compose(t.position, t.quaternion, t.scale),
              t.matrixWorldInverse.getInverse(t.matrixWorld);
            const g = s + f,
              v = a + f,
              y = d - m,
              x = p + (i - m),
              b = ((c * a) / v) * g,
              _ = ((l * a) / v) * g;
            t.projectionMatrix.makePerspective(y, x, b, _, g, v);
          })(f, h, u)
        : f.projectionMatrix.copy(h.projectionMatrix),
      f
    );
  };
  let T = null;
  const E = new Ze();
  E.setAnimationLoop(function (e, n) {
    if (((a = n.getViewerPose(o)), null !== a)) {
      const e = a.views,
        n = i.renderState.baseLayer;
      t.setFramebuffer(n.framebuffer);
      let r = !1;
      e.length !== f.cameras.length && ((f.cameras.length = 0), (r = !0));
      for (let t = 0; t < e.length; t++) {
        const i = e[t],
          o = n.getViewport(i),
          s = p[t];
        s.matrix.fromArray(i.transform.matrix),
          s.projectionMatrix.fromArray(i.projectionMatrix),
          s.viewport.set(o.x, o.y, o.width, o.height),
          0 === t && f.matrix.copy(s.matrix),
          !0 === r && f.cameras.push(s);
      }
    }
    const r = i.inputSources;
    for (let t = 0; t < c.length; t++) {
      const e = c[t],
        i = r[t];
      e.update(i, n, o);
    }
    T && T(e, n);
  }),
    (this.setAnimationLoop = function (t) {
      T = t;
    }),
    (this.dispose = function () {});
}
function ir(t) {
  function e(e, n) {
    (e.opacity.value = n.opacity),
      n.color && e.diffuse.value.copy(n.color),
      n.emissive &&
        e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
      n.map && (e.map.value = n.map),
      n.alphaMap && (e.alphaMap.value = n.alphaMap),
      n.specularMap && (e.specularMap.value = n.specularMap);
    const i = t.get(n).envMap;
    if (i) {
      (e.envMap.value = i),
        (e.flipEnvMap.value = i.isCubeTexture ? -1 : 1),
        (e.reflectivity.value = n.reflectivity),
        (e.refractionRatio.value = n.refractionRatio);
      const r = t.get(i).__maxMipLevel;
      void 0 !== r && (e.maxMipLevel.value = r);
    }
    let r, o;
    n.lightMap &&
      ((e.lightMap.value = n.lightMap),
      (e.lightMapIntensity.value = n.lightMapIntensity)),
      n.aoMap &&
        ((e.aoMap.value = n.aoMap),
        (e.aoMapIntensity.value = n.aoMapIntensity)),
      n.map
        ? (r = n.map)
        : n.specularMap
        ? (r = n.specularMap)
        : n.displacementMap
        ? (r = n.displacementMap)
        : n.normalMap
        ? (r = n.normalMap)
        : n.bumpMap
        ? (r = n.bumpMap)
        : n.roughnessMap
        ? (r = n.roughnessMap)
        : n.metalnessMap
        ? (r = n.metalnessMap)
        : n.alphaMap
        ? (r = n.alphaMap)
        : n.emissiveMap
        ? (r = n.emissiveMap)
        : n.clearcoatMap
        ? (r = n.clearcoatMap)
        : n.clearcoatNormalMap
        ? (r = n.clearcoatNormalMap)
        : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
      void 0 !== r &&
        (r.isWebGLRenderTarget && (r = r.texture),
        !0 === r.matrixAutoUpdate && r.updateMatrix(),
        e.uvTransform.value.copy(r.matrix)),
      n.aoMap ? (o = n.aoMap) : n.lightMap && (o = n.lightMap),
      void 0 !== o &&
        (o.isWebGLRenderTarget && (o = o.texture),
        !0 === o.matrixAutoUpdate && o.updateMatrix(),
        e.uv2Transform.value.copy(o.matrix));
  }
  function n(e, n) {
    (e.roughness.value = n.roughness),
      (e.metalness.value = n.metalness),
      n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
      n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
      n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
      n.bumpMap &&
        ((e.bumpMap.value = n.bumpMap),
        (e.bumpScale.value = n.bumpScale),
        1 === n.side && (e.bumpScale.value *= -1)),
      n.normalMap &&
        ((e.normalMap.value = n.normalMap),
        e.normalScale.value.copy(n.normalScale),
        1 === n.side && e.normalScale.value.negate()),
      n.displacementMap &&
        ((e.displacementMap.value = n.displacementMap),
        (e.displacementScale.value = n.displacementScale),
        (e.displacementBias.value = n.displacementBias));
    t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
  }
  return {
    refreshFogUniforms: function (t, e) {
      t.fogColor.value.copy(e.color),
        e.isFog
          ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
          : e.isFogExp2 && (t.fogDensity.value = e.density);
    },
    refreshMaterialUniforms: function (t, i, r, o) {
      i.isMeshBasicMaterial
        ? e(t, i)
        : i.isMeshLambertMaterial
        ? (e(t, i),
          (function (t, e) {
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
          })(t, i))
        : i.isMeshToonMaterial
        ? (e(t, i),
          (function (t, e) {
            e.gradientMap && (t.gradientMap.value = e.gradientMap);
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              1 === e.side && (t.bumpScale.value *= -1));
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              1 === e.side && t.normalScale.value.negate());
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
          })(t, i))
        : i.isMeshPhongMaterial
        ? (e(t, i),
          (function (t, e) {
            t.specular.value.copy(e.specular),
              (t.shininess.value = Math.max(e.shininess, 1e-4)),
              e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              1 === e.side && (t.bumpScale.value *= -1));
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              1 === e.side && t.normalScale.value.negate());
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
          })(t, i))
        : i.isMeshStandardMaterial
        ? (e(t, i),
          i.isMeshPhysicalMaterial
            ? (function (t, e) {
                n(t, e),
                  (t.reflectivity.value = e.reflectivity),
                  (t.clearcoat.value = e.clearcoat),
                  (t.clearcoatRoughness.value = e.clearcoatRoughness),
                  e.sheen && t.sheen.value.copy(e.sheen);
                e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                e.clearcoatRoughnessMap &&
                  (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                e.clearcoatNormalMap &&
                  (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                  (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                  1 === e.side && t.clearcoatNormalScale.value.negate());
                (t.transmission.value = e.transmission),
                  e.transmissionMap &&
                    (t.transmissionMap.value = e.transmissionMap);
              })(t, i)
            : n(t, i))
        : i.isMeshMatcapMaterial
        ? (e(t, i),
          (function (t, e) {
            e.matcap && (t.matcap.value = e.matcap);
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              1 === e.side && (t.bumpScale.value *= -1));
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              1 === e.side && t.normalScale.value.negate());
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
          })(t, i))
        : i.isMeshDepthMaterial
        ? (e(t, i),
          (function (t, e) {
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
          })(t, i))
        : i.isMeshDistanceMaterial
        ? (e(t, i),
          (function (t, e) {
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
            t.referencePosition.value.copy(e.referencePosition),
              (t.nearDistance.value = e.nearDistance),
              (t.farDistance.value = e.farDistance);
          })(t, i))
        : i.isMeshNormalMaterial
        ? (e(t, i),
          (function (t, e) {
            e.bumpMap &&
              ((t.bumpMap.value = e.bumpMap),
              (t.bumpScale.value = e.bumpScale),
              1 === e.side && (t.bumpScale.value *= -1));
            e.normalMap &&
              ((t.normalMap.value = e.normalMap),
              t.normalScale.value.copy(e.normalScale),
              1 === e.side && t.normalScale.value.negate());
            e.displacementMap &&
              ((t.displacementMap.value = e.displacementMap),
              (t.displacementScale.value = e.displacementScale),
              (t.displacementBias.value = e.displacementBias));
          })(t, i))
        : i.isLineBasicMaterial
        ? ((function (t, e) {
            t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
          })(t, i),
          i.isLineDashedMaterial &&
            (function (t, e) {
              (t.dashSize.value = e.dashSize),
                (t.totalSize.value = e.dashSize + e.gapSize),
                (t.scale.value = e.scale);
            })(t, i))
        : i.isPointsMaterial
        ? (function (t, e, n, i) {
            t.diffuse.value.copy(e.color),
              (t.opacity.value = e.opacity),
              (t.size.value = e.size * n),
              (t.scale.value = 0.5 * i),
              e.map && (t.map.value = e.map);
            e.alphaMap && (t.alphaMap.value = e.alphaMap);
            let r;
            e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
            void 0 !== r &&
              (!0 === r.matrixAutoUpdate && r.updateMatrix(),
              t.uvTransform.value.copy(r.matrix));
          })(t, i, r, o)
        : i.isSpriteMaterial
        ? (function (t, e) {
            t.diffuse.value.copy(e.color),
              (t.opacity.value = e.opacity),
              (t.rotation.value = e.rotation),
              e.map && (t.map.value = e.map);
            e.alphaMap && (t.alphaMap.value = e.alphaMap);
            let n;
            e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
            void 0 !== n &&
              (!0 === n.matrixAutoUpdate && n.updateMatrix(),
              t.uvTransform.value.copy(n.matrix));
          })(t, i)
        : i.isShadowMaterial
        ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
        : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
    },
  };
}
function rr(t) {
  const e =
      void 0 !== (t = t || {}).canvas
        ? t.canvas
        : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
    n = void 0 !== t.context ? t.context : null,
    i = void 0 !== t.alpha && t.alpha,
    r = void 0 === t.depth || t.depth,
    a = void 0 === t.stencil || t.stencil,
    c = void 0 !== t.antialias && t.antialias,
    l = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
    h = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
    u = void 0 !== t.powerPreference ? t.powerPreference : "default",
    p =
      void 0 !== t.failIfMajorPerformanceCaveat &&
      t.failIfMajorPerformanceCaveat;
  let f = null,
    m = null;
  (this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.gammaFactor = 2),
    (this.outputEncoding = 3e3),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = 0),
    (this.toneMappingExposure = 1),
    (this.maxMorphTargets = 8),
    (this.maxMorphNormals = 4);
  const v = this;
  let y = !1,
    x = null,
    b = 0,
    _ = 0,
    w = null,
    M = null,
    S = -1,
    T = null,
    E = null;
  const A = new d(),
    L = new d();
  let R = null,
    P = e.width,
    C = e.height,
    O = 1,
    N = null,
    I = null;
  const D = new d(0, 0, P, C),
    B = new d(0, 0, P, C);
  let z = !1;
  const F = new Ye();
  let U = !1,
    G = !1;
  const H = new j(),
    k = new g(),
    V = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function W() {
    return null === w ? O : 1;
  }
  let q,
    X,
    Y,
    Z,
    J,
    K,
    Q,
    $,
    tt,
    et,
    nt,
    it,
    rt,
    ot,
    st,
    at,
    ct,
    lt,
    ht,
    ut,
    dt,
    pt = n;
  function ft(t, n) {
    for (let i = 0; i < t.length; i++) {
      const r = t[i],
        o = e.getContext(r, n);
      if (null !== o) return o;
    }
    return null;
  }
  try {
    const t = {
      alpha: i,
      depth: r,
      stencil: a,
      antialias: c,
      premultipliedAlpha: l,
      preserveDrawingBuffer: h,
      powerPreference: u,
      failIfMajorPerformanceCaveat: p,
    };
    if (
      (e.addEventListener("webglcontextlost", yt, !1),
      e.addEventListener("webglcontextrestored", xt, !1),
      null === pt)
    ) {
      const e = ["webgl2", "webgl", "experimental-webgl"];
      if (
        (!0 === v.isWebGL1Renderer && e.shift(), (pt = ft(e, t)), null === pt)
      )
        throw ft(e)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    void 0 === pt.getShaderPrecisionFormat &&
      (pt.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (t) {
    throw (console.error("THREE.WebGLRenderer: " + t.message), t);
  }
  function mt() {
    (q = new ln(pt)),
      (X = new sn(pt, q, t)),
      !1 === X.isWebGL2 &&
        (q.get("WEBGL_depth_texture"),
        q.get("OES_texture_float"),
        q.get("OES_texture_half_float"),
        q.get("OES_texture_half_float_linear"),
        q.get("OES_standard_derivatives"),
        q.get("OES_element_index_uint"),
        q.get("OES_vertex_array_object"),
        q.get("ANGLE_instanced_arrays")),
      q.get("OES_texture_float_linear"),
      (ut = new Qi(pt, q, X)),
      (Y = new Ji(pt, q, X)),
      Y.scissor(L.copy(B).multiplyScalar(O).floor()),
      Y.viewport(A.copy(D).multiplyScalar(O).floor()),
      (Z = new dn(pt)),
      (J = new Bi()),
      (K = new Ki(pt, q, Y, J, X, ut, Z)),
      (Q = new cn(v)),
      ($ = new Je(pt, X)),
      (dt = new rn(pt, q, $, X)),
      (tt = new hn(pt, $, Z, dt)),
      (et = new gn(pt, tt, $, Z)),
      (ct = new mn(pt)),
      (st = new an(J)),
      (nt = new Di(v, Q, q, X, dt, st)),
      (it = new ir(J)),
      (rt = new Gi(J)),
      (ot = new qi()),
      (at = new nn(v, Q, Y, et, l)),
      (lt = new on(pt, q, Z, X)),
      (ht = new un(pt, q, Z, X)),
      (Z.programs = nt.programs),
      (v.capabilities = X),
      (v.extensions = q),
      (v.properties = J),
      (v.renderLists = rt),
      (v.state = Y),
      (v.info = Z);
  }
  mt();
  const gt = new nr(v, pt);
  this.xr = gt;
  const vt = new Zi(v, et, X.maxTextureSize);
  function yt(t) {
    t.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (y = !0);
  }
  function xt() {
    console.log("THREE.WebGLRenderer: Context Restored."), (y = !1), mt();
  }
  function bt(t) {
    const e = t.target;
    e.removeEventListener("dispose", bt),
      (function (t) {
        _t(t), J.remove(t);
      })(e);
  }
  function _t(t) {
    const e = J.get(t).program;
    void 0 !== e && nt.releaseProgram(e);
  }
  (this.shadowMap = vt),
    (this.getContext = function () {
      return pt;
    }),
    (this.getContextAttributes = function () {
      return pt.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const t = q.get("WEBGL_lose_context");
      t && t.loseContext();
    }),
    (this.forceContextRestore = function () {
      const t = q.get("WEBGL_lose_context");
      t && t.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return O;
    }),
    (this.setPixelRatio = function (t) {
      void 0 !== t && ((O = t), this.setSize(P, C, !1));
    }),
    (this.getSize = function (t) {
      return (
        void 0 === t &&
          (console.warn(
            "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
          ),
          (t = new s())),
        t.set(P, C)
      );
    }),
    (this.setSize = function (t, n, i) {
      gt.isPresenting
        ? console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          )
        : ((P = t),
          (C = n),
          (e.width = Math.floor(t * O)),
          (e.height = Math.floor(n * O)),
          !1 !== i && ((e.style.width = t + "px"), (e.style.height = n + "px")),
          this.setViewport(0, 0, t, n));
    }),
    (this.getDrawingBufferSize = function (t) {
      return (
        void 0 === t &&
          (console.warn(
            "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
          ),
          (t = new s())),
        t.set(P * O, C * O).floor()
      );
    }),
    (this.setDrawingBufferSize = function (t, n, i) {
      (P = t),
        (C = n),
        (O = i),
        (e.width = Math.floor(t * i)),
        (e.height = Math.floor(n * i)),
        this.setViewport(0, 0, t, n);
    }),
    (this.getCurrentViewport = function (t) {
      return (
        void 0 === t &&
          (console.warn(
            "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
          ),
          (t = new d())),
        t.copy(A)
      );
    }),
    (this.getViewport = function (t) {
      return t.copy(D);
    }),
    (this.setViewport = function (t, e, n, i) {
      t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, n, i),
        Y.viewport(A.copy(D).multiplyScalar(O).floor());
    }),
    (this.getScissor = function (t) {
      return t.copy(B);
    }),
    (this.setScissor = function (t, e, n, i) {
      t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i),
        Y.scissor(L.copy(B).multiplyScalar(O).floor());
    }),
    (this.getScissorTest = function () {
      return z;
    }),
    (this.setScissorTest = function (t) {
      Y.setScissorTest((z = t));
    }),
    (this.setOpaqueSort = function (t) {
      N = t;
    }),
    (this.setTransparentSort = function (t) {
      I = t;
    }),
    (this.getClearColor = function () {
      return at.getClearColor();
    }),
    (this.setClearColor = function () {
      at.setClearColor.apply(at, arguments);
    }),
    (this.getClearAlpha = function () {
      return at.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      at.setClearAlpha.apply(at, arguments);
    }),
    (this.clear = function (t, e, n) {
      let i = 0;
      (void 0 === t || t) && (i |= 16384),
        (void 0 === e || e) && (i |= 256),
        (void 0 === n || n) && (i |= 1024),
        pt.clear(i);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      e.removeEventListener("webglcontextlost", yt, !1),
        e.removeEventListener("webglcontextrestored", xt, !1),
        rt.dispose(),
        ot.dispose(),
        J.dispose(),
        Q.dispose(),
        et.dispose(),
        dt.dispose(),
        gt.dispose(),
        Mt.stop();
    }),
    (this.renderBufferImmediate = function (t, e) {
      dt.initAttributes();
      const n = J.get(t);
      t.hasPositions && !n.position && (n.position = pt.createBuffer()),
        t.hasNormals && !n.normal && (n.normal = pt.createBuffer()),
        t.hasUvs && !n.uv && (n.uv = pt.createBuffer()),
        t.hasColors && !n.color && (n.color = pt.createBuffer());
      const i = e.getAttributes();
      t.hasPositions &&
        (pt.bindBuffer(34962, n.position),
        pt.bufferData(34962, t.positionArray, 35048),
        dt.enableAttribute(i.position),
        pt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
        t.hasNormals &&
          (pt.bindBuffer(34962, n.normal),
          pt.bufferData(34962, t.normalArray, 35048),
          dt.enableAttribute(i.normal),
          pt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
        t.hasUvs &&
          (pt.bindBuffer(34962, n.uv),
          pt.bufferData(34962, t.uvArray, 35048),
          dt.enableAttribute(i.uv),
          pt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
        t.hasColors &&
          (pt.bindBuffer(34962, n.color),
          pt.bufferData(34962, t.colorArray, 35048),
          dt.enableAttribute(i.color),
          pt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
        dt.disableUnusedAttributes(),
        pt.drawArrays(4, 0, t.count),
        (t.count = 0);
    }),
    (this.renderBufferDirect = function (t, e, n, i, r, o) {
      null === e && (e = V);
      const s = r.isMesh && r.matrixWorld.determinant() < 0,
        a = Lt(t, e, i, r);
      Y.setMaterial(i, s);
      let c = n.index;
      const l = n.attributes.position;
      if (null === c) {
        if (void 0 === l || 0 === l.count) return;
      } else if (0 === c.count) return;
      let h,
        u = 1;
      !0 === i.wireframe && ((c = tt.getWireframeAttribute(n)), (u = 2)),
        (i.morphTargets || i.morphNormals) && ct.update(r, n, i, a),
        dt.setup(r, i, a, n, c);
      let d = lt;
      null !== c && ((h = $.get(c)), (d = ht), d.setIndex(h));
      const p = null !== c ? c.count : l.count,
        f = n.drawRange.start * u,
        m = n.drawRange.count * u,
        g = null !== o ? o.start * u : 0,
        v = null !== o ? o.count * u : 1 / 0,
        y = Math.max(f, g),
        x = Math.min(p, f + m, g + v) - 1,
        b = Math.max(0, x - y + 1);
      if (0 !== b) {
        if (r.isMesh)
          !0 === i.wireframe
            ? (Y.setLineWidth(i.wireframeLinewidth * W()), d.setMode(1))
            : d.setMode(4);
        else if (r.isLine) {
          let t = i.linewidth;
          void 0 === t && (t = 1),
            Y.setLineWidth(t * W()),
            r.isLineSegments
              ? d.setMode(1)
              : r.isLineLoop
              ? d.setMode(2)
              : d.setMode(3);
        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
        if (r.isInstancedMesh) d.renderInstances(y, b, r.count);
        else if (n.isInstancedBufferGeometry) {
          const t = Math.min(n.instanceCount, n._maxInstanceCount);
          d.renderInstances(y, b, t);
        } else d.render(y, b);
      }
    }),
    (this.compile = function (t, e) {
      (m = ot.get(t, e)),
        m.init(),
        t.traverse(function (t) {
          t.isLight && (m.pushLight(t), t.castShadow && m.pushShadow(t));
        }),
        m.setupLights(e);
      const n = new WeakMap();
      t.traverse(function (e) {
        const i = e.material;
        if (i)
          if (Array.isArray(i))
            for (let r = 0; r < i.length; r++) {
              const o = i[r];
              !1 === n.has(o) && (At(o, t, e), n.set(o));
            }
          else !1 === n.has(i) && (At(i, t, e), n.set(i));
      });
    });
  let wt = null;
  const Mt = new Ze();
  function St(t, e, n, i) {
    if (!1 === t.visible) return;
    if (t.layers.test(e.layers))
      if (t.isGroup) n = t.renderOrder;
      else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
      else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
      else if (t.isSprite) {
        if (!t.frustumCulled || F.intersectsSprite(t)) {
          i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
          const e = et.update(t),
            r = t.material;
          r.visible && f.push(t, e, r, n, k.z, null);
        }
      } else if (t.isImmediateRenderObject)
        i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H),
          f.push(t, null, t.material, n, k.z, null);
      else if (
        (t.isMesh || t.isLine || t.isPoints) &&
        (t.isSkinnedMesh &&
          t.skeleton.frame !== Z.render.frame &&
          (t.skeleton.update(), (t.skeleton.frame = Z.render.frame)),
        !t.frustumCulled || F.intersectsObject(t))
      ) {
        i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
        const e = et.update(t),
          r = t.material;
        if (Array.isArray(r)) {
          const i = e.groups;
          for (let o = 0, s = i.length; o < s; o++) {
            const s = i[o],
              a = r[s.materialIndex];
            a && a.visible && f.push(t, e, a, n, k.z, s);
          }
        } else r.visible && f.push(t, e, r, n, k.z, null);
      }
    const r = t.children;
    for (let t = 0, o = r.length; t < o; t++) St(r[t], e, n, i);
  }
  function Tt(t, e, n) {
    const i = !0 === e.isScene ? e.overrideMaterial : null;
    for (let r = 0, o = t.length; r < o; r++) {
      const o = t[r],
        s = o.object,
        a = o.geometry,
        c = null === i ? o.material : i,
        l = o.group;
      if (n.isArrayCamera) {
        E = n;
        const t = n.cameras;
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          s.layers.test(i.layers) &&
            (Y.viewport(A.copy(i.viewport)),
            m.setupLights(i),
            Et(s, e, i, a, c, l));
        }
      } else (E = null), Et(s, e, n, a, c, l);
    }
  }
  function Et(t, e, n, i, r, o) {
    if (
      (t.onBeforeRender(v, e, n, i, r, o),
      (m = ot.get(e, E || n)),
      t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
      t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
      t.isImmediateRenderObject)
    ) {
      const i = Lt(n, e, r, t);
      Y.setMaterial(r),
        dt.reset(),
        (function (t, e) {
          t.render(function (t) {
            v.renderBufferImmediate(t, e);
          });
        })(t, i);
    } else v.renderBufferDirect(n, e, i, r, t, o);
    t.onAfterRender(v, e, n, i, r, o), (m = ot.get(e, E || n));
  }
  function At(t, e, n) {
    !0 !== e.isScene && (e = V);
    const i = J.get(t),
      r = m.state.lights,
      o = m.state.shadowsArray,
      s = r.state.version,
      a = nt.getParameters(t, r.state, o, e, n),
      c = nt.getProgramCacheKey(a);
    let l = i.program,
      h = !0;
    if (void 0 === l) t.addEventListener("dispose", bt);
    else if (l.cacheKey !== c) _t(t);
    else if (i.lightsStateVersion !== s) h = !1;
    else {
      if (void 0 !== a.shaderID) {
        const n = t.isMeshStandardMaterial ? e.environment : null;
        return void (i.envMap = Q.get(t.envMap || n));
      }
      h = !1;
    }
    h &&
      ((a.uniforms = nt.getUniforms(t)),
      t.onBeforeCompile(a, v),
      (l = nt.acquireProgram(a, c)),
      (i.program = l),
      (i.uniforms = a.uniforms),
      (i.outputEncoding = a.outputEncoding));
    const u = i.uniforms;
    ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
      ((i.numClippingPlanes = st.numPlanes),
      (i.numIntersection = st.numIntersection),
      (u.clippingPlanes = st.uniform)),
      (i.environment = t.isMeshStandardMaterial ? e.environment : null),
      (i.fog = e.fog),
      (i.envMap = Q.get(t.envMap || i.environment)),
      (i.needsLights = (function (t) {
        return (
          t.isMeshLambertMaterial ||
          t.isMeshToonMaterial ||
          t.isMeshPhongMaterial ||
          t.isMeshStandardMaterial ||
          t.isShadowMaterial ||
          (t.isShaderMaterial && !0 === t.lights)
        );
      })(t)),
      (i.lightsStateVersion = s),
      i.needsLights &&
        ((u.ambientLightColor.value = r.state.ambient),
        (u.lightProbe.value = r.state.probe),
        (u.directionalLights.value = r.state.directional),
        (u.directionalLightShadows.value = r.state.directionalShadow),
        (u.spotLights.value = r.state.spot),
        (u.spotLightShadows.value = r.state.spotShadow),
        (u.rectAreaLights.value = r.state.rectArea),
        (u.ltc_1.value = r.state.rectAreaLTC1),
        (u.ltc_2.value = r.state.rectAreaLTC2),
        (u.pointLights.value = r.state.point),
        (u.pointLightShadows.value = r.state.pointShadow),
        (u.hemisphereLights.value = r.state.hemi),
        (u.directionalShadowMap.value = r.state.directionalShadowMap),
        (u.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
        (u.spotShadowMap.value = r.state.spotShadowMap),
        (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
        (u.pointShadowMap.value = r.state.pointShadowMap),
        (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
    const d = i.program.getUniforms(),
      p = fi.seqWithValue(d.seq, u);
    i.uniformsList = p;
  }
  function Lt(t, e, n, i) {
    !0 !== e.isScene && (e = V), K.resetTextureUnits();
    const r = e.fog,
      s = n.isMeshStandardMaterial ? e.environment : null,
      a = null === w ? v.outputEncoding : w.texture.encoding,
      c = Q.get(n.envMap || s),
      l = J.get(n),
      h = m.state.lights;
    if (!0 === U && (!0 === G || t !== T)) {
      const e = t === T && n.id === S;
      st.setState(n, t, e);
    }
    n.version === l.__version
      ? (n.fog && l.fog !== r) ||
        l.environment !== s ||
        (l.needsLights && l.lightsStateVersion !== h.state.version)
        ? At(n, e, i)
        : void 0 === l.numClippingPlanes ||
          (l.numClippingPlanes === st.numPlanes &&
            l.numIntersection === st.numIntersection)
        ? (l.outputEncoding !== a || l.envMap !== c) && At(n, e, i)
        : At(n, e, i)
      : (At(n, e, i), (l.__version = n.version));
    let u = !1,
      d = !1,
      p = !1;
    const f = l.program,
      g = f.getUniforms(),
      y = l.uniforms;
    if (
      (Y.useProgram(f.program) && ((u = !0), (d = !0), (p = !0)),
      n.id !== S && ((S = n.id), (d = !0)),
      u || T !== t)
    ) {
      if (
        (g.setValue(pt, "projectionMatrix", t.projectionMatrix),
        X.logarithmicDepthBuffer &&
          g.setValue(pt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
        T !== t && ((T = t), (d = !0), (p = !0)),
        n.isShaderMaterial ||
          n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshStandardMaterial ||
          n.envMap)
      ) {
        const e = g.map.cameraPosition;
        void 0 !== e && e.setValue(pt, k.setFromMatrixPosition(t.matrixWorld));
      }
      (n.isMeshPhongMaterial ||
        n.isMeshToonMaterial ||
        n.isMeshLambertMaterial ||
        n.isMeshBasicMaterial ||
        n.isMeshStandardMaterial ||
        n.isShaderMaterial) &&
        g.setValue(pt, "isOrthographic", !0 === t.isOrthographicCamera),
        (n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshLambertMaterial ||
          n.isMeshBasicMaterial ||
          n.isMeshStandardMaterial ||
          n.isShaderMaterial ||
          n.isShadowMaterial ||
          n.skinning) &&
          g.setValue(pt, "viewMatrix", t.matrixWorldInverse);
    }
    if (n.skinning) {
      g.setOptional(pt, i, "bindMatrix"),
        g.setOptional(pt, i, "bindMatrixInverse");
      const t = i.skeleton;
      if (t) {
        const e = t.bones;
        if (X.floatVertexTextures) {
          if (void 0 === t.boneTexture) {
            let n = Math.sqrt(4 * e.length);
            (n = o.ceilPowerOfTwo(n)), (n = Math.max(n, 4));
            const i = new Float32Array(n * n * 4);
            i.set(t.boneMatrices);
            const r = new We(i, n, n, 1023, 1015);
            (t.boneMatrices = i), (t.boneTexture = r), (t.boneTextureSize = n);
          }
          g.setValue(pt, "boneTexture", t.boneTexture, K),
            g.setValue(pt, "boneTextureSize", t.boneTextureSize);
        } else g.setOptional(pt, t, "boneMatrices");
      }
    }
    var x, b;
    return (
      (d || l.receiveShadow !== i.receiveShadow) &&
        ((l.receiveShadow = i.receiveShadow),
        g.setValue(pt, "receiveShadow", i.receiveShadow)),
      d &&
        (g.setValue(pt, "toneMappingExposure", v.toneMappingExposure),
        l.needsLights &&
          ((b = p),
          ((x = y).ambientLightColor.needsUpdate = b),
          (x.lightProbe.needsUpdate = b),
          (x.directionalLights.needsUpdate = b),
          (x.directionalLightShadows.needsUpdate = b),
          (x.pointLights.needsUpdate = b),
          (x.pointLightShadows.needsUpdate = b),
          (x.spotLights.needsUpdate = b),
          (x.spotLightShadows.needsUpdate = b),
          (x.rectAreaLights.needsUpdate = b),
          (x.hemisphereLights.needsUpdate = b)),
        r && n.fog && it.refreshFogUniforms(y, r),
        it.refreshMaterialUniforms(y, n, O, C),
        fi.upload(pt, l.uniformsList, y, K)),
      n.isShaderMaterial &&
        !0 === n.uniformsNeedUpdate &&
        (fi.upload(pt, l.uniformsList, y, K), (n.uniformsNeedUpdate = !1)),
      n.isSpriteMaterial && g.setValue(pt, "center", i.center),
      g.setValue(pt, "modelViewMatrix", i.modelViewMatrix),
      g.setValue(pt, "normalMatrix", i.normalMatrix),
      g.setValue(pt, "modelMatrix", i.matrixWorld),
      f
    );
  }
  Mt.setAnimationLoop(function (t) {
    gt.isPresenting || (wt && wt(t));
  }),
    "undefined" != typeof window && Mt.setContext(window),
    (this.setAnimationLoop = function (t) {
      (wt = t), gt.setAnimationLoop(t), null === t ? Mt.stop() : Mt.start();
    }),
    (this.render = function (t, e) {
      let n, i;
      if (
        (void 0 !== arguments[2] &&
          (console.warn(
            "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
          ),
          (n = arguments[2])),
        void 0 !== arguments[3] &&
          (console.warn(
            "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
          ),
          (i = arguments[3])),
        void 0 !== e && !0 !== e.isCamera)
      )
        return void console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
      if (!0 === y) return;
      dt.resetDefaultState(),
        (S = -1),
        (T = null),
        !0 === t.autoUpdate && t.updateMatrixWorld(),
        null === e.parent && e.updateMatrixWorld(),
        !0 === gt.enabled && !0 === gt.isPresenting && (e = gt.getCamera(e)),
        !0 === t.isScene && t.onBeforeRender(v, t, e, n || w),
        (m = ot.get(t, e)),
        m.init(),
        H.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        F.setFromProjectionMatrix(H),
        (G = this.localClippingEnabled),
        (U = st.init(this.clippingPlanes, G, e)),
        (f = rt.get(t, e)),
        f.init(),
        St(t, e, 0, v.sortObjects),
        f.finish(),
        !0 === v.sortObjects && f.sort(N, I),
        !0 === U && st.beginShadows();
      const r = m.state.shadowsArray;
      vt.render(r, t, e),
        m.setupLights(e),
        !0 === U && st.endShadows(),
        !0 === this.info.autoReset && this.info.reset(),
        void 0 !== n && this.setRenderTarget(n),
        at.render(f, t, e, i);
      const o = f.opaque,
        s = f.transparent;
      o.length > 0 && Tt(o, t, e),
        s.length > 0 && Tt(s, t, e),
        !0 === t.isScene && t.onAfterRender(v, t, e),
        null !== w &&
          (K.updateRenderTargetMipmap(w), K.updateMultisampleRenderTarget(w)),
        Y.buffers.depth.setTest(!0),
        Y.buffers.depth.setMask(!0),
        Y.buffers.color.setMask(!0),
        Y.setPolygonOffset(!1),
        (f = null),
        (m = null);
    }),
    (this.setFramebuffer = function (t) {
      x !== t && null === w && pt.bindFramebuffer(36160, t), (x = t);
    }),
    (this.getActiveCubeFace = function () {
      return b;
    }),
    (this.getActiveMipmapLevel = function () {
      return _;
    }),
    (this.getRenderList = function () {
      return f;
    }),
    (this.setRenderList = function (t) {
      f = t;
    }),
    (this.getRenderState = function () {
      return m;
    }),
    (this.setRenderState = function (t) {
      m = t;
    }),
    (this.getRenderTarget = function () {
      return w;
    }),
    (this.setRenderTarget = function (t, e = 0, n = 0) {
      (w = t),
        (b = e),
        (_ = n),
        t && void 0 === J.get(t).__webglFramebuffer && K.setupRenderTarget(t);
      let i = x,
        r = !1;
      if (t) {
        const n = J.get(t).__webglFramebuffer;
        t.isWebGLCubeRenderTarget
          ? ((i = n[e]), (r = !0))
          : (i = t.isWebGLMultisampleRenderTarget
              ? J.get(t).__webglMultisampledFramebuffer
              : n),
          A.copy(t.viewport),
          L.copy(t.scissor),
          (R = t.scissorTest);
      } else
        A.copy(D).multiplyScalar(O).floor(),
          L.copy(B).multiplyScalar(O).floor(),
          (R = z);
      if (
        (M !== i && (pt.bindFramebuffer(36160, i), (M = i)),
        Y.viewport(A),
        Y.scissor(L),
        Y.setScissorTest(R),
        r)
      ) {
        const i = J.get(t.texture);
        pt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n);
      }
    }),
    (this.readRenderTargetPixels = function (t, e, n, i, r, o, s) {
      if (!t || !t.isWebGLRenderTarget)
        return void console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
      let a = J.get(t).__webglFramebuffer;
      if ((t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a)) {
        let s = !1;
        a !== M && (pt.bindFramebuffer(36160, a), (s = !0));
        try {
          const a = t.texture,
            c = a.format,
            l = a.type;
          if (1023 !== c && ut.convert(c) !== pt.getParameter(35739))
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
          if (
            !(
              1009 === l ||
              ut.convert(l) === pt.getParameter(35738) ||
              (1015 === l &&
                (X.isWebGL2 ||
                  q.get("OES_texture_float") ||
                  q.get("WEBGL_color_buffer_float"))) ||
              (1016 === l &&
                (X.isWebGL2
                  ? q.get("EXT_color_buffer_float")
                  : q.get("EXT_color_buffer_half_float")))
            )
          )
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
          36053 === pt.checkFramebufferStatus(36160)
            ? e >= 0 &&
              e <= t.width - i &&
              n >= 0 &&
              n <= t.height - r &&
              pt.readPixels(e, n, i, r, ut.convert(c), ut.convert(l), o)
            : console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
              );
        } finally {
          s && pt.bindFramebuffer(36160, M);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (t, e, n) {
      void 0 === n && (n = 0);
      const i = Math.pow(2, -n),
        r = Math.floor(e.image.width * i),
        o = Math.floor(e.image.height * i),
        s = ut.convert(e.format);
      K.setTexture2D(e, 0),
        pt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0),
        Y.unbindTexture();
    }),
    (this.copyTextureToTexture = function (t, e, n, i) {
      void 0 === i && (i = 0);
      const r = e.image.width,
        o = e.image.height,
        s = ut.convert(n.format),
        a = ut.convert(n.type);
      K.setTexture2D(n, 0),
        pt.pixelStorei(37440, n.flipY),
        pt.pixelStorei(37441, n.premultiplyAlpha),
        pt.pixelStorei(3317, n.unpackAlignment),
        e.isDataTexture
          ? pt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data)
          : e.isCompressedTexture
          ? pt.compressedTexSubImage2D(
              3553,
              i,
              t.x,
              t.y,
              e.mipmaps[0].width,
              e.mipmaps[0].height,
              s,
              e.mipmaps[0].data
            )
          : pt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image),
        0 === i && n.generateMipmaps && pt.generateMipmap(3553),
        Y.unbindTexture();
    }),
    (this.initTexture = function (t) {
      K.setTexture2D(t, 0), Y.unbindTexture();
    }),
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
function or(t) {
  rr.call(this, t);
}
($i.prototype = Object.assign(Object.create(ke.prototype), {
  constructor: $i,
  isArrayCamera: !0,
})),
  (tr.prototype = Object.assign(Object.create(mt.prototype), {
    constructor: tr,
    isGroup: !0,
  })),
  Object.assign(er.prototype, {
    constructor: er,
    getHandSpace: function () {
      if (
        null === this._hand &&
        ((this._hand = new tr()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = []),
        (this._hand.inputState = { pinching: !1 }),
        window.XRHand)
      )
        for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
          const t = new tr();
          (t.matrixAutoUpdate = !1),
            (t.visible = !1),
            this._hand.joints.push(t),
            this._hand.add(t);
        }
      return this._hand;
    },
    getTargetRaySpace: function () {
      return (
        null === this._targetRay &&
          ((this._targetRay = new tr()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1)),
        this._targetRay
      );
    },
    getGripSpace: function () {
      return (
        null === this._grip &&
          ((this._grip = new tr()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1)),
        this._grip
      );
    },
    dispatchEvent: function (t) {
      return (
        null !== this._targetRay && this._targetRay.dispatchEvent(t),
        null !== this._grip && this._grip.dispatchEvent(t),
        null !== this._hand && this._hand.dispatchEvent(t),
        this
      );
    },
    disconnect: function (t) {
      return (
        this.dispatchEvent({ type: "disconnected", data: t }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
      );
    },
    update: function (t, e, n) {
      let i = null,
        r = null,
        o = null;
      const s = this._targetRay,
        a = this._grip,
        c = this._hand;
      if (t)
        if (c && t.hand) {
          o = !0;
          for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)
            if (t.hand[i]) {
              const r = e.getJointPose(t.hand[i], n),
                o = c.joints[i];
              null !== r &&
                (o.matrix.fromArray(r.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                (o.jointRadius = r.radius)),
                (o.visible = null !== r);
              const s = c.joints[window.XRHand.INDEX_PHALANX_TIP],
                a = c.joints[window.XRHand.THUMB_PHALANX_TIP],
                l = s.position.distanceTo(a.position),
                h = 0.02,
                u = 0.005;
              c.inputState.pinching && l > h + u
                ? ((c.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this,
                  }))
                : !c.inputState.pinching &&
                  l <= h - u &&
                  ((c.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this,
                  }));
            }
        } else
          null !== s &&
            ((i = e.getPose(t.targetRaySpace, n)),
            null !== i &&
              (s.matrix.fromArray(i.transform.matrix),
              s.matrix.decompose(s.position, s.rotation, s.scale))),
            null !== a &&
              t.gripSpace &&
              ((r = e.getPose(t.gripSpace, n)),
              null !== r &&
                (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale)));
      return (
        null !== s && (s.visible = null !== i),
        null !== a && (a.visible = null !== r),
        null !== c && (c.visible = null !== o),
        this
      );
    },
  }),
  Object.assign(nr.prototype, n.prototype),
  (or.prototype = Object.assign(Object.create(rr.prototype), {
    constructor: or,
    isWebGL1Renderer: !0,
  }));
class sr {
  constructor(t, e) {
    Object.defineProperty(this, "isFogExp2", { value: !0 }),
      (this.name = ""),
      (this.color = new zt(t)),
      (this.density = void 0 !== e ? e : 25e-5);
  }
  clone() {
    return new sr(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class ar {
  constructor(t, e, n) {
    Object.defineProperty(this, "isFog", { value: !0 }),
      (this.name = ""),
      (this.color = new zt(t)),
      (this.near = void 0 !== e ? e : 1),
      (this.far = void 0 !== n ? n : 1e3);
  }
  clone() {
    return new ar(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class cr extends mt {
  constructor() {
    super(),
      Object.defineProperty(this, "isScene", { value: !0 }),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      null !== t.background && (this.background = t.background.clone()),
      null !== t.environment && (this.environment = t.environment.clone()),
      null !== t.fog && (this.fog = t.fog.clone()),
      null !== t.overrideMaterial &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.autoUpdate = t.autoUpdate),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      null !== this.background &&
        (e.object.background = this.background.toJSON(t)),
      null !== this.environment &&
        (e.object.environment = this.environment.toJSON(t)),
      null !== this.fog && (e.object.fog = this.fog.toJSON()),
      e
    );
  }
}
function lr(t, e) {
  (this.array = t),
    (this.stride = e),
    (this.count = void 0 !== t ? t.length / e : 0),
    (this.usage = 35044),
    (this.updateRange = { offset: 0, count: -1 }),
    (this.version = 0),
    (this.uuid = o.generateUUID());
}
Object.defineProperty(lr.prototype, "needsUpdate", {
  set: function (t) {
    !0 === t && this.version++;
  },
}),
  Object.assign(lr.prototype, {
    isInterleavedBuffer: !0,
    onUploadCallback: function () {},
    setUsage: function (t) {
      return (this.usage = t), this;
    },
    copy: function (t) {
      return (
        (this.array = new t.array.constructor(t.array)),
        (this.count = t.count),
        (this.stride = t.stride),
        (this.usage = t.usage),
        this
      );
    },
    copyAt: function (t, e, n) {
      (t *= this.stride), (n *= e.stride);
      for (let i = 0, r = this.stride; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    },
    set: function (t, e) {
      return void 0 === e && (e = 0), this.array.set(t, e), this;
    },
    clone: function (t) {
      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid &&
          (this.array.buffer._uuid = o.generateUUID()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      const e = new lr(
        new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
        this.stride
      );
      return e.setUsage(this.usage), e;
    },
    onUpload: function (t) {
      return (this.onUploadCallback = t), this;
    },
    toJSON: function (t) {
      return (
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid &&
          (this.array.buffer._uuid = o.generateUUID()),
        void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
          (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    },
  });
const hr = new g();
function ur(t, e, n, i) {
  (this.name = ""),
    (this.data = t),
    (this.itemSize = e),
    (this.offset = n),
    (this.normalized = !0 === i);
}
function dr(t) {
  Gt.call(this),
    (this.type = "SpriteMaterial"),
    (this.color = new zt(16777215)),
    (this.map = null),
    (this.alphaMap = null),
    (this.rotation = 0),
    (this.sizeAttenuation = !0),
    (this.transparent = !0),
    this.setValues(t);
}
let pr;
Object.defineProperties(ur.prototype, {
  count: {
    get: function () {
      return this.data.count;
    },
  },
  array: {
    get: function () {
      return this.data.array;
    },
  },
  needsUpdate: {
    set: function (t) {
      this.data.needsUpdate = t;
    },
  },
}),
  Object.assign(ur.prototype, {
    isInterleavedBufferAttribute: !0,
    applyMatrix4: function (t) {
      for (let e = 0, n = this.data.count; e < n; e++)
        (hr.x = this.getX(e)),
          (hr.y = this.getY(e)),
          (hr.z = this.getZ(e)),
          hr.applyMatrix4(t),
          this.setXYZ(e, hr.x, hr.y, hr.z);
      return this;
    },
    setX: function (t, e) {
      return (this.data.array[t * this.data.stride + this.offset] = e), this;
    },
    setY: function (t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 1] = e), this
      );
    },
    setZ: function (t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 2] = e), this
      );
    },
    setW: function (t, e) {
      return (
        (this.data.array[t * this.data.stride + this.offset + 3] = e), this
      );
    },
    getX: function (t) {
      return this.data.array[t * this.data.stride + this.offset];
    },
    getY: function (t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    },
    getZ: function (t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    },
    getW: function (t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    },
    setXY: function (t, e, n) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        this
      );
    },
    setXYZ: function (t, e, n, i) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        this
      );
    },
    setXYZW: function (t, e, n, i, r) {
      return (
        (t = t * this.data.stride + this.offset),
        (this.data.array[t + 0] = e),
        (this.data.array[t + 1] = n),
        (this.data.array[t + 2] = i),
        (this.data.array[t + 3] = r),
        this
      );
    },
    clone: function (t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return new jt(
          new this.array.constructor(t),
          this.itemSize,
          this.normalized
        );
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new ur(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
    },
    toJSON: function (t) {
      if (void 0 === t) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
        );
        const t = [];
        for (let e = 0; e < this.count; e++) {
          const n = e * this.data.stride + this.offset;
          for (let e = 0; e < this.itemSize; e++)
            t.push(this.data.array[n + e]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: t,
          normalized: this.normalized,
        };
      }
      return (
        void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
        void 0 === t.interleavedBuffers[this.data.uuid] &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    },
  }),
  (dr.prototype = Object.create(Gt.prototype)),
  (dr.prototype.constructor = dr),
  (dr.prototype.isSpriteMaterial = !0),
  (dr.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.rotation = t.rotation),
      (this.sizeAttenuation = t.sizeAttenuation),
      this
    );
  });
const fr = new g(),
  mr = new g(),
  gr = new g(),
  vr = new s(),
  yr = new s(),
  xr = new j(),
  br = new g(),
  _r = new g(),
  wr = new g(),
  Mr = new s(),
  Sr = new s(),
  Tr = new s();
function Er(t) {
  if ((mt.call(this), (this.type = "Sprite"), void 0 === pr)) {
    pr = new le();
    const t = new lr(
      new Float32Array([
        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
        0, 0, 1,
      ]),
      5
    );
    pr.setIndex([0, 1, 2, 0, 2, 3]),
      pr.setAttribute("position", new ur(t, 3, 0, !1)),
      pr.setAttribute("uv", new ur(t, 2, 3, !1));
  }
  (this.geometry = pr),
    (this.material = void 0 !== t ? t : new dr()),
    (this.center = new s(0.5, 0.5));
}
function Ar(t, e, n, i, r, o) {
  vr.subVectors(t, n).addScalar(0.5).multiply(i),
    void 0 !== r
      ? ((yr.x = o * vr.x - r * vr.y), (yr.y = r * vr.x + o * vr.y))
      : yr.copy(vr),
    t.copy(e),
    (t.x += yr.x),
    (t.y += yr.y),
    t.applyMatrix4(xr);
}
Er.prototype = Object.assign(Object.create(mt.prototype), {
  constructor: Er,
  isSprite: !0,
  raycast: function (t, e) {
    null === t.camera &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      mr.setFromMatrixScale(this.matrixWorld),
      xr.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        t.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      gr.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        !1 === this.material.sizeAttenuation &&
        mr.multiplyScalar(-gr.z);
    const n = this.material.rotation;
    let i, r;
    0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
    const o = this.center;
    Ar(br.set(-0.5, -0.5, 0), gr, o, mr, i, r),
      Ar(_r.set(0.5, -0.5, 0), gr, o, mr, i, r),
      Ar(wr.set(0.5, 0.5, 0), gr, o, mr, i, r),
      Mr.set(0, 0),
      Sr.set(1, 0),
      Tr.set(1, 1);
    let a = t.ray.intersectTriangle(br, _r, wr, !1, fr);
    if (
      null === a &&
      (Ar(_r.set(-0.5, 0.5, 0), gr, o, mr, i, r),
      Sr.set(0, 1),
      (a = t.ray.intersectTriangle(br, wr, _r, !1, fr)),
      null === a)
    )
      return;
    const c = t.ray.origin.distanceTo(fr);
    c < t.near ||
      c > t.far ||
      e.push({
        distance: c,
        point: fr.clone(),
        uv: Pt.getUV(fr, br, _r, wr, Mr, Sr, Tr, new s()),
        face: null,
        object: this,
      });
  },
  copy: function (t) {
    return (
      mt.prototype.copy.call(this, t),
      void 0 !== t.center && this.center.copy(t.center),
      (this.material = t.material),
      this
    );
  },
});
const Lr = new g(),
  Rr = new g();
function Pr() {
  mt.call(this),
    (this._currentLevel = 0),
    (this.type = "LOD"),
    Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
    (this.autoUpdate = !0);
}
function Cr(t, e) {
  t &&
    t.isGeometry &&
    console.error(
      "THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
    ),
    Ae.call(this, t, e),
    (this.type = "SkinnedMesh"),
    (this.bindMode = "attached"),
    (this.bindMatrix = new j()),
    (this.bindMatrixInverse = new j());
}
(Pr.prototype = Object.assign(Object.create(mt.prototype), {
  constructor: Pr,
  isLOD: !0,
  copy: function (t) {
    mt.prototype.copy.call(this, t, !1);
    const e = t.levels;
    for (let t = 0, n = e.length; t < n; t++) {
      const n = e[t];
      this.addLevel(n.object.clone(), n.distance);
    }
    return (this.autoUpdate = t.autoUpdate), this;
  },
  addLevel: function (t, e) {
    void 0 === e && (e = 0), (e = Math.abs(e));
    const n = this.levels;
    let i;
    for (i = 0; i < n.length && !(e < n[i].distance); i++);
    return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
  },
  getCurrentLevel: function () {
    return this._currentLevel;
  },
  getObjectForDistance: function (t) {
    const e = this.levels;
    if (e.length > 0) {
      let n, i;
      for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
      return e[n - 1].object;
    }
    return null;
  },
  raycast: function (t, e) {
    if (this.levels.length > 0) {
      Lr.setFromMatrixPosition(this.matrixWorld);
      const n = t.ray.origin.distanceTo(Lr);
      this.getObjectForDistance(n).raycast(t, e);
    }
  },
  update: function (t) {
    const e = this.levels;
    if (e.length > 1) {
      Lr.setFromMatrixPosition(t.matrixWorld),
        Rr.setFromMatrixPosition(this.matrixWorld);
      const n = Lr.distanceTo(Rr) / t.zoom;
      let i, r;
      for (
        e[0].object.visible = !0, i = 1, r = e.length;
        i < r && n >= e[i].distance;
        i++
      )
        (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
      for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
    }
  },
  toJSON: function (t) {
    const e = mt.prototype.toJSON.call(this, t);
    !1 === this.autoUpdate && (e.object.autoUpdate = !1),
      (e.object.levels = []);
    const n = this.levels;
    for (let t = 0, i = n.length; t < i; t++) {
      const i = n[t];
      e.object.levels.push({ object: i.object.uuid, distance: i.distance });
    }
    return e;
  },
})),
  (Cr.prototype = Object.assign(Object.create(Ae.prototype), {
    constructor: Cr,
    isSkinnedMesh: !0,
    copy: function (t) {
      return (
        Ae.prototype.copy.call(this, t),
        (this.bindMode = t.bindMode),
        this.bindMatrix.copy(t.bindMatrix),
        this.bindMatrixInverse.copy(t.bindMatrixInverse),
        (this.skeleton = t.skeleton),
        this
      );
    },
    bind: function (t, e) {
      (this.skeleton = t),
        void 0 === e &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (e = this.matrixWorld)),
        this.bindMatrix.copy(e),
        this.bindMatrixInverse.getInverse(e);
    },
    pose: function () {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function () {
      const t = new d(),
        e = this.geometry.attributes.skinWeight;
      for (let n = 0, i = e.count; n < i; n++) {
        (t.x = e.getX(n)),
          (t.y = e.getY(n)),
          (t.z = e.getZ(n)),
          (t.w = e.getW(n));
        const i = 1 / t.manhattanLength();
        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
          e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    },
    updateMatrixWorld: function (t) {
      Ae.prototype.updateMatrixWorld.call(this, t),
        "attached" === this.bindMode
          ? this.bindMatrixInverse.getInverse(this.matrixWorld)
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.getInverse(this.bindMatrix)
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            );
    },
    boneTransform: (function () {
      const t = new g(),
        e = new d(),
        n = new d(),
        i = new g(),
        r = new j();
      return function (o, s) {
        const a = this.skeleton,
          c = this.geometry;
        e.fromBufferAttribute(c.attributes.skinIndex, o),
          n.fromBufferAttribute(c.attributes.skinWeight, o),
          t
            .fromBufferAttribute(c.attributes.position, o)
            .applyMatrix4(this.bindMatrix),
          s.set(0, 0, 0);
        for (let o = 0; o < 4; o++) {
          const c = n.getComponent(o);
          if (0 !== c) {
            const n = e.getComponent(o);
            r.multiplyMatrices(a.bones[n].matrixWorld, a.boneInverses[n]),
              s.addScaledVector(i.copy(t).applyMatrix4(r), c);
          }
        }
        return s.applyMatrix4(this.bindMatrixInverse);
      };
    })(),
  }));
const Or = new j(),
  Nr = new j();
function Ir(t, e) {
  if (
    ((t = t || []),
    (this.bones = t.slice(0)),
    (this.boneMatrices = new Float32Array(16 * this.bones.length)),
    (this.frame = -1),
    void 0 === e)
  )
    this.calculateInverses();
  else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
  else {
    console.warn("THREE.Skeleton boneInverses is the wrong length."),
      (this.boneInverses = []);
    for (let t = 0, e = this.bones.length; t < e; t++)
      this.boneInverses.push(new j());
  }
}
function Dr() {
  mt.call(this), (this.type = "Bone");
}
Object.assign(Ir.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = new j();
      this.bones[t] && e.getInverse(this.bones[t].matrixWorld),
        this.boneInverses.push(e);
    }
  },
  pose: function () {
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t];
      e && e.matrixWorld.getInverse(this.boneInverses[t]);
    }
    for (let t = 0, e = this.bones.length; t < e; t++) {
      const e = this.bones[t];
      e &&
        (e.parent && e.parent.isBone
          ? (e.matrix.getInverse(e.parent.matrixWorld),
            e.matrix.multiply(e.matrixWorld))
          : e.matrix.copy(e.matrixWorld),
        e.matrix.decompose(e.position, e.quaternion, e.scale));
    }
  },
  update: function () {
    const t = this.bones,
      e = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let i = 0, r = t.length; i < r; i++) {
      const r = t[i] ? t[i].matrixWorld : Nr;
      Or.multiplyMatrices(r, e[i]), Or.toArray(n, 16 * i);
    }
    void 0 !== i && (i.needsUpdate = !0);
  },
  clone: function () {
    return new Ir(this.bones, this.boneInverses);
  },
  getBoneByName: function (t) {
    for (let e = 0, n = this.bones.length; e < n; e++) {
      const n = this.bones[e];
      if (n.name === t) return n;
    }
  },
  dispose: function () {
    this.boneTexture &&
      (this.boneTexture.dispose(), (this.boneTexture = void 0));
  },
}),
  (Dr.prototype = Object.assign(Object.create(mt.prototype), {
    constructor: Dr,
    isBone: !0,
  }));
const Br = new j(),
  zr = new j(),
  Fr = [],
  Ur = new Ae();
function Gr(t, e, n) {
  Ae.call(this, t, e),
    (this.instanceMatrix = new jt(new Float32Array(16 * n), 16)),
    (this.instanceColor = null),
    (this.count = n),
    (this.frustumCulled = !1);
}
function Hr(t) {
  Gt.call(this),
    (this.type = "LineBasicMaterial"),
    (this.color = new zt(16777215)),
    (this.linewidth = 1),
    (this.linecap = "round"),
    (this.linejoin = "round"),
    (this.morphTargets = !1),
    this.setValues(t);
}
(Gr.prototype = Object.assign(Object.create(Ae.prototype), {
  constructor: Gr,
  isInstancedMesh: !0,
  copy: function (t) {
    return (
      Ae.prototype.copy.call(this, t),
      this.instanceMatrix.copy(t.instanceMatrix),
      (this.count = t.count),
      this
    );
  },
  setColorAt: function (t, e) {
    null === this.instanceColor &&
      (this.instanceColor = new jt(new Float32Array(3 * this.count), 3)),
      e.toArray(this.instanceColor.array, 3 * t);
  },
  getMatrixAt: function (t, e) {
    e.fromArray(this.instanceMatrix.array, 16 * t);
  },
  raycast: function (t, e) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((Ur.geometry = this.geometry),
      (Ur.material = this.material),
      void 0 !== Ur.material)
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Br),
          zr.multiplyMatrices(n, Br),
          (Ur.matrixWorld = zr),
          Ur.raycast(t, Fr);
        for (let t = 0, n = Fr.length; t < n; t++) {
          const n = Fr[t];
          (n.instanceId = r), (n.object = this), e.push(n);
        }
        Fr.length = 0;
      }
  },
  setMatrixAt: function (t, e) {
    e.toArray(this.instanceMatrix.array, 16 * t);
  },
  updateMorphTargets: function () {},
})),
  (Hr.prototype = Object.create(Gt.prototype)),
  (Hr.prototype.constructor = Hr),
  (Hr.prototype.isLineBasicMaterial = !0),
  (Hr.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      (this.morphTargets = t.morphTargets),
      this
    );
  });
const kr = new g(),
  Vr = new g(),
  jr = new j(),
  Wr = new V(),
  qr = new D();
function Xr(t, e, n) {
  1 === n &&
    console.error(
      "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."
    ),
    mt.call(this),
    (this.type = "Line"),
    (this.geometry = void 0 !== t ? t : new le()),
    (this.material = void 0 !== e ? e : new Hr()),
    this.updateMorphTargets();
}
Xr.prototype = Object.assign(Object.create(mt.prototype), {
  constructor: Xr,
  isLine: !0,
  copy: function (t) {
    return (
      mt.prototype.copy.call(this, t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  },
  computeLineDistances: function () {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (null === t.index) {
        const e = t.attributes.position,
          n = [0];
        for (let t = 1, i = e.count; t < i; t++)
          kr.fromBufferAttribute(e, t - 1),
            Vr.fromBufferAttribute(e, t),
            (n[t] = n[t - 1]),
            (n[t] += kr.distanceTo(Vr));
        t.setAttribute("lineDistance", new Qt(n, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else if (t.isGeometry) {
      const e = t.vertices,
        n = t.lineDistances;
      n[0] = 0;
      for (let t = 1, i = e.length; t < i; t++)
        (n[t] = n[t - 1]), (n[t] += e[t - 1].distanceTo(e[t]));
    }
    return this;
  },
  raycast: function (t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = t.params.Line.threshold;
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      qr.copy(n.boundingSphere),
      qr.applyMatrix4(i),
      (qr.radius += r),
      !1 === t.ray.intersectsSphere(qr))
    )
      return;
    jr.getInverse(i), Wr.copy(t.ray).applyMatrix4(jr);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      s = o * o,
      a = new g(),
      c = new g(),
      l = new g(),
      h = new g(),
      u = this && this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const i = n.index,
        r = n.attributes.position.array;
      if (null !== i) {
        const n = i.array;
        for (let i = 0, o = n.length - 1; i < o; i += u) {
          const o = n[i],
            u = n[i + 1];
          a.fromArray(r, 3 * o), c.fromArray(r, 3 * u);
          if (Wr.distanceSqToSegment(a, c, h, l) > s) continue;
          h.applyMatrix4(this.matrixWorld);
          const d = t.ray.origin.distanceTo(h);
          d < t.near ||
            d > t.far ||
            e.push({
              distance: d,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else
        for (let n = 0, i = r.length / 3 - 1; n < i; n += u) {
          a.fromArray(r, 3 * n), c.fromArray(r, 3 * n + 3);
          if (Wr.distanceSqToSegment(a, c, h, l) > s) continue;
          h.applyMatrix4(this.matrixWorld);
          const i = t.ray.origin.distanceTo(h);
          i < t.near ||
            i > t.far ||
            e.push({
              distance: i,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: n,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
    } else if (n.isGeometry) {
      const i = n.vertices,
        r = i.length;
      for (let n = 0; n < r - 1; n += u) {
        if (Wr.distanceSqToSegment(i[n], i[n + 1], h, l) > s) continue;
        h.applyMatrix4(this.matrixWorld);
        const r = t.ray.origin.distanceTo(h);
        r < t.near ||
          r > t.far ||
          e.push({
            distance: r,
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: n,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  },
  updateMorphTargets: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const t = e[n[0]];
        if (void 0 !== t) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[n] = e);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  },
});
const Yr = new g(),
  Zr = new g();
function Jr(t, e) {
  Xr.call(this, t, e), (this.type = "LineSegments");
}
function Kr(t, e) {
  Xr.call(this, t, e), (this.type = "LineLoop");
}
function Qr(t) {
  Gt.call(this),
    (this.type = "PointsMaterial"),
    (this.color = new zt(16777215)),
    (this.map = null),
    (this.alphaMap = null),
    (this.size = 1),
    (this.sizeAttenuation = !0),
    (this.morphTargets = !1),
    this.setValues(t);
}
(Jr.prototype = Object.assign(Object.create(Xr.prototype), {
  constructor: Jr,
  isLineSegments: !0,
  computeLineDistances: function () {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (null === t.index) {
        const e = t.attributes.position,
          n = [];
        for (let t = 0, i = e.count; t < i; t += 2)
          Yr.fromBufferAttribute(e, t),
            Zr.fromBufferAttribute(e, t + 1),
            (n[t] = 0 === t ? 0 : n[t - 1]),
            (n[t + 1] = n[t] + Yr.distanceTo(Zr));
        t.setAttribute("lineDistance", new Qt(n, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else if (t.isGeometry) {
      const e = t.vertices,
        n = t.lineDistances;
      for (let t = 0, i = e.length; t < i; t += 2)
        Yr.copy(e[t]),
          Zr.copy(e[t + 1]),
          (n[t] = 0 === t ? 0 : n[t - 1]),
          (n[t + 1] = n[t] + Yr.distanceTo(Zr));
    }
    return this;
  },
})),
  (Kr.prototype = Object.assign(Object.create(Xr.prototype), {
    constructor: Kr,
    isLineLoop: !0,
  })),
  (Qr.prototype = Object.create(Gt.prototype)),
  (Qr.prototype.constructor = Qr),
  (Qr.prototype.isPointsMaterial = !0),
  (Qr.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      (this.morphTargets = t.morphTargets),
      this
    );
  });
const $r = new j(),
  to = new V(),
  eo = new D(),
  no = new g();
function io(t, e) {
  mt.call(this),
    (this.type = "Points"),
    (this.geometry = void 0 !== t ? t : new le()),
    (this.material = void 0 !== e ? e : new Qr()),
    this.updateMorphTargets();
}
function ro(t, e, n, i, r, o, s) {
  const a = to.distanceSqToPoint(t);
  if (a < n) {
    const n = new g();
    to.closestPointToPoint(t, n), n.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(n);
    if (c < r.near || c > r.far) return;
    o.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: n,
      index: e,
      face: null,
      object: s,
    });
  }
}
function oo(t, e, n, i, r, o, s, a, c) {
  u.call(this, t, e, n, i, r, o, s, a, c),
    (this.format = void 0 !== s ? s : 1022),
    (this.minFilter = void 0 !== o ? o : 1006),
    (this.magFilter = void 0 !== r ? r : 1006),
    (this.generateMipmaps = !1);
  const l = this;
  "requestVideoFrameCallback" in t &&
    t.requestVideoFrameCallback(function e() {
      (l.needsUpdate = !0), t.requestVideoFrameCallback(e);
    });
}
function so(t, e, n, i, r, o, s, a, c, l, h, d) {
  u.call(this, null, o, s, a, c, l, i, r, h, d),
    (this.image = { width: e, height: n }),
    (this.mipmaps = t),
    (this.flipY = !1),
    (this.generateMipmaps = !1);
}
function ao(t, e, n, i, r, o, s, a, c) {
  u.call(this, t, e, n, i, r, o, s, a, c), (this.needsUpdate = !0);
}
function co(t, e, n, i, r, o, s, a, c, l) {
  if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l)
    throw new Error(
      "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
    );
  void 0 === n && 1026 === l && (n = 1012),
    void 0 === n && 1027 === l && (n = 1020),
    u.call(this, null, i, r, o, s, a, l, n, c),
    (this.image = { width: t, height: e }),
    (this.magFilter = void 0 !== s ? s : 1003),
    (this.minFilter = void 0 !== a ? a : 1003),
    (this.flipY = !1),
    (this.generateMipmaps = !1);
}
(io.prototype = Object.assign(Object.create(mt.prototype), {
  constructor: io,
  isPoints: !0,
  copy: function (t) {
    return (
      mt.prototype.copy.call(this, t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  },
  raycast: function (t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = t.params.Points.threshold;
    if (
      (null === n.boundingSphere && n.computeBoundingSphere(),
      eo.copy(n.boundingSphere),
      eo.applyMatrix4(i),
      (eo.radius += r),
      !1 === t.ray.intersectsSphere(eo))
    )
      return;
    $r.getInverse(i), to.copy(t.ray).applyMatrix4($r);
    const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      s = o * o;
    if (n.isBufferGeometry) {
      const r = n.index,
        o = n.attributes.position.array;
      if (null !== r) {
        const n = r.array;
        for (let r = 0, a = n.length; r < a; r++) {
          const a = n[r];
          no.fromArray(o, 3 * a), ro(no, a, s, i, t, e, this);
        }
      } else
        for (let n = 0, r = o.length / 3; n < r; n++)
          no.fromArray(o, 3 * n), ro(no, n, s, i, t, e, this);
    } else {
      const r = n.vertices;
      for (let n = 0, o = r.length; n < o; n++) ro(r[n], n, s, i, t, e, this);
    }
  },
  updateMorphTargets: function () {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const t = e[n[0]];
        if (void 0 !== t) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[n] = e);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      void 0 !== e &&
        e.length > 0 &&
        console.error(
          "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  },
})),
  (oo.prototype = Object.assign(Object.create(u.prototype), {
    constructor: oo,
    isVideoTexture: !0,
    update: function () {
      const t = this.image;
      !1 === "requestVideoFrameCallback" in t &&
        t.readyState >= t.HAVE_CURRENT_DATA &&
        (this.needsUpdate = !0);
    },
  })),
  (so.prototype = Object.create(u.prototype)),
  (so.prototype.constructor = so),
  (so.prototype.isCompressedTexture = !0),
  (ao.prototype = Object.create(u.prototype)),
  (ao.prototype.constructor = ao),
  (ao.prototype.isCanvasTexture = !0),
  (co.prototype = Object.create(u.prototype)),
  (co.prototype.constructor = co),
  (co.prototype.isDepthTexture = !0);
class lo extends le {
  constructor(t) {
    super(), (this.type = "WireframeGeometry");
    const e = [],
      n = [0, 0],
      i = {},
      r = ["a", "b", "c"];
    if (t && t.isGeometry) {
      const o = t.faces;
      for (let t = 0, e = o.length; t < e; t++) {
        const e = o[t];
        for (let t = 0; t < 3; t++) {
          const o = e[r[t]],
            s = e[r[(t + 1) % 3]];
          (n[0] = Math.min(o, s)), (n[1] = Math.max(o, s));
          const a = n[0] + "," + n[1];
          void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] });
        }
      }
      for (const n in i) {
        const r = i[n];
        let o = t.vertices[r.index1];
        e.push(o.x, o.y, o.z),
          (o = t.vertices[r.index2]),
          e.push(o.x, o.y, o.z);
      }
    } else if (t && t.isBufferGeometry) {
      const r = new g();
      if (null !== t.index) {
        const o = t.attributes.position,
          s = t.index;
        let a = t.groups;
        0 === a.length &&
          (a = [{ start: 0, count: s.count, materialIndex: 0 }]);
        for (let t = 0, e = a.length; t < e; ++t) {
          const e = a[t],
            r = e.start;
          for (let t = r, o = r + e.count; t < o; t += 3)
            for (let e = 0; e < 3; e++) {
              const r = s.getX(t + e),
                o = s.getX(t + ((e + 1) % 3));
              (n[0] = Math.min(r, o)), (n[1] = Math.max(r, o));
              const a = n[0] + "," + n[1];
              void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] });
            }
        }
        for (const t in i) {
          const n = i[t];
          r.fromBufferAttribute(o, n.index1),
            e.push(r.x, r.y, r.z),
            r.fromBufferAttribute(o, n.index2),
            e.push(r.x, r.y, r.z);
        }
      } else {
        const n = t.attributes.position;
        for (let t = 0, i = n.count / 3; t < i; t++)
          for (let i = 0; i < 3; i++) {
            const o = 3 * t + i;
            r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z);
            const s = 3 * t + ((i + 1) % 3);
            r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z);
          }
      }
    }
    this.setAttribute("position", new Qt(e, 3));
  }
}
function ho(t, e, n) {
  Ie.call(this),
    (this.type = "ParametricGeometry"),
    (this.parameters = { func: t, slices: e, stacks: n }),
    this.fromBufferGeometry(new uo(t, e, n)),
    this.mergeVertices();
}
function uo(t, e, n) {
  le.call(this),
    (this.type = "ParametricBufferGeometry"),
    (this.parameters = { func: t, slices: e, stacks: n });
  const i = [],
    r = [],
    o = [],
    s = [],
    a = 1e-5,
    c = new g(),
    l = new g(),
    h = new g(),
    u = new g(),
    d = new g();
  t.length < 3 &&
    console.error(
      "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
    );
  const p = e + 1;
  for (let i = 0; i <= n; i++) {
    const p = i / n;
    for (let n = 0; n <= e; n++) {
      const i = n / e;
      t(i, p, l),
        r.push(l.x, l.y, l.z),
        i - a >= 0
          ? (t(i - a, p, h), u.subVectors(l, h))
          : (t(i + a, p, h), u.subVectors(h, l)),
        p - a >= 0
          ? (t(i, p - a, h), d.subVectors(l, h))
          : (t(i, p + a, h), d.subVectors(h, l)),
        c.crossVectors(u, d).normalize(),
        o.push(c.x, c.y, c.z),
        s.push(i, p);
    }
  }
  for (let t = 0; t < n; t++)
    for (let n = 0; n < e; n++) {
      const e = t * p + n,
        r = t * p + n + 1,
        o = (t + 1) * p + n + 1,
        s = (t + 1) * p + n;
      i.push(e, r, s), i.push(r, o, s);
    }
  this.setIndex(i),
    this.setAttribute("position", new Qt(r, 3)),
    this.setAttribute("normal", new Qt(o, 3)),
    this.setAttribute("uv", new Qt(s, 2));
}
(ho.prototype = Object.create(Ie.prototype)),
  (ho.prototype.constructor = ho),
  (uo.prototype = Object.create(le.prototype)),
  (uo.prototype.constructor = uo);
class po extends Ie {
  constructor(t, e, n, i) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
      this.fromBufferGeometry(new fo(t, e, n, i)),
      this.mergeVertices();
  }
}
class fo extends le {
  constructor(t, e, n, i) {
    super(),
      (this.type = "PolyhedronBufferGeometry"),
      (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
      (n = n || 1);
    const r = [],
      o = [];
    function a(t, e, n, i) {
      const r = Math.pow(2, i),
        o = [];
      for (let i = 0; i <= r; i++) {
        o[i] = [];
        const s = t.clone().lerp(n, i / r),
          a = e.clone().lerp(n, i / r),
          c = r - i;
        for (let t = 0; t <= c; t++)
          o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c);
      }
      for (let t = 0; t < r; t++)
        for (let e = 0; e < 2 * (r - t) - 1; e++) {
          const n = Math.floor(e / 2);
          e % 2 == 0
            ? (c(o[t][n + 1]), c(o[t + 1][n]), c(o[t][n]))
            : (c(o[t][n + 1]), c(o[t + 1][n + 1]), c(o[t + 1][n]));
        }
    }
    function c(t) {
      r.push(t.x, t.y, t.z);
    }
    function l(e, n) {
      const i = 3 * e;
      (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
    }
    function h(t, e, n, i) {
      i < 0 && 1 === t.x && (o[e] = t.x - 1),
        0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + 0.5);
    }
    function u(t) {
      return Math.atan2(t.z, -t.x);
    }
    !(function (t) {
      const n = new g(),
        i = new g(),
        r = new g();
      for (let o = 0; o < e.length; o += 3)
        l(e[o + 0], n), l(e[o + 1], i), l(e[o + 2], r), a(n, i, r, t);
    })((i = i || 0)),
      (function (t) {
        const e = new g();
        for (let n = 0; n < r.length; n += 3)
          (e.x = r[n + 0]),
            (e.y = r[n + 1]),
            (e.z = r[n + 2]),
            e.normalize().multiplyScalar(t),
            (r[n + 0] = e.x),
            (r[n + 1] = e.y),
            (r[n + 2] = e.z);
      })(n),
      (function () {
        const t = new g();
        for (let n = 0; n < r.length; n += 3) {
          (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
          const i = u(t) / 2 / Math.PI + 0.5,
            s =
              ((e = t),
              Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI +
                0.5);
          o.push(i, 1 - s);
        }
        var e;
        (function () {
          const t = new g(),
            e = new g(),
            n = new g(),
            i = new g(),
            a = new s(),
            c = new s(),
            l = new s();
          for (let s = 0, d = 0; s < r.length; s += 9, d += 6) {
            t.set(r[s + 0], r[s + 1], r[s + 2]),
              e.set(r[s + 3], r[s + 4], r[s + 5]),
              n.set(r[s + 6], r[s + 7], r[s + 8]),
              a.set(o[d + 0], o[d + 1]),
              c.set(o[d + 2], o[d + 3]),
              l.set(o[d + 4], o[d + 5]),
              i.copy(t).add(e).add(n).divideScalar(3);
            const p = u(i);
            h(a, d + 0, t, p), h(c, d + 2, e, p), h(l, d + 4, n, p);
          }
        })(),
          (function () {
            for (let t = 0; t < o.length; t += 6) {
              const e = o[t + 0],
                n = o[t + 2],
                i = o[t + 4],
                r = Math.max(e, n, i),
                s = Math.min(e, n, i);
              r > 0.9 &&
                s < 0.1 &&
                (e < 0.2 && (o[t + 0] += 1),
                n < 0.2 && (o[t + 2] += 1),
                i < 0.2 && (o[t + 4] += 1));
            }
          })();
      })(),
      this.setAttribute("position", new Qt(r, 3)),
      this.setAttribute("normal", new Qt(r.slice(), 3)),
      this.setAttribute("uv", new Qt(o, 2)),
      0 === i ? this.computeVertexNormals() : this.normalizeNormals();
  }
}
class mo extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new go(t, e)),
      this.mergeVertices();
  }
}
class go extends fo {
  constructor(t, e) {
    super(
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ),
      (this.type = "TetrahedronBufferGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
}
class vo extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new yo(t, e)),
      this.mergeVertices();
  }
}
class yo extends fo {
  constructor(t, e) {
    super(
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ),
      (this.type = "OctahedronBufferGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
}
class xo extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new bo(t, e)),
      this.mergeVertices();
  }
}
class bo extends fo {
  constructor(t, e) {
    const n = (1 + Math.sqrt(5)) / 2;
    super(
      [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      t,
      e
    ),
      (this.type = "IcosahedronBufferGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
}
class _o extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new wo(t, e)),
      this.mergeVertices();
  }
}
class wo extends fo {
  constructor(t, e) {
    const n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n;
    super(
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i,
      ],
      [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ],
      t,
      e
    ),
      (this.type = "DodecahedronBufferGeometry"),
      (this.parameters = { radius: t, detail: e });
  }
}
class Mo extends Ie {
  constructor(t, e, n, i, r, o) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: n,
        radialSegments: i,
        closed: r,
      }),
      void 0 !== o &&
        console.warn("THREE.TubeGeometry: taper has been removed.");
    const s = new So(t, e, n, i, r);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals),
      this.fromBufferGeometry(s),
      this.mergeVertices();
  }
}
class So extends le {
  constructor(t, e, n, i, r) {
    super(),
      (this.type = "TubeBufferGeometry"),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: n,
        radialSegments: i,
        closed: r,
      }),
      (e = e || 64),
      (n = n || 1),
      (i = i || 8),
      (r = r || !1);
    const o = t.computeFrenetFrames(e, r);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new g(),
      c = new g(),
      l = new s();
    let h = new g();
    const u = [],
      d = [],
      p = [],
      f = [];
    function m(r) {
      h = t.getPointAt(r / e, h);
      const s = o.normals[r],
        l = o.binormals[r];
      for (let t = 0; t <= i; t++) {
        const e = (t / i) * Math.PI * 2,
          r = Math.sin(e),
          o = -Math.cos(e);
        (c.x = o * s.x + r * l.x),
          (c.y = o * s.y + r * l.y),
          (c.z = o * s.z + r * l.z),
          c.normalize(),
          d.push(c.x, c.y, c.z),
          (a.x = h.x + n * c.x),
          (a.y = h.y + n * c.y),
          (a.z = h.z + n * c.z),
          u.push(a.x, a.y, a.z);
      }
    }
    !(function () {
      for (let t = 0; t < e; t++) m(t);
      m(!1 === r ? e : 0),
        (function () {
          for (let t = 0; t <= e; t++)
            for (let n = 0; n <= i; n++)
              (l.x = t / e), (l.y = n / i), p.push(l.x, l.y);
        })(),
        (function () {
          for (let t = 1; t <= e; t++)
            for (let e = 1; e <= i; e++) {
              const n = (i + 1) * (t - 1) + (e - 1),
                r = (i + 1) * t + (e - 1),
                o = (i + 1) * t + e,
                s = (i + 1) * (t - 1) + e;
              f.push(n, r, s), f.push(r, o, s);
            }
        })();
    })(),
      this.setIndex(f),
      this.setAttribute("position", new Qt(u, 3)),
      this.setAttribute("normal", new Qt(d, 3)),
      this.setAttribute("uv", new Qt(p, 2));
  }
  toJSON() {
    const t = le.prototype.toJSON.call(this);
    return (t.path = this.parameters.path.toJSON()), t;
  }
}
class To extends Ie {
  constructor(t, e, n, i, r, o, s) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: n,
        radialSegments: i,
        p: r,
        q: o,
      }),
      void 0 !== s &&
        console.warn(
          "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."
        ),
      this.fromBufferGeometry(new Eo(t, e, n, i, r, o)),
      this.mergeVertices();
  }
}
class Eo extends le {
  constructor(t, e, n, i, r, o) {
    super(),
      (this.type = "TorusKnotBufferGeometry"),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: n,
        radialSegments: i,
        p: r,
        q: o,
      }),
      (t = t || 1),
      (e = e || 0.4),
      (n = Math.floor(n) || 64),
      (i = Math.floor(i) || 8),
      (r = r || 2),
      (o = o || 3);
    const s = [],
      a = [],
      c = [],
      l = [],
      h = new g(),
      u = new g(),
      d = new g(),
      p = new g(),
      f = new g(),
      m = new g(),
      v = new g();
    for (let s = 0; s <= n; ++s) {
      const g = (s / n) * r * Math.PI * 2;
      y(g, r, o, t, d),
        y(g + 0.01, r, o, t, p),
        m.subVectors(p, d),
        v.addVectors(p, d),
        f.crossVectors(m, v),
        v.crossVectors(f, m),
        f.normalize(),
        v.normalize();
      for (let t = 0; t <= i; ++t) {
        const r = (t / i) * Math.PI * 2,
          o = -e * Math.cos(r),
          p = e * Math.sin(r);
        (h.x = d.x + (o * v.x + p * f.x)),
          (h.y = d.y + (o * v.y + p * f.y)),
          (h.z = d.z + (o * v.z + p * f.z)),
          a.push(h.x, h.y, h.z),
          u.subVectors(h, d).normalize(),
          c.push(u.x, u.y, u.z),
          l.push(s / n),
          l.push(t / i);
      }
    }
    for (let t = 1; t <= n; t++)
      for (let e = 1; e <= i; e++) {
        const n = (i + 1) * (t - 1) + (e - 1),
          r = (i + 1) * t + (e - 1),
          o = (i + 1) * t + e,
          a = (i + 1) * (t - 1) + e;
        s.push(n, r, a), s.push(r, o, a);
      }
    function y(t, e, n, i, r) {
      const o = Math.cos(t),
        s = Math.sin(t),
        a = (n / e) * t,
        c = Math.cos(a);
      (r.x = i * (2 + c) * 0.5 * o),
        (r.y = i * (2 + c) * s * 0.5),
        (r.z = i * Math.sin(a) * 0.5);
    }
    this.setIndex(s),
      this.setAttribute("position", new Qt(a, 3)),
      this.setAttribute("normal", new Qt(c, 3)),
      this.setAttribute("uv", new Qt(l, 2));
  }
}
class Ao extends Ie {
  constructor(t, e, n, i, r) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: n,
        tubularSegments: i,
        arc: r,
      }),
      this.fromBufferGeometry(new Lo(t, e, n, i, r)),
      this.mergeVertices();
  }
}
class Lo extends le {
  constructor(t, e, n, i, r) {
    super(),
      (this.type = "TorusBufferGeometry"),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: n,
        tubularSegments: i,
        arc: r,
      }),
      (t = t || 1),
      (e = e || 0.4),
      (n = Math.floor(n) || 8),
      (i = Math.floor(i) || 6),
      (r = r || 2 * Math.PI);
    const o = [],
      s = [],
      a = [],
      c = [],
      l = new g(),
      h = new g(),
      u = new g();
    for (let o = 0; o <= n; o++)
      for (let d = 0; d <= i; d++) {
        const p = (d / i) * r,
          f = (o / n) * Math.PI * 2;
        (h.x = (t + e * Math.cos(f)) * Math.cos(p)),
          (h.y = (t + e * Math.cos(f)) * Math.sin(p)),
          (h.z = e * Math.sin(f)),
          s.push(h.x, h.y, h.z),
          (l.x = t * Math.cos(p)),
          (l.y = t * Math.sin(p)),
          u.subVectors(h, l).normalize(),
          a.push(u.x, u.y, u.z),
          c.push(d / i),
          c.push(o / n);
      }
    for (let t = 1; t <= n; t++)
      for (let e = 1; e <= i; e++) {
        const n = (i + 1) * t + e - 1,
          r = (i + 1) * (t - 1) + e - 1,
          s = (i + 1) * (t - 1) + e,
          a = (i + 1) * t + e;
        o.push(n, r, a), o.push(r, s, a);
      }
    this.setIndex(o),
      this.setAttribute("position", new Qt(s, 3)),
      this.setAttribute("normal", new Qt(a, 3)),
      this.setAttribute("uv", new Qt(c, 2));
  }
}
const Ro = function (t, e, n) {
  n = n || 2;
  const i = e && e.length,
    r = i ? e[0] * n : t.length;
  let o = Po(t, 0, r, n, !0);
  const s = [];
  if (!o || o.next === o.prev) return s;
  let a, c, l, h, u, d, p;
  if (
    (i &&
      (o = (function (t, e, n, i) {
        const r = [];
        let o, s, a, c, l;
        for (o = 0, s = e.length; o < s; o++)
          (a = e[o] * i),
            (c = o < s - 1 ? e[o + 1] * i : t.length),
            (l = Po(t, a, c, i, !1)),
            l === l.next && (l.steiner = !0),
            r.push(Ho(l));
        for (r.sort(zo), o = 0; o < r.length; o++)
          Fo(r[o], n), (n = Co(n, n.next));
        return n;
      })(t, e, o, n)),
    t.length > 80 * n)
  ) {
    (a = l = t[0]), (c = h = t[1]);
    for (let e = n; e < r; e += n)
      (u = t[e]),
        (d = t[e + 1]),
        u < a && (a = u),
        d < c && (c = d),
        u > l && (l = u),
        d > h && (h = d);
    (p = Math.max(l - a, h - c)), (p = 0 !== p ? 1 / p : 0);
  }
  return Oo(o, s, n, a, c, p), s;
};
function Po(t, e, n, i, r) {
  let o, s;
  if (
    r ===
    (function (t, e, n, i) {
      let r = 0;
      for (let o = e, s = n - i; o < n; o += i)
        (r += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
      return r;
    })(t, e, n, i) >
      0
  )
    for (o = e; o < n; o += i) s = Ko(o, t[o], t[o + 1], s);
  else for (o = n - i; o >= e; o -= i) s = Ko(o, t[o], t[o + 1], s);
  return s && Wo(s, s.next) && (Qo(s), (s = s.next)), s;
}
function Co(t, e) {
  if (!t) return t;
  e || (e = t);
  let n,
    i = t;
  do {
    if (
      ((n = !1), i.steiner || (!Wo(i, i.next) && 0 !== jo(i.prev, i, i.next)))
    )
      i = i.next;
    else {
      if ((Qo(i), (i = e = i.prev), i === i.next)) break;
      n = !0;
    }
  } while (n || i !== e);
  return e;
}
function Oo(t, e, n, i, r, o, s) {
  if (!t) return;
  !s &&
    o &&
    (function (t, e, n, i) {
      let r = t;
      do {
        null === r.z && (r.z = Go(r.x, r.y, e, n, i)),
          (r.prevZ = r.prev),
          (r.nextZ = r.next),
          (r = r.next);
      } while (r !== t);
      (r.prevZ.nextZ = null),
        (r.prevZ = null),
        (function (t) {
          let e,
            n,
            i,
            r,
            o,
            s,
            a,
            c,
            l = 1;
          do {
            for (n = t, t = null, o = null, s = 0; n; ) {
              for (
                s++, i = n, a = 0, e = 0;
                e < l && (a++, (i = i.nextZ), i);
                e++
              );
              for (c = l; a > 0 || (c > 0 && i); )
                0 !== a && (0 === c || !i || n.z <= i.z)
                  ? ((r = n), (n = n.nextZ), a--)
                  : ((r = i), (i = i.nextZ), c--),
                  o ? (o.nextZ = r) : (t = r),
                  (r.prevZ = o),
                  (o = r);
              n = i;
            }
            (o.nextZ = null), (l *= 2);
          } while (s > 1);
        })(r);
    })(t, i, r, o);
  let a,
    c,
    l = t;
  for (; t.prev !== t.next; )
    if (((a = t.prev), (c = t.next), o ? Io(t, i, r, o) : No(t)))
      e.push(a.i / n),
        e.push(t.i / n),
        e.push(c.i / n),
        Qo(t),
        (t = c.next),
        (l = c.next);
    else if ((t = c) === l) {
      s
        ? 1 === s
          ? Oo((t = Do(Co(t), e, n)), e, n, i, r, o, 2)
          : 2 === s && Bo(t, e, n, i, r, o)
        : Oo(Co(t), e, n, i, r, o, 1);
      break;
    }
}
function No(t) {
  const e = t.prev,
    n = t,
    i = t.next;
  if (jo(e, n, i) >= 0) return !1;
  let r = t.next.next;
  for (; r !== t.prev; ) {
    if (
      ko(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
      jo(r.prev, r, r.next) >= 0
    )
      return !1;
    r = r.next;
  }
  return !0;
}
function Io(t, e, n, i) {
  const r = t.prev,
    o = t,
    s = t.next;
  if (jo(r, o, s) >= 0) return !1;
  const a = r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
    c = r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
    l = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
    h = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
    u = Go(a, c, e, n, i),
    d = Go(l, h, e, n, i);
  let p = t.prevZ,
    f = t.nextZ;
  for (; p && p.z >= u && f && f.z <= d; ) {
    if (
      p !== t.prev &&
      p !== t.next &&
      ko(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
      jo(p.prev, p, p.next) >= 0
    )
      return !1;
    if (
      ((p = p.prevZ),
      f !== t.prev &&
        f !== t.next &&
        ko(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
        jo(f.prev, f, f.next) >= 0)
    )
      return !1;
    f = f.nextZ;
  }
  for (; p && p.z >= u; ) {
    if (
      p !== t.prev &&
      p !== t.next &&
      ko(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
      jo(p.prev, p, p.next) >= 0
    )
      return !1;
    p = p.prevZ;
  }
  for (; f && f.z <= d; ) {
    if (
      f !== t.prev &&
      f !== t.next &&
      ko(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
      jo(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.nextZ;
  }
  return !0;
}
function Do(t, e, n) {
  let i = t;
  do {
    const r = i.prev,
      o = i.next.next;
    !Wo(r, o) &&
      qo(r, i, i.next, o) &&
      Zo(r, o) &&
      Zo(o, r) &&
      (e.push(r.i / n),
      e.push(i.i / n),
      e.push(o.i / n),
      Qo(i),
      Qo(i.next),
      (i = t = o)),
      (i = i.next);
  } while (i !== t);
  return Co(i);
}
function Bo(t, e, n, i, r, o) {
  let s = t;
  do {
    let t = s.next.next;
    for (; t !== s.prev; ) {
      if (s.i !== t.i && Vo(s, t)) {
        let a = Jo(s, t);
        return (
          (s = Co(s, s.next)),
          (a = Co(a, a.next)),
          Oo(s, e, n, i, r, o),
          void Oo(a, e, n, i, r, o)
        );
      }
      t = t.next;
    }
    s = s.next;
  } while (s !== t);
}
function zo(t, e) {
  return t.x - e.x;
}
function Fo(t, e) {
  if (
    (e = (function (t, e) {
      let n = e;
      const i = t.x,
        r = t.y;
      let o,
        s = -1 / 0;
      do {
        if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
          const t = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
          if (t <= i && t > s) {
            if (((s = t), t === i)) {
              if (r === n.y) return n;
              if (r === n.next.y) return n.next;
            }
            o = n.x < n.next.x ? n : n.next;
          }
        }
        n = n.next;
      } while (n !== e);
      if (!o) return null;
      if (i === s) return o;
      const a = o,
        c = o.x,
        l = o.y;
      let h,
        u = 1 / 0;
      n = o;
      do {
        i >= n.x &&
          n.x >= c &&
          i !== n.x &&
          ko(r < l ? i : s, r, c, l, r < l ? s : i, r, n.x, n.y) &&
          ((h = Math.abs(r - n.y) / (i - n.x)),
          Zo(n, t) &&
            (h < u || (h === u && (n.x > o.x || (n.x === o.x && Uo(o, n))))) &&
            ((o = n), (u = h))),
          (n = n.next);
      } while (n !== a);
      return o;
    })(t, e))
  ) {
    const n = Jo(e, t);
    Co(e, e.next), Co(n, n.next);
  }
}
function Uo(t, e) {
  return jo(t.prev, t, e.prev) < 0 && jo(e.next, t, t.next) < 0;
}
function Go(t, e, n, i, r) {
  return (
    (t =
      1431655765 &
      ((t =
        858993459 &
        ((t =
          252645135 &
          ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
            (t << 4))) |
          (t << 2))) |
        (t << 1))) |
    ((e =
      1431655765 &
      ((e =
        858993459 &
        ((e =
          252645135 &
          ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
            (e << 4))) |
          (e << 2))) |
        (e << 1))) <<
      1)
  );
}
function Ho(t) {
  let e = t,
    n = t;
  do {
    (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
  } while (e !== t);
  return n;
}
function ko(t, e, n, i, r, o, s, a) {
  return (
    (r - s) * (e - a) - (t - s) * (o - a) >= 0 &&
    (t - s) * (i - a) - (n - s) * (e - a) >= 0 &&
    (n - s) * (o - a) - (r - s) * (i - a) >= 0
  );
}
function Vo(t, e) {
  return (
    t.next.i !== e.i &&
    t.prev.i !== e.i &&
    !(function (t, e) {
      let n = t;
      do {
        if (
          n.i !== t.i &&
          n.next.i !== t.i &&
          n.i !== e.i &&
          n.next.i !== e.i &&
          qo(n, n.next, t, e)
        )
          return !0;
        n = n.next;
      } while (n !== t);
      return !1;
    })(t, e) &&
    ((Zo(t, e) &&
      Zo(e, t) &&
      (function (t, e) {
        let n = t,
          i = !1;
        const r = (t.x + e.x) / 2,
          o = (t.y + e.y) / 2;
        do {
          n.y > o != n.next.y > o &&
            n.next.y !== n.y &&
            r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
            (i = !i),
            (n = n.next);
        } while (n !== t);
        return i;
      })(t, e) &&
      (jo(t.prev, t, e.prev) || jo(t, e.prev, e))) ||
      (Wo(t, e) && jo(t.prev, t, t.next) > 0 && jo(e.prev, e, e.next) > 0))
  );
}
function jo(t, e, n) {
  return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
}
function Wo(t, e) {
  return t.x === e.x && t.y === e.y;
}
function qo(t, e, n, i) {
  const r = Yo(jo(t, e, n)),
    o = Yo(jo(t, e, i)),
    s = Yo(jo(n, i, t)),
    a = Yo(jo(n, i, e));
  return (
    (r !== o && s !== a) ||
    !(0 !== r || !Xo(t, n, e)) ||
    !(0 !== o || !Xo(t, i, e)) ||
    !(0 !== s || !Xo(n, t, i)) ||
    !(0 !== a || !Xo(n, e, i))
  );
}
function Xo(t, e, n) {
  return (
    e.x <= Math.max(t.x, n.x) &&
    e.x >= Math.min(t.x, n.x) &&
    e.y <= Math.max(t.y, n.y) &&
    e.y >= Math.min(t.y, n.y)
  );
}
function Yo(t) {
  return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function Zo(t, e) {
  return jo(t.prev, t, t.next) < 0
    ? jo(t, e, t.next) >= 0 && jo(t, t.prev, e) >= 0
    : jo(t, e, t.prev) < 0 || jo(t, t.next, e) < 0;
}
function Jo(t, e) {
  const n = new $o(t.i, t.x, t.y),
    i = new $o(e.i, e.x, e.y),
    r = t.next,
    o = e.prev;
  return (
    (t.next = e),
    (e.prev = t),
    (n.next = r),
    (r.prev = n),
    (i.next = n),
    (n.prev = i),
    (o.next = i),
    (i.prev = o),
    i
  );
}
function Ko(t, e, n, i) {
  const r = new $o(t, e, n);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function Qo(t) {
  (t.next.prev = t.prev),
    (t.prev.next = t.next),
    t.prevZ && (t.prevZ.nextZ = t.nextZ),
    t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function $o(t, e, n) {
  (this.i = t),
    (this.x = e),
    (this.y = n),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
const ts = {
  area: function (t) {
    const e = t.length;
    let n = 0;
    for (let i = e - 1, r = 0; r < e; i = r++)
      n += t[i].x * t[r].y - t[r].x * t[i].y;
    return 0.5 * n;
  },
  isClockWise: function (t) {
    return ts.area(t) < 0;
  },
  triangulateShape: function (t, e) {
    const n = [],
      i = [],
      r = [];
    es(t), ns(n, t);
    let o = t.length;
    e.forEach(es);
    for (let t = 0; t < e.length; t++)
      i.push(o), (o += e[t].length), ns(n, e[t]);
    const s = Ro(n, i);
    for (let t = 0; t < s.length; t += 3) r.push(s.slice(t, t + 3));
    return r;
  },
};
function es(t) {
  const e = t.length;
  e > 2 && t[e - 1].equals(t[0]) && t.pop();
}
function ns(t, e) {
  for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
}
class is extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: t, options: e }),
      this.fromBufferGeometry(new rs(t, e)),
      this.mergeVertices();
  }
  toJSON() {
    const t = super.toJSON();
    return ss(this.parameters.shapes, this.parameters.options, t);
  }
}
class rs extends le {
  constructor(t, e) {
    super(),
      (this.type = "ExtrudeBufferGeometry"),
      (this.parameters = { shapes: t, options: e }),
      (t = Array.isArray(t) ? t : [t]);
    const n = this,
      i = [],
      r = [];
    for (let e = 0, n = t.length; e < n; e++) {
      o(t[e]);
    }
    function o(t) {
      const o = [],
        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
        c = void 0 !== e.steps ? e.steps : 1;
      let l = void 0 !== e.depth ? e.depth : 100,
        h = void 0 === e.bevelEnabled || e.bevelEnabled,
        u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
        d = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
        p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
        f = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
      const m = e.extrudePath,
        v = void 0 !== e.UVGenerator ? e.UVGenerator : os;
      void 0 !== e.amount &&
        (console.warn(
          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
        ),
        (l = e.amount));
      let y,
        x,
        b,
        _,
        w,
        M = !1;
      m &&
        ((y = m.getSpacedPoints(c)),
        (M = !0),
        (h = !1),
        (x = m.computeFrenetFrames(c, !1)),
        (b = new g()),
        (_ = new g()),
        (w = new g())),
        h || ((f = 0), (u = 0), (d = 0), (p = 0));
      const S = t.extractPoints(a);
      let T = S.shape;
      const E = S.holes;
      if (!ts.isClockWise(T)) {
        T = T.reverse();
        for (let t = 0, e = E.length; t < e; t++) {
          const e = E[t];
          ts.isClockWise(e) && (E[t] = e.reverse());
        }
      }
      const A = ts.triangulateShape(T, E),
        L = T;
      for (let t = 0, e = E.length; t < e; t++) {
        const e = E[t];
        T = T.concat(e);
      }
      function R(t, e, n) {
        return (
          e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          e.clone().multiplyScalar(n).add(t)
        );
      }
      const P = T.length,
        C = A.length;
      function O(t, e, n) {
        let i, r, o;
        const a = t.x - e.x,
          c = t.y - e.y,
          l = n.x - t.x,
          h = n.y - t.y,
          u = a * a + c * c,
          d = a * h - c * l;
        if (Math.abs(d) > Number.EPSILON) {
          const d = Math.sqrt(u),
            p = Math.sqrt(l * l + h * h),
            f = e.x - c / d,
            m = e.y + a / d,
            g =
              ((n.x - h / p - f) * h - (n.y + l / p - m) * l) / (a * h - c * l);
          (i = f + a * g - t.x), (r = m + c * g - t.y);
          const v = i * i + r * r;
          if (v <= 2) return new s(i, r);
          o = Math.sqrt(v / 2);
        } else {
          let t = !1;
          a > Number.EPSILON
            ? l > Number.EPSILON && (t = !0)
            : a < -Number.EPSILON
            ? l < -Number.EPSILON && (t = !0)
            : Math.sign(c) === Math.sign(h) && (t = !0),
            t
              ? ((i = -c), (r = a), (o = Math.sqrt(u)))
              : ((i = a), (r = c), (o = Math.sqrt(u / 2)));
        }
        return new s(i / o, r / o);
      }
      const N = [];
      for (let t = 0, e = L.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)
        n === e && (n = 0), i === e && (i = 0), (N[t] = O(L[t], L[n], L[i]));
      const I = [];
      let D,
        B = N.concat();
      for (let t = 0, e = E.length; t < e; t++) {
        const e = E[t];
        D = [];
        for (
          let t = 0, n = e.length, i = n - 1, r = t + 1;
          t < n;
          t++, i++, r++
        )
          i === n && (i = 0), r === n && (r = 0), (D[t] = O(e[t], e[i], e[r]));
        I.push(D), (B = B.concat(D));
      }
      for (let t = 0; t < f; t++) {
        const e = t / f,
          n = u * Math.cos((e * Math.PI) / 2),
          i = d * Math.sin((e * Math.PI) / 2) + p;
        for (let t = 0, e = L.length; t < e; t++) {
          const e = R(L[t], N[t], i);
          U(e.x, e.y, -n);
        }
        for (let t = 0, e = E.length; t < e; t++) {
          const e = E[t];
          D = I[t];
          for (let t = 0, r = e.length; t < r; t++) {
            const r = R(e[t], D[t], i);
            U(r.x, r.y, -n);
          }
        }
      }
      const z = d + p;
      for (let t = 0; t < P; t++) {
        const e = h ? R(T[t], B[t], z) : T[t];
        M
          ? (_.copy(x.normals[0]).multiplyScalar(e.x),
            b.copy(x.binormals[0]).multiplyScalar(e.y),
            w.copy(y[0]).add(_).add(b),
            U(w.x, w.y, w.z))
          : U(e.x, e.y, 0);
      }
      for (let t = 1; t <= c; t++)
        for (let e = 0; e < P; e++) {
          const n = h ? R(T[e], B[e], z) : T[e];
          M
            ? (_.copy(x.normals[t]).multiplyScalar(n.x),
              b.copy(x.binormals[t]).multiplyScalar(n.y),
              w.copy(y[t]).add(_).add(b),
              U(w.x, w.y, w.z))
            : U(n.x, n.y, (l / c) * t);
        }
      for (let t = f - 1; t >= 0; t--) {
        const e = t / f,
          n = u * Math.cos((e * Math.PI) / 2),
          i = d * Math.sin((e * Math.PI) / 2) + p;
        for (let t = 0, e = L.length; t < e; t++) {
          const e = R(L[t], N[t], i);
          U(e.x, e.y, l + n);
        }
        for (let t = 0, e = E.length; t < e; t++) {
          const e = E[t];
          D = I[t];
          for (let t = 0, r = e.length; t < r; t++) {
            const r = R(e[t], D[t], i);
            M ? U(r.x, r.y + y[c - 1].y, y[c - 1].x + n) : U(r.x, r.y, l + n);
          }
        }
      }
      function F(t, e) {
        let n = t.length;
        for (; --n >= 0; ) {
          const i = n;
          let r = n - 1;
          r < 0 && (r = t.length - 1);
          for (let t = 0, n = c + 2 * f; t < n; t++) {
            const n = P * t,
              o = P * (t + 1);
            H(e + i + n, e + r + n, e + r + o, e + i + o);
          }
        }
      }
      function U(t, e, n) {
        o.push(t), o.push(e), o.push(n);
      }
      function G(t, e, r) {
        k(t), k(e), k(r);
        const o = i.length / 3,
          s = v.generateTopUV(n, i, o - 3, o - 2, o - 1);
        V(s[0]), V(s[1]), V(s[2]);
      }
      function H(t, e, r, o) {
        k(t), k(e), k(o), k(e), k(r), k(o);
        const s = i.length / 3,
          a = v.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
        V(a[0]), V(a[1]), V(a[3]), V(a[1]), V(a[2]), V(a[3]);
      }
      function k(t) {
        i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]);
      }
      function V(t) {
        r.push(t.x), r.push(t.y);
      }
      !(function () {
        const t = i.length / 3;
        if (h) {
          let t = 0,
            e = P * t;
          for (let t = 0; t < C; t++) {
            const n = A[t];
            G(n[2] + e, n[1] + e, n[0] + e);
          }
          (t = c + 2 * f), (e = P * t);
          for (let t = 0; t < C; t++) {
            const n = A[t];
            G(n[0] + e, n[1] + e, n[2] + e);
          }
        } else {
          for (let t = 0; t < C; t++) {
            const e = A[t];
            G(e[2], e[1], e[0]);
          }
          for (let t = 0; t < C; t++) {
            const e = A[t];
            G(e[0] + P * c, e[1] + P * c, e[2] + P * c);
          }
        }
        n.addGroup(t, i.length / 3 - t, 0);
      })(),
        (function () {
          const t = i.length / 3;
          let e = 0;
          F(L, e), (e += L.length);
          for (let t = 0, n = E.length; t < n; t++) {
            const n = E[t];
            F(n, e), (e += n.length);
          }
          n.addGroup(t, i.length / 3 - t, 1);
        })();
    }
    this.setAttribute("position", new Qt(i, 3)),
      this.setAttribute("uv", new Qt(r, 2)),
      this.computeVertexNormals();
  }
  toJSON() {
    const t = le.prototype.toJSON.call(this);
    return ss(this.parameters.shapes, this.parameters.options, t);
  }
}
const os = {
  generateTopUV: function (t, e, n, i, r) {
    const o = e[3 * n],
      a = e[3 * n + 1],
      c = e[3 * i],
      l = e[3 * i + 1],
      h = e[3 * r],
      u = e[3 * r + 1];
    return [new s(o, a), new s(c, l), new s(h, u)];
  },
  generateSideWallUV: function (t, e, n, i, r, o) {
    const a = e[3 * n],
      c = e[3 * n + 1],
      l = e[3 * n + 2],
      h = e[3 * i],
      u = e[3 * i + 1],
      d = e[3 * i + 2],
      p = e[3 * r],
      f = e[3 * r + 1],
      m = e[3 * r + 2],
      g = e[3 * o],
      v = e[3 * o + 1],
      y = e[3 * o + 2];
    return Math.abs(c - u) < 0.01
      ? [new s(a, 1 - l), new s(h, 1 - d), new s(p, 1 - m), new s(g, 1 - y)]
      : [new s(c, 1 - l), new s(u, 1 - d), new s(f, 1 - m), new s(v, 1 - y)];
  },
};
function ss(t, e, n) {
  if (((n.shapes = []), Array.isArray(t)))
    for (let e = 0, i = t.length; e < i; e++) {
      const i = t[e];
      n.shapes.push(i.uuid);
    }
  else n.shapes.push(t.uuid);
  return (
    void 0 !== e.extrudePath &&
      (n.options.extrudePath = e.extrudePath.toJSON()),
    n
  );
}
class as extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "TextGeometry"),
      (this.parameters = { text: t, parameters: e }),
      this.fromBufferGeometry(new cs(t, e)),
      this.mergeVertices();
  }
}
class cs extends rs {
  constructor(t, e) {
    const n = (e = e || {}).font;
    if (!n || !n.isFont)
      return (
        console.error(
          "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
        ),
        new Ie()
      );
    const i = n.generateShapes(t, e.size);
    (e.depth = void 0 !== e.height ? e.height : 50),
      void 0 === e.bevelThickness && (e.bevelThickness = 10),
      void 0 === e.bevelSize && (e.bevelSize = 8),
      void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
      super(i, e),
      (this.type = "TextBufferGeometry");
  }
}
class ls extends Ie {
  constructor(t, e, n, i, r, o, s) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: s,
      }),
      this.fromBufferGeometry(new hs(t, e, n, i, r, o, s)),
      this.mergeVertices();
  }
}
class hs extends le {
  constructor(t, e, n, i, r, o, s) {
    super(),
      (this.type = "SphereBufferGeometry"),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: s,
      }),
      (t = t || 1),
      (e = Math.max(3, Math.floor(e) || 8)),
      (n = Math.max(2, Math.floor(n) || 6)),
      (i = void 0 !== i ? i : 0),
      (r = void 0 !== r ? r : 2 * Math.PI),
      (o = void 0 !== o ? o : 0),
      (s = void 0 !== s ? s : Math.PI);
    const a = Math.min(o + s, Math.PI);
    let c = 0;
    const l = [],
      h = new g(),
      u = new g(),
      d = [],
      p = [],
      f = [],
      m = [];
    for (let d = 0; d <= n; d++) {
      const g = [],
        v = d / n;
      let y = 0;
      0 == d && 0 == o
        ? (y = 0.5 / e)
        : d == n && a == Math.PI && (y = -0.5 / e);
      for (let n = 0; n <= e; n++) {
        const a = n / e;
        (h.x = -t * Math.cos(i + a * r) * Math.sin(o + v * s)),
          (h.y = t * Math.cos(o + v * s)),
          (h.z = t * Math.sin(i + a * r) * Math.sin(o + v * s)),
          p.push(h.x, h.y, h.z),
          u.copy(h).normalize(),
          f.push(u.x, u.y, u.z),
          m.push(a + y, 1 - v),
          g.push(c++);
      }
      l.push(g);
    }
    for (let t = 0; t < n; t++)
      for (let i = 0; i < e; i++) {
        const e = l[t][i + 1],
          r = l[t][i],
          s = l[t + 1][i],
          c = l[t + 1][i + 1];
        (0 !== t || o > 0) && d.push(e, r, c),
          (t !== n - 1 || a < Math.PI) && d.push(r, s, c);
      }
    this.setIndex(d),
      this.setAttribute("position", new Qt(p, 3)),
      this.setAttribute("normal", new Qt(f, 3)),
      this.setAttribute("uv", new Qt(m, 2));
  }
}
class us extends Ie {
  constructor(t, e, n, i, r, o) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: r,
        thetaLength: o,
      }),
      this.fromBufferGeometry(new ds(t, e, n, i, r, o)),
      this.mergeVertices();
  }
}
class ds extends le {
  constructor(t, e, n, i, r, o) {
    super(),
      (this.type = "RingBufferGeometry"),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: r,
        thetaLength: o,
      }),
      (t = t || 0.5),
      (e = e || 1),
      (r = void 0 !== r ? r : 0),
      (o = void 0 !== o ? o : 2 * Math.PI),
      (n = void 0 !== n ? Math.max(3, n) : 8);
    const a = [],
      c = [],
      l = [],
      h = [];
    let u = t;
    const d = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
      p = new g(),
      f = new s();
    for (let t = 0; t <= i; t++) {
      for (let t = 0; t <= n; t++) {
        const i = r + (t / n) * o;
        (p.x = u * Math.cos(i)),
          (p.y = u * Math.sin(i)),
          c.push(p.x, p.y, p.z),
          l.push(0, 0, 1),
          (f.x = (p.x / e + 1) / 2),
          (f.y = (p.y / e + 1) / 2),
          h.push(f.x, f.y);
      }
      u += d;
    }
    for (let t = 0; t < i; t++) {
      const e = t * (n + 1);
      for (let t = 0; t < n; t++) {
        const i = t + e,
          r = i,
          o = i + n + 1,
          s = i + n + 2,
          c = i + 1;
        a.push(r, o, c), a.push(o, s, c);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Qt(c, 3)),
      this.setAttribute("normal", new Qt(l, 3)),
      this.setAttribute("uv", new Qt(h, 2));
  }
}
class ps extends Ie {
  constructor(t, e, n, i) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
      this.fromBufferGeometry(new fs(t, e, n, i)),
      this.mergeVertices();
  }
}
class fs extends le {
  constructor(t, e, n, i) {
    super(),
      (this.type = "LatheBufferGeometry"),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
      (e = Math.floor(e) || 12),
      (n = n || 0),
      (i = i || 2 * Math.PI),
      (i = o.clamp(i, 0, 2 * Math.PI));
    const r = [],
      a = [],
      c = [],
      l = 1 / e,
      h = new g(),
      u = new s();
    for (let r = 0; r <= e; r++) {
      const o = n + r * l * i,
        s = Math.sin(o),
        d = Math.cos(o);
      for (let n = 0; n <= t.length - 1; n++)
        (h.x = t[n].x * s),
          (h.y = t[n].y),
          (h.z = t[n].x * d),
          a.push(h.x, h.y, h.z),
          (u.x = r / e),
          (u.y = n / (t.length - 1)),
          c.push(u.x, u.y);
    }
    for (let n = 0; n < e; n++)
      for (let e = 0; e < t.length - 1; e++) {
        const i = e + n * t.length,
          o = i,
          s = i + t.length,
          a = i + t.length + 1,
          c = i + 1;
        r.push(o, s, c), r.push(s, a, c);
      }
    if (
      (this.setIndex(r),
      this.setAttribute("position", new Qt(a, 3)),
      this.setAttribute("uv", new Qt(c, 2)),
      this.computeVertexNormals(),
      i === 2 * Math.PI)
    ) {
      const n = this.attributes.normal.array,
        i = new g(),
        r = new g(),
        o = new g(),
        s = e * t.length * 3;
      for (let e = 0, a = 0; e < t.length; e++, a += 3)
        (i.x = n[a + 0]),
          (i.y = n[a + 1]),
          (i.z = n[a + 2]),
          (r.x = n[s + a + 0]),
          (r.y = n[s + a + 1]),
          (r.z = n[s + a + 2]),
          o.addVectors(i, r).normalize(),
          (n[a + 0] = n[s + a + 0] = o.x),
          (n[a + 1] = n[s + a + 1] = o.y),
          (n[a + 2] = n[s + a + 2] = o.z);
    }
  }
}
class ms extends Ie {
  constructor(t, e) {
    super(),
      (this.type = "ShapeGeometry"),
      "object" == typeof e &&
        (console.warn(
          "THREE.ShapeGeometry: Options parameter has been removed."
        ),
        (e = e.curveSegments)),
      (this.parameters = { shapes: t, curveSegments: e }),
      this.fromBufferGeometry(new gs(t, e)),
      this.mergeVertices();
  }
  toJSON() {
    const t = Ie.prototype.toJSON.call(this);
    return vs(this.parameters.shapes, t);
  }
}
class gs extends le {
  constructor(t, e) {
    super(),
      (this.type = "ShapeBufferGeometry"),
      (this.parameters = { shapes: t, curveSegments: e }),
      (e = e || 12);
    const n = [],
      i = [],
      r = [],
      o = [];
    let s = 0,
      a = 0;
    if (!1 === Array.isArray(t)) c(t);
    else
      for (let e = 0; e < t.length; e++)
        c(t[e]), this.addGroup(s, a, e), (s += a), (a = 0);
    function c(t) {
      const s = i.length / 3,
        c = t.extractPoints(e);
      let l = c.shape;
      const h = c.holes;
      !1 === ts.isClockWise(l) && (l = l.reverse());
      for (let t = 0, e = h.length; t < e; t++) {
        const e = h[t];
        !0 === ts.isClockWise(e) && (h[t] = e.reverse());
      }
      const u = ts.triangulateShape(l, h);
      for (let t = 0, e = h.length; t < e; t++) {
        const e = h[t];
        l = l.concat(e);
      }
      for (let t = 0, e = l.length; t < e; t++) {
        const e = l[t];
        i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y);
      }
      for (let t = 0, e = u.length; t < e; t++) {
        const e = u[t],
          i = e[0] + s,
          r = e[1] + s,
          o = e[2] + s;
        n.push(i, r, o), (a += 3);
      }
    }
    this.setIndex(n),
      this.setAttribute("position", new Qt(i, 3)),
      this.setAttribute("normal", new Qt(r, 3)),
      this.setAttribute("uv", new Qt(o, 2));
  }
  toJSON() {
    const t = le.prototype.toJSON.call(this);
    return vs(this.parameters.shapes, t);
  }
}
function vs(t, e) {
  if (((e.shapes = []), Array.isArray(t)))
    for (let n = 0, i = t.length; n < i; n++) {
      const i = t[n];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(t.uuid);
  return e;
}
class ys extends le {
  constructor(t, e) {
    super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { thresholdAngle: e }),
      (e = void 0 !== e ? e : 1);
    const n = [],
      i = Math.cos(o.DEG2RAD * e),
      r = [0, 0],
      s = {};
    let a, c, l;
    const h = ["a", "b", "c"];
    let u;
    t.isBufferGeometry
      ? ((u = new Ie()), u.fromBufferGeometry(t))
      : (u = t.clone()),
      u.mergeVertices(),
      u.computeFaceNormals();
    const d = u.vertices,
      p = u.faces;
    for (let t = 0, e = p.length; t < e; t++) {
      const e = p[t];
      for (let n = 0; n < 3; n++)
        (a = e[h[n]]),
          (c = e[h[(n + 1) % 3]]),
          (r[0] = Math.min(a, c)),
          (r[1] = Math.max(a, c)),
          (l = r[0] + "," + r[1]),
          void 0 === s[l]
            ? (s[l] = { index1: r[0], index2: r[1], face1: t, face2: void 0 })
            : (s[l].face2 = t);
    }
    for (l in s) {
      const t = s[l];
      if (void 0 === t.face2 || p[t.face1].normal.dot(p[t.face2].normal) <= i) {
        let e = d[t.index1];
        n.push(e.x, e.y, e.z), (e = d[t.index2]), n.push(e.x, e.y, e.z);
      }
    }
    this.setAttribute("position", new Qt(n, 3));
  }
}
class xs extends Ie {
  constructor(t, e, n, i, r, o, s, a) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: i,
        heightSegments: r,
        openEnded: o,
        thetaStart: s,
        thetaLength: a,
      }),
      this.fromBufferGeometry(new bs(t, e, n, i, r, o, s, a)),
      this.mergeVertices();
  }
}
class bs extends le {
  constructor(t, e, n, i, r, o, a, c) {
    super(),
      (this.type = "CylinderBufferGeometry"),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: i,
        heightSegments: r,
        openEnded: o,
        thetaStart: a,
        thetaLength: c,
      });
    const l = this;
    (t = void 0 !== t ? t : 1),
      (e = void 0 !== e ? e : 1),
      (n = n || 1),
      (i = Math.floor(i) || 8),
      (r = Math.floor(r) || 1),
      (o = void 0 !== o && o),
      (a = void 0 !== a ? a : 0),
      (c = void 0 !== c ? c : 2 * Math.PI);
    const h = [],
      u = [],
      d = [],
      p = [];
    let f = 0;
    const m = [],
      v = n / 2;
    let y = 0;
    function x(n) {
      const r = f,
        o = new s(),
        m = new g();
      let x = 0;
      const b = !0 === n ? t : e,
        _ = !0 === n ? 1 : -1;
      for (let t = 1; t <= i; t++)
        u.push(0, v * _, 0), d.push(0, _, 0), p.push(0.5, 0.5), f++;
      const w = f;
      for (let t = 0; t <= i; t++) {
        const e = (t / i) * c + a,
          n = Math.cos(e),
          r = Math.sin(e);
        (m.x = b * r),
          (m.y = v * _),
          (m.z = b * n),
          u.push(m.x, m.y, m.z),
          d.push(0, _, 0),
          (o.x = 0.5 * n + 0.5),
          (o.y = 0.5 * r * _ + 0.5),
          p.push(o.x, o.y),
          f++;
      }
      for (let t = 0; t < i; t++) {
        const e = r + t,
          i = w + t;
        !0 === n ? h.push(i, i + 1, e) : h.push(i + 1, i, e), (x += 3);
      }
      l.addGroup(y, x, !0 === n ? 1 : 2), (y += x);
    }
    !(function () {
      const o = new g(),
        s = new g();
      let x = 0;
      const b = (e - t) / n;
      for (let l = 0; l <= r; l++) {
        const h = [],
          g = l / r,
          y = g * (e - t) + t;
        for (let t = 0; t <= i; t++) {
          const e = t / i,
            r = e * c + a,
            l = Math.sin(r),
            m = Math.cos(r);
          (s.x = y * l),
            (s.y = -g * n + v),
            (s.z = y * m),
            u.push(s.x, s.y, s.z),
            o.set(l, b, m).normalize(),
            d.push(o.x, o.y, o.z),
            p.push(e, 1 - g),
            h.push(f++);
        }
        m.push(h);
      }
      for (let t = 0; t < i; t++)
        for (let e = 0; e < r; e++) {
          const n = m[e][t],
            i = m[e + 1][t],
            r = m[e + 1][t + 1],
            o = m[e][t + 1];
          h.push(n, i, o), h.push(i, r, o), (x += 6);
        }
      l.addGroup(y, x, 0), (y += x);
    })(),
      !1 === o && (t > 0 && x(!0), e > 0 && x(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Qt(u, 3)),
      this.setAttribute("normal", new Qt(d, 3)),
      this.setAttribute("uv", new Qt(p, 2));
  }
}
class _s extends xs {
  constructor(t, e, n, i, r, o, s) {
    super(0, t, e, n, i, r, o, s),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: n,
        heightSegments: i,
        openEnded: r,
        thetaStart: o,
        thetaLength: s,
      });
  }
}
class ws extends bs {
  constructor(t, e, n, i, r, o, s) {
    super(0, t, e, n, i, r, o, s),
      (this.type = "ConeBufferGeometry"),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: n,
        heightSegments: i,
        openEnded: r,
        thetaStart: o,
        thetaLength: s,
      });
  }
}
class Ms extends Ie {
  constructor(t, e, n, i) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: t,
        segments: e,
        thetaStart: n,
        thetaLength: i,
      }),
      this.fromBufferGeometry(new Ss(t, e, n, i)),
      this.mergeVertices();
  }
}
class Ss extends le {
  constructor(t, e, n, i) {
    super(),
      (this.type = "CircleBufferGeometry"),
      (this.parameters = {
        radius: t,
        segments: e,
        thetaStart: n,
        thetaLength: i,
      }),
      (t = t || 1),
      (e = void 0 !== e ? Math.max(3, e) : 8),
      (n = void 0 !== n ? n : 0),
      (i = void 0 !== i ? i : 2 * Math.PI);
    const r = [],
      o = [],
      a = [],
      c = [],
      l = new g(),
      h = new s();
    o.push(0, 0, 0), a.push(0, 0, 1), c.push(0.5, 0.5);
    for (let r = 0, s = 3; r <= e; r++, s += 3) {
      const u = n + (r / e) * i;
      (l.x = t * Math.cos(u)),
        (l.y = t * Math.sin(u)),
        o.push(l.x, l.y, l.z),
        a.push(0, 0, 1),
        (h.x = (o[s] / t + 1) / 2),
        (h.y = (o[s + 1] / t + 1) / 2),
        c.push(h.x, h.y);
    }
    for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
    this.setIndex(r),
      this.setAttribute("position", new Qt(o, 3)),
      this.setAttribute("normal", new Qt(a, 3)),
      this.setAttribute("uv", new Qt(c, 2));
  }
}
var Ts = Object.freeze({
  __proto__: null,
  WireframeGeometry: lo,
  ParametricGeometry: ho,
  ParametricBufferGeometry: uo,
  TetrahedronGeometry: mo,
  TetrahedronBufferGeometry: go,
  OctahedronGeometry: vo,
  OctahedronBufferGeometry: yo,
  IcosahedronGeometry: xo,
  IcosahedronBufferGeometry: bo,
  DodecahedronGeometry: _o,
  DodecahedronBufferGeometry: wo,
  PolyhedronGeometry: po,
  PolyhedronBufferGeometry: fo,
  TubeGeometry: Mo,
  TubeBufferGeometry: So,
  TorusKnotGeometry: To,
  TorusKnotBufferGeometry: Eo,
  TorusGeometry: Ao,
  TorusBufferGeometry: Lo,
  TextGeometry: as,
  TextBufferGeometry: cs,
  SphereGeometry: ls,
  SphereBufferGeometry: hs,
  RingGeometry: us,
  RingBufferGeometry: ds,
  PlaneGeometry: Ke,
  PlaneBufferGeometry: Qe,
  LatheGeometry: ps,
  LatheBufferGeometry: fs,
  ShapeGeometry: ms,
  ShapeBufferGeometry: gs,
  ExtrudeGeometry: is,
  ExtrudeBufferGeometry: rs,
  EdgesGeometry: ys,
  ConeGeometry: _s,
  ConeBufferGeometry: ws,
  CylinderGeometry: xs,
  CylinderBufferGeometry: bs,
  CircleGeometry: Ms,
  CircleBufferGeometry: Ss,
  BoxGeometry: De,
  BoxBufferGeometry: Be,
});
function Es(t) {
  Gt.call(this),
    (this.type = "ShadowMaterial"),
    (this.color = new zt(0)),
    (this.transparent = !0),
    this.setValues(t);
}
function As(t) {
  Ge.call(this, t), (this.type = "RawShaderMaterial");
}
function Ls(t) {
  Gt.call(this),
    (this.defines = { STANDARD: "" }),
    (this.type = "MeshStandardMaterial"),
    (this.color = new zt(16777215)),
    (this.roughness = 1),
    (this.metalness = 0),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new zt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = 0),
    (this.normalScale = new s(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.roughnessMap = null),
    (this.metalnessMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.envMapIntensity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    (this.vertexTangents = !1),
    this.setValues(t);
}
function Rs(t) {
  Ls.call(this),
    (this.defines = { STANDARD: "", PHYSICAL: "" }),
    (this.type = "MeshPhysicalMaterial"),
    (this.clearcoat = 0),
    (this.clearcoatMap = null),
    (this.clearcoatRoughness = 0),
    (this.clearcoatRoughnessMap = null),
    (this.clearcoatNormalScale = new s(1, 1)),
    (this.clearcoatNormalMap = null),
    (this.reflectivity = 0.5),
    (this.sheen = null),
    (this.transmission = 0),
    (this.transmissionMap = null),
    this.setValues(t);
}
function Ps(t) {
  Gt.call(this),
    (this.type = "MeshPhongMaterial"),
    (this.color = new zt(16777215)),
    (this.specular = new zt(1118481)),
    (this.shininess = 30),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new zt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = 0),
    (this.normalScale = new s(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.specularMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.combine = 0),
    (this.reflectivity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
function Cs(t) {
  Gt.call(this),
    (this.defines = { TOON: "" }),
    (this.type = "MeshToonMaterial"),
    (this.color = new zt(16777215)),
    (this.map = null),
    (this.gradientMap = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new zt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = 0),
    (this.normalScale = new s(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.alphaMap = null),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
function Os(t) {
  Gt.call(this),
    (this.type = "MeshNormalMaterial"),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = 0),
    (this.normalScale = new s(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.fog = !1),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
function Ns(t) {
  Gt.call(this),
    (this.type = "MeshLambertMaterial"),
    (this.color = new zt(16777215)),
    (this.map = null),
    (this.lightMap = null),
    (this.lightMapIntensity = 1),
    (this.aoMap = null),
    (this.aoMapIntensity = 1),
    (this.emissive = new zt(0)),
    (this.emissiveIntensity = 1),
    (this.emissiveMap = null),
    (this.specularMap = null),
    (this.alphaMap = null),
    (this.envMap = null),
    (this.combine = 0),
    (this.reflectivity = 1),
    (this.refractionRatio = 0.98),
    (this.wireframe = !1),
    (this.wireframeLinewidth = 1),
    (this.wireframeLinecap = "round"),
    (this.wireframeLinejoin = "round"),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
function Is(t) {
  Gt.call(this),
    (this.defines = { MATCAP: "" }),
    (this.type = "MeshMatcapMaterial"),
    (this.color = new zt(16777215)),
    (this.matcap = null),
    (this.map = null),
    (this.bumpMap = null),
    (this.bumpScale = 1),
    (this.normalMap = null),
    (this.normalMapType = 0),
    (this.normalScale = new s(1, 1)),
    (this.displacementMap = null),
    (this.displacementScale = 1),
    (this.displacementBias = 0),
    (this.alphaMap = null),
    (this.skinning = !1),
    (this.morphTargets = !1),
    (this.morphNormals = !1),
    this.setValues(t);
}
function Ds(t) {
  Hr.call(this),
    (this.type = "LineDashedMaterial"),
    (this.scale = 1),
    (this.dashSize = 3),
    (this.gapSize = 1),
    this.setValues(t);
}
(Es.prototype = Object.create(Gt.prototype)),
  (Es.prototype.constructor = Es),
  (Es.prototype.isShadowMaterial = !0),
  (Es.prototype.copy = function (t) {
    return Gt.prototype.copy.call(this, t), this.color.copy(t.color), this;
  }),
  (As.prototype = Object.create(Ge.prototype)),
  (As.prototype.constructor = As),
  (As.prototype.isRawShaderMaterial = !0),
  (Ls.prototype = Object.create(Gt.prototype)),
  (Ls.prototype.constructor = Ls),
  (Ls.prototype.isMeshStandardMaterial = !0),
  (Ls.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      (this.defines = { STANDARD: "" }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.envMapIntensity = t.envMapIntensity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      (this.vertexTangents = t.vertexTangents),
      this
    );
  }),
  (Rs.prototype = Object.create(Ls.prototype)),
  (Rs.prototype.constructor = Rs),
  (Rs.prototype.isMeshPhysicalMaterial = !0),
  (Rs.prototype.copy = function (t) {
    return (
      Ls.prototype.copy.call(this, t),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = t.clearcoat),
      (this.clearcoatMap = t.clearcoatMap),
      (this.clearcoatRoughness = t.clearcoatRoughness),
      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = t.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
      (this.reflectivity = t.reflectivity),
      t.sheen
        ? (this.sheen = (this.sheen || new zt()).copy(t.sheen))
        : (this.sheen = null),
      (this.transmission = t.transmission),
      (this.transmissionMap = t.transmissionMap),
      this
    );
  }),
  (Ps.prototype = Object.create(Gt.prototype)),
  (Ps.prototype.constructor = Ps),
  (Ps.prototype.isMeshPhongMaterial = !0),
  (Ps.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      this.specular.copy(t.specular),
      (this.shininess = t.shininess),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      this
    );
  }),
  (Cs.prototype = Object.create(Gt.prototype)),
  (Cs.prototype.constructor = Cs),
  (Cs.prototype.isMeshToonMaterial = !0),
  (Cs.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.gradientMap = t.gradientMap),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      this
    );
  }),
  (Os.prototype = Object.create(Gt.prototype)),
  (Os.prototype.constructor = Os),
  (Os.prototype.isMeshNormalMaterial = !0),
  (Os.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      this
    );
  }),
  (Ns.prototype = Object.create(Gt.prototype)),
  (Ns.prototype.constructor = Ns),
  (Ns.prototype.isMeshLambertMaterial = !0),
  (Ns.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      this
    );
  }),
  (Is.prototype = Object.create(Gt.prototype)),
  (Is.prototype.constructor = Is),
  (Is.prototype.isMeshMatcapMaterial = !0),
  (Is.prototype.copy = function (t) {
    return (
      Gt.prototype.copy.call(this, t),
      (this.defines = { MATCAP: "" }),
      this.color.copy(t.color),
      (this.matcap = t.matcap),
      (this.map = t.map),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.skinning = t.skinning),
      (this.morphTargets = t.morphTargets),
      (this.morphNormals = t.morphNormals),
      this
    );
  }),
  (Ds.prototype = Object.create(Hr.prototype)),
  (Ds.prototype.constructor = Ds),
  (Ds.prototype.isLineDashedMaterial = !0),
  (Ds.prototype.copy = function (t) {
    return (
      Hr.prototype.copy.call(this, t),
      (this.scale = t.scale),
      (this.dashSize = t.dashSize),
      (this.gapSize = t.gapSize),
      this
    );
  });
var Bs = Object.freeze({
  __proto__: null,
  ShadowMaterial: Es,
  SpriteMaterial: dr,
  RawShaderMaterial: As,
  ShaderMaterial: Ge,
  PointsMaterial: Qr,
  MeshPhysicalMaterial: Rs,
  MeshStandardMaterial: Ls,
  MeshPhongMaterial: Ps,
  MeshToonMaterial: Cs,
  MeshNormalMaterial: Os,
  MeshLambertMaterial: Ns,
  MeshDepthMaterial: Xi,
  MeshDistanceMaterial: Yi,
  MeshBasicMaterial: Ht,
  MeshMatcapMaterial: Is,
  LineDashedMaterial: Ds,
  LineBasicMaterial: Hr,
  Material: Gt,
});
const zs = {
  arraySlice: function (t, e, n) {
    return zs.isTypedArray(t)
      ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
      : t.slice(e, n);
  },
  convertArray: function (t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : "number" == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t);
  },
  isTypedArray: function (t) {
    return ArrayBuffer.isView(t) && !(t instanceof DataView);
  },
  getKeyframeOrder: function (t) {
    const e = t.length,
      n = new Array(e);
    for (let t = 0; t !== e; ++t) n[t] = t;
    return (
      n.sort(function (e, n) {
        return t[e] - t[n];
      }),
      n
    );
  },
  sortedArray: function (t, e, n) {
    const i = t.length,
      r = new t.constructor(i);
    for (let o = 0, s = 0; s !== i; ++o) {
      const i = n[o] * e;
      for (let n = 0; n !== e; ++n) r[s++] = t[i + n];
    }
    return r;
  },
  flattenJSON: function (t, e, n, i) {
    let r = 1,
      o = t[0];
    for (; void 0 !== o && void 0 === o[i]; ) o = t[r++];
    if (void 0 === o) return;
    let s = o[i];
    if (void 0 !== s)
      if (Array.isArray(s))
        do {
          (s = o[i]),
            void 0 !== s && (e.push(o.time), n.push.apply(n, s)),
            (o = t[r++]);
        } while (void 0 !== o);
      else if (void 0 !== s.toArray)
        do {
          (s = o[i]),
            void 0 !== s && (e.push(o.time), s.toArray(n, n.length)),
            (o = t[r++]);
        } while (void 0 !== o);
      else
        do {
          (s = o[i]), void 0 !== s && (e.push(o.time), n.push(s)), (o = t[r++]);
        } while (void 0 !== o);
  },
  subclip: function (t, e, n, i, r) {
    r = r || 30;
    const o = t.clone();
    o.name = e;
    const s = [];
    for (let t = 0; t < o.tracks.length; ++t) {
      const e = o.tracks[t],
        a = e.getValueSize(),
        c = [],
        l = [];
      for (let t = 0; t < e.times.length; ++t) {
        const o = e.times[t] * r;
        if (!(o < n || o >= i)) {
          c.push(e.times[t]);
          for (let n = 0; n < a; ++n) l.push(e.values[t * a + n]);
        }
      }
      0 !== c.length &&
        ((e.times = zs.convertArray(c, e.times.constructor)),
        (e.values = zs.convertArray(l, e.values.constructor)),
        s.push(e));
    }
    o.tracks = s;
    let a = 1 / 0;
    for (let t = 0; t < o.tracks.length; ++t)
      a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
    for (let t = 0; t < o.tracks.length; ++t) o.tracks[t].shift(-1 * a);
    return o.resetDuration(), o;
  },
  makeClipAdditive: function (t, e, n, i) {
    void 0 === e && (e = 0),
      void 0 === n && (n = t),
      (void 0 === i || i <= 0) && (i = 30);
    const r = t.tracks.length,
      o = e / i;
    for (let e = 0; e < r; ++e) {
      const i = n.tracks[e],
        r = i.ValueTypeName;
      if ("bool" === r || "string" === r) continue;
      const s = t.tracks.find(function (t) {
        return t.name === i.name && t.ValueTypeName === r;
      });
      if (void 0 === s) continue;
      let a = 0;
      const c = i.getValueSize();
      i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (a = c / 3);
      let l = 0;
      const h = s.getValueSize();
      s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (l = h / 3);
      const u = i.times.length - 1;
      let d;
      if (o <= i.times[0]) {
        const t = a,
          e = c - a;
        d = zs.arraySlice(i.values, t, e);
      } else if (o >= i.times[u]) {
        const t = u * c + a,
          e = t + c - a;
        d = zs.arraySlice(i.values, t, e);
      } else {
        const t = i.createInterpolant(),
          e = a,
          n = c - a;
        t.evaluate(o), (d = zs.arraySlice(t.resultBuffer, e, n));
      }
      if ("quaternion" === r) {
        new m().fromArray(d).normalize().conjugate().toArray(d);
      }
      const p = s.times.length;
      for (let t = 0; t < p; ++t) {
        const e = t * h + l;
        if ("quaternion" === r)
          m.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e);
        else {
          const t = h - 2 * l;
          for (let n = 0; n < t; ++n) s.values[e + n] -= d[n];
        }
      }
    }
    return (t.blendMode = 2501), t;
  },
};
function Fs(t, e, n, i) {
  (this.parameterPositions = t),
    (this._cachedIndex = 0),
    (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
    (this.sampleValues = e),
    (this.valueSize = n);
}
function Us(t, e, n, i) {
  Fs.call(this, t, e, n, i),
    (this._weightPrev = -0),
    (this._offsetPrev = -0),
    (this._weightNext = -0),
    (this._offsetNext = -0);
}
function Gs(t, e, n, i) {
  Fs.call(this, t, e, n, i);
}
function Hs(t, e, n, i) {
  Fs.call(this, t, e, n, i);
}
function ks(t, e, n, i) {
  if (void 0 === t)
    throw new Error("THREE.KeyframeTrack: track name is undefined");
  if (void 0 === e || 0 === e.length)
    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
  (this.name = t),
    (this.times = zs.convertArray(e, this.TimeBufferType)),
    (this.values = zs.convertArray(n, this.ValueBufferType)),
    this.setInterpolation(i || this.DefaultInterpolation);
}
function Vs(t, e, n) {
  ks.call(this, t, e, n);
}
function js(t, e, n, i) {
  ks.call(this, t, e, n, i);
}
function Ws(t, e, n, i) {
  ks.call(this, t, e, n, i);
}
function qs(t, e, n, i) {
  Fs.call(this, t, e, n, i);
}
function Xs(t, e, n, i) {
  ks.call(this, t, e, n, i);
}
function Ys(t, e, n, i) {
  ks.call(this, t, e, n, i);
}
function Zs(t, e, n, i) {
  ks.call(this, t, e, n, i);
}
function Js(t, e, n, i) {
  (this.name = t),
    (this.tracks = n),
    (this.duration = void 0 !== e ? e : -1),
    (this.blendMode = void 0 !== i ? i : 2500),
    (this.uuid = o.generateUUID()),
    this.duration < 0 && this.resetDuration();
}
function Ks(t) {
  if (void 0 === t.type)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = (function (t) {
    switch (t.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Ws;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Zs;
      case "color":
        return js;
      case "quaternion":
        return Xs;
      case "bool":
      case "boolean":
        return Vs;
      case "string":
        return Ys;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
  })(t.type);
  if (void 0 === t.times) {
    const e = [],
      n = [];
    zs.flattenJSON(t.keys, e, n, "value"), (t.times = e), (t.values = n);
  }
  return void 0 !== e.parse
    ? e.parse(t)
    : new e(t.name, t.times, t.values, t.interpolation);
}
Object.assign(Fs.prototype, {
  evaluate: function (t) {
    const e = this.parameterPositions;
    let n = this._cachedIndex,
      i = e[n],
      r = e[n - 1];
    t: {
      e: {
        let o;
        n: {
          i: if (!(t < i)) {
            for (let o = n + 2; ; ) {
              if (void 0 === i) {
                if (t < r) break i;
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, t, r)
                );
              }
              if (n === o) break;
              if (((r = i), (i = e[++n]), t < i)) break e;
            }
            o = e.length;
            break n;
          }
          if (t >= r) break t;
          {
            const s = e[1];
            t < s && ((n = 2), (r = s));
            for (let o = n - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
              if (n === o) break;
              if (((i = r), (r = e[--n - 1]), t >= r)) break e;
            }
            (o = n), (n = 0);
          }
        }
        for (; n < o; ) {
          const i = (n + o) >>> 1;
          t < e[i] ? (o = i) : (n = i + 1);
        }
        if (((i = e[n]), (r = e[n - 1]), void 0 === r))
          return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
        if (void 0 === i)
          return (
            (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, t)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, t, i);
  },
  settings: null,
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = t * i;
    for (let t = 0; t !== i; ++t) e[t] = n[r + t];
    return e;
  },
  interpolate_: function () {
    throw new Error("call to abstract method");
  },
  intervalChanged_: function () {},
}),
  Object.assign(Fs.prototype, {
    beforeStart_: Fs.prototype.copySampleValue_,
    afterEnd_: Fs.prototype.copySampleValue_,
  }),
  (Us.prototype = Object.assign(Object.create(Fs.prototype), {
    constructor: Us,
    DefaultSettings_: { endingStart: 2400, endingEnd: 2400 },
    intervalChanged_: function (t, e, n) {
      const i = this.parameterPositions;
      let r = t - 2,
        o = t + 1,
        s = i[r],
        a = i[o];
      if (void 0 === s)
        switch (this.getSettings_().endingStart) {
          case 2401:
            (r = t), (s = 2 * e - n);
            break;
          case 2402:
            (r = i.length - 2), (s = e + i[r] - i[r + 1]);
            break;
          default:
            (r = t), (s = n);
        }
      if (void 0 === a)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            (o = t), (a = 2 * n - e);
            break;
          case 2402:
            (o = 1), (a = n + i[1] - i[0]);
            break;
          default:
            (o = t - 1), (a = e);
        }
      const c = 0.5 * (n - e),
        l = this.valueSize;
      (this._weightPrev = c / (e - s)),
        (this._weightNext = c / (a - n)),
        (this._offsetPrev = r * l),
        (this._offsetNext = o * l);
    },
    interpolate_: function (t, e, n, i) {
      const r = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = t * s,
        c = a - s,
        l = this._offsetPrev,
        h = this._offsetNext,
        u = this._weightPrev,
        d = this._weightNext,
        p = (n - e) / (i - e),
        f = p * p,
        m = f * p,
        g = -u * m + 2 * u * f - u * p,
        v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
        y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        x = d * m - d * f;
      for (let t = 0; t !== s; ++t)
        r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + x * o[h + t];
      return r;
    },
  })),
  (Gs.prototype = Object.assign(Object.create(Fs.prototype), {
    constructor: Gs,
    interpolate_: function (t, e, n, i) {
      const r = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = t * s,
        c = a - s,
        l = (n - e) / (i - e),
        h = 1 - l;
      for (let t = 0; t !== s; ++t) r[t] = o[c + t] * h + o[a + t] * l;
      return r;
    },
  })),
  (Hs.prototype = Object.assign(Object.create(Fs.prototype), {
    constructor: Hs,
    interpolate_: function (t) {
      return this.copySampleValue_(t - 1);
    },
  })),
  Object.assign(ks, {
    toJSON: function (t) {
      const e = t.constructor;
      let n;
      if (void 0 !== e.toJSON) n = e.toJSON(t);
      else {
        n = {
          name: t.name,
          times: zs.convertArray(t.times, Array),
          values: zs.convertArray(t.values, Array),
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (n.interpolation = e);
      }
      return (n.type = t.ValueTypeName), n;
    },
  }),
  Object.assign(ks.prototype, {
    constructor: ks,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodDiscrete: function (t) {
      return new Hs(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodLinear: function (t) {
      return new Gs(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: function (t) {
      return new Us(this.times, this.values, this.getValueSize(), t);
    },
    setInterpolation: function (t) {
      let e;
      switch (t) {
        case 2300:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case 2301:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case 2302:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        const e =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return (this.createInterpolant = e), this;
    },
    getInterpolation: function () {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return 2300;
        case this.InterpolantFactoryMethodLinear:
          return 2301;
        case this.InterpolantFactoryMethodSmooth:
          return 2302;
      }
    },
    getValueSize: function () {
      return this.values.length / this.times.length;
    },
    shift: function (t) {
      if (0 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
      }
      return this;
    },
    scale: function (t) {
      if (1 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
      }
      return this;
    },
    trim: function (t, e) {
      const n = this.times,
        i = n.length;
      let r = 0,
        o = i - 1;
      for (; r !== i && n[r] < t; ) ++r;
      for (; -1 !== o && n[o] > e; ) --o;
      if ((++o, 0 !== r || o !== i)) {
        r >= o && ((o = Math.max(o, 1)), (r = o - 1));
        const t = this.getValueSize();
        (this.times = zs.arraySlice(n, r, o)),
          (this.values = zs.arraySlice(this.values, r * t, o * t));
      }
      return this;
    },
    validate: function () {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (t = !1));
      const n = this.times,
        i = this.values,
        r = n.length;
      0 === r &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
      let o = null;
      for (let e = 0; e !== r; e++) {
        const i = n[e];
        if ("number" == typeof i && isNaN(i)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            e,
            i
          ),
            (t = !1);
          break;
        }
        if (null !== o && o > i) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            e,
            i,
            o
          ),
            (t = !1);
          break;
        }
        o = i;
      }
      if (void 0 !== i && zs.isTypedArray(i))
        for (let e = 0, n = i.length; e !== n; ++e) {
          const n = i[e];
          if (isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              e,
              n
            ),
              (t = !1);
            break;
          }
        }
      return t;
    },
    optimize: function () {
      const t = zs.arraySlice(this.times),
        e = zs.arraySlice(this.values),
        n = this.getValueSize(),
        i = 2302 === this.getInterpolation(),
        r = t.length - 1;
      let o = 1;
      for (let s = 1; s < r; ++s) {
        let r = !1;
        const a = t[s];
        if (a !== t[s + 1] && (1 !== s || a !== a[0]))
          if (i) r = !0;
          else {
            const t = s * n,
              i = t - n,
              o = t + n;
            for (let s = 0; s !== n; ++s) {
              const n = e[t + s];
              if (n !== e[i + s] || n !== e[o + s]) {
                r = !0;
                break;
              }
            }
          }
        if (r) {
          if (s !== o) {
            t[o] = t[s];
            const i = s * n,
              r = o * n;
            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
          }
          ++o;
        }
      }
      if (r > 0) {
        t[o] = t[r];
        for (let t = r * n, i = o * n, s = 0; s !== n; ++s) e[i + s] = e[t + s];
        ++o;
      }
      return (
        o !== t.length
          ? ((this.times = zs.arraySlice(t, 0, o)),
            (this.values = zs.arraySlice(e, 0, o * n)))
          : ((this.times = t), (this.values = e)),
        this
      );
    },
    clone: function () {
      const t = zs.arraySlice(this.times, 0),
        e = zs.arraySlice(this.values, 0),
        n = new (0, this.constructor)(this.name, t, e);
      return (n.createInterpolant = this.createInterpolant), n;
    },
  }),
  (Vs.prototype = Object.assign(Object.create(ks.prototype), {
    constructor: Vs,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0,
  })),
  (js.prototype = Object.assign(Object.create(ks.prototype), {
    constructor: js,
    ValueTypeName: "color",
  })),
  (Ws.prototype = Object.assign(Object.create(ks.prototype), {
    constructor: Ws,
    ValueTypeName: "number",
  })),
  (qs.prototype = Object.assign(Object.create(Fs.prototype), {
    constructor: qs,
    interpolate_: function (t, e, n, i) {
      const r = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = (n - e) / (i - e);
      let c = t * s;
      for (let t = c + s; c !== t; c += 4) m.slerpFlat(r, 0, o, c - s, o, c, a);
      return r;
    },
  })),
  (Xs.prototype = Object.assign(Object.create(ks.prototype), {
    constructor: Xs,
    ValueTypeName: "quaternion",
    DefaultInterpolation: 2301,
    InterpolantFactoryMethodLinear: function (t) {
      return new qs(this.times, this.values, this.getValueSize(), t);
    },
    InterpolantFactoryMethodSmooth: void 0,
  })),
  (Ys.prototype = Object.assign(Object.create(ks.prototype), {
    constructor: Ys,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0,
  })),
  (Zs.prototype = Object.assign(Object.create(ks.prototype), {
    constructor: Zs,
    ValueTypeName: "vector",
  })),
  Object.assign(Js, {
    parse: function (t) {
      const e = [],
        n = t.tracks,
        i = 1 / (t.fps || 1);
      for (let t = 0, r = n.length; t !== r; ++t) e.push(Ks(n[t]).scale(i));
      return new Js(t.name, t.duration, e, t.blendMode);
    },
    toJSON: function (t) {
      const e = [],
        n = t.tracks,
        i = {
          name: t.name,
          duration: t.duration,
          tracks: e,
          uuid: t.uuid,
          blendMode: t.blendMode,
        };
      for (let t = 0, i = n.length; t !== i; ++t) e.push(ks.toJSON(n[t]));
      return i;
    },
    CreateFromMorphTargetSequence: function (t, e, n, i) {
      const r = e.length,
        o = [];
      for (let t = 0; t < r; t++) {
        let s = [],
          a = [];
        s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
        const c = zs.getKeyframeOrder(s);
        (s = zs.sortedArray(s, 1, c)),
          (a = zs.sortedArray(a, 1, c)),
          i || 0 !== s[0] || (s.push(r), a.push(a[0])),
          o.push(
            new Ws(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(
              1 / n
            )
          );
      }
      return new Js(t, -1, o);
    },
    findByName: function (t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        const e = t;
        n = (e.geometry && e.geometry.animations) || e.animations;
      }
      for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
      return null;
    },
    CreateClipsFromMorphTargetSequences: function (t, e, n) {
      const i = {},
        r = /^([\w-]*?)([\d]+)$/;
      for (let e = 0, n = t.length; e < n; e++) {
        const n = t[e],
          o = n.name.match(r);
        if (o && o.length > 1) {
          const t = o[1];
          let e = i[t];
          e || (i[t] = e = []), e.push(n);
        }
      }
      const o = [];
      for (const t in i)
        o.push(Js.CreateFromMorphTargetSequence(t, i[t], e, n));
      return o;
    },
    parseAnimation: function (t, e) {
      if (!t)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      const n = function (t, e, n, i, r) {
          if (0 !== n.length) {
            const o = [],
              s = [];
            zs.flattenJSON(n, o, s, i),
              0 !== o.length && r.push(new t(e, o, s));
          }
        },
        i = [],
        r = t.name || "default",
        o = t.fps || 30,
        s = t.blendMode;
      let a = t.length || -1;
      const c = t.hierarchy || [];
      for (let t = 0; t < c.length; t++) {
        const r = c[t].keys;
        if (r && 0 !== r.length)
          if (r[0].morphTargets) {
            const t = {};
            let e;
            for (e = 0; e < r.length; e++)
              if (r[e].morphTargets)
                for (let n = 0; n < r[e].morphTargets.length; n++)
                  t[r[e].morphTargets[n]] = -1;
            for (const n in t) {
              const t = [],
                o = [];
              for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                const i = r[e];
                t.push(i.time), o.push(i.morphTarget === n ? 1 : 0);
              }
              i.push(new Ws(".morphTargetInfluence[" + n + "]", t, o));
            }
            a = t.length * (o || 1);
          } else {
            const o = ".bones[" + e[t].name + "]";
            n(Zs, o + ".position", r, "pos", i),
              n(Xs, o + ".quaternion", r, "rot", i),
              n(Zs, o + ".scale", r, "scl", i);
          }
      }
      if (0 === i.length) return null;
      return new Js(r, a, i, s);
    },
  }),
  Object.assign(Js.prototype, {
    resetDuration: function () {
      let t = 0;
      for (let e = 0, n = this.tracks.length; e !== n; ++e) {
        const n = this.tracks[e];
        t = Math.max(t, n.times[n.times.length - 1]);
      }
      return (this.duration = t), this;
    },
    trim: function () {
      for (let t = 0; t < this.tracks.length; t++)
        this.tracks[t].trim(0, this.duration);
      return this;
    },
    validate: function () {
      let t = !0;
      for (let e = 0; e < this.tracks.length; e++)
        t = t && this.tracks[e].validate();
      return t;
    },
    optimize: function () {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    },
    clone: function () {
      const t = [];
      for (let e = 0; e < this.tracks.length; e++)
        t.push(this.tracks[e].clone());
      return new Js(this.name, this.duration, t, this.blendMode);
    },
  });
const Qs = {
  enabled: !1,
  files: {},
  add: function (t, e) {
    !1 !== this.enabled && (this.files[t] = e);
  },
  get: function (t) {
    if (!1 !== this.enabled) return this.files[t];
  },
  remove: function (t) {
    delete this.files[t];
  },
  clear: function () {
    this.files = {};
  },
};
function $s(t, e, n) {
  const i = this;
  let r,
    o = !1,
    s = 0,
    a = 0;
  const c = [];
  (this.onStart = void 0),
    (this.onLoad = t),
    (this.onProgress = e),
    (this.onError = n),
    (this.itemStart = function (t) {
      a++, !1 === o && void 0 !== i.onStart && i.onStart(t, s, a), (o = !0);
    }),
    (this.itemEnd = function (t) {
      s++,
        void 0 !== i.onProgress && i.onProgress(t, s, a),
        s === a && ((o = !1), void 0 !== i.onLoad && i.onLoad());
    }),
    (this.itemError = function (t) {
      void 0 !== i.onError && i.onError(t);
    }),
    (this.resolveURL = function (t) {
      return r ? r(t) : t;
    }),
    (this.setURLModifier = function (t) {
      return (r = t), this;
    }),
    (this.addHandler = function (t, e) {
      return c.push(t, e), this;
    }),
    (this.removeHandler = function (t) {
      const e = c.indexOf(t);
      return -1 !== e && c.splice(e, 2), this;
    }),
    (this.getHandler = function (t) {
      for (let e = 0, n = c.length; e < n; e += 2) {
        const n = c[e],
          i = c[e + 1];
        if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
      }
      return null;
    });
}
const ta = new $s();
function ea(t) {
  (this.manager = void 0 !== t ? t : ta),
    (this.crossOrigin = "anonymous"),
    (this.path = ""),
    (this.resourcePath = ""),
    (this.requestHeader = {});
}
Object.assign(ea.prototype, {
  load: function () {},
  loadAsync: function (t, e) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(t, i, e, r);
    });
  },
  parse: function () {},
  setCrossOrigin: function (t) {
    return (this.crossOrigin = t), this;
  },
  setPath: function (t) {
    return (this.path = t), this;
  },
  setResourcePath: function (t) {
    return (this.resourcePath = t), this;
  },
  setRequestHeader: function (t) {
    return (this.requestHeader = t), this;
  },
});
const na = {};
function ia(t) {
  ea.call(this, t);
}
function ra(t) {
  ea.call(this, t);
}
function oa(t) {
  ea.call(this, t);
}
function sa(t) {
  ea.call(this, t);
}
function aa(t) {
  ea.call(this, t);
}
function ca(t) {
  ea.call(this, t);
}
function la(t) {
  ea.call(this, t);
}
function ha() {
  (this.type = "Curve"), (this.arcLengthDivisions = 200);
}
function ua(t, e, n, i, r, o, s, a) {
  ha.call(this),
    (this.type = "EllipseCurve"),
    (this.aX = t || 0),
    (this.aY = e || 0),
    (this.xRadius = n || 1),
    (this.yRadius = i || 1),
    (this.aStartAngle = r || 0),
    (this.aEndAngle = o || 2 * Math.PI),
    (this.aClockwise = s || !1),
    (this.aRotation = a || 0);
}
function da(t, e, n, i, r, o) {
  ua.call(this, t, e, n, n, i, r, o), (this.type = "ArcCurve");
}
function pa() {
  let t = 0,
    e = 0,
    n = 0,
    i = 0;
  function r(r, o, s, a) {
    (t = r),
      (e = s),
      (n = -3 * r + 3 * o - 2 * s - a),
      (i = 2 * r - 2 * o + s + a);
  }
  return {
    initCatmullRom: function (t, e, n, i, o) {
      r(e, n, o * (n - t), o * (i - e));
    },
    initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
      let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
        l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
      (c *= s), (l *= s), r(e, n, c, l);
    },
    calc: function (r) {
      const o = r * r;
      return t + e * r + n * o + i * (o * r);
    },
  };
}
(ia.prototype = Object.assign(Object.create(ea.prototype), {
  constructor: ia,
  load: function (t, e, n, i) {
    void 0 === t && (t = ""),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      o = Qs.get(t);
    if (void 0 !== o)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0),
        o
      );
    if (void 0 !== na[t])
      return void na[t].push({ onLoad: e, onProgress: n, onError: i });
    const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
    let a;
    if (s) {
      const n = s[1],
        o = !!s[2];
      let a = s[3];
      (a = decodeURIComponent(a)), o && (a = atob(a));
      try {
        let i;
        const o = (this.responseType || "").toLowerCase();
        switch (o) {
          case "arraybuffer":
          case "blob":
            const t = new Uint8Array(a.length);
            for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
            i = "blob" === o ? new Blob([t.buffer], { type: n }) : t.buffer;
            break;
          case "document":
            const e = new DOMParser();
            i = e.parseFromString(a, n);
            break;
          case "json":
            i = JSON.parse(a);
            break;
          default:
            i = a;
        }
        setTimeout(function () {
          e && e(i), r.manager.itemEnd(t);
        }, 0);
      } catch (e) {
        setTimeout(function () {
          i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
        }, 0);
      }
    } else {
      (na[t] = []),
        na[t].push({ onLoad: e, onProgress: n, onError: i }),
        (a = new XMLHttpRequest()),
        a.open("GET", t, !0),
        a.addEventListener(
          "load",
          function (e) {
            const n = this.response,
              i = na[t];
            if ((delete na[t], 200 === this.status || 0 === this.status)) {
              0 === this.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
                Qs.add(t, n);
              for (let t = 0, e = i.length; t < e; t++) {
                const e = i[t];
                e.onLoad && e.onLoad(n);
              }
              r.manager.itemEnd(t);
            } else {
              for (let t = 0, n = i.length; t < n; t++) {
                const n = i[t];
                n.onError && n.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            }
          },
          !1
        ),
        a.addEventListener(
          "progress",
          function (e) {
            const n = na[t];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              i.onProgress && i.onProgress(e);
            }
          },
          !1
        ),
        a.addEventListener(
          "error",
          function (e) {
            const n = na[t];
            delete na[t];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              i.onError && i.onError(e);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          },
          !1
        ),
        a.addEventListener(
          "abort",
          function (e) {
            const n = na[t];
            delete na[t];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              i.onError && i.onError(e);
            }
            r.manager.itemError(t), r.manager.itemEnd(t);
          },
          !1
        ),
        void 0 !== this.responseType && (a.responseType = this.responseType),
        void 0 !== this.withCredentials &&
          (a.withCredentials = this.withCredentials),
        a.overrideMimeType &&
          a.overrideMimeType(
            void 0 !== this.mimeType ? this.mimeType : "text/plain"
          );
      for (const t in this.requestHeader)
        a.setRequestHeader(t, this.requestHeader[t]);
      a.send(null);
    }
    return r.manager.itemStart(t), a;
  },
  setResponseType: function (t) {
    return (this.responseType = t), this;
  },
  setWithCredentials: function (t) {
    return (this.withCredentials = t), this;
  },
  setMimeType: function (t) {
    return (this.mimeType = t), this;
  },
})),
  (ra.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: ra,
    load: function (t, e, n, i) {
      const r = this,
        o = new ia(r.manager);
      o.setPath(r.path),
        o.setRequestHeader(r.requestHeader),
        o.load(
          t,
          function (n) {
            try {
              e(r.parse(JSON.parse(n)));
            } catch (e) {
              i ? i(e) : console.error(e), r.manager.itemError(t);
            }
          },
          n,
          i
        );
    },
    parse: function (t) {
      const e = [];
      for (let n = 0; n < t.length; n++) {
        const i = Js.parse(t[n]);
        e.push(i);
      }
      return e;
    },
  })),
  (oa.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: oa,
    load: function (t, e, n, i) {
      const r = this,
        o = [],
        s = new so();
      s.image = o;
      const a = new ia(this.manager);
      a.setPath(this.path),
        a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader);
      let c = 0;
      function l(l) {
        a.load(
          t[l],
          function (t) {
            const n = r.parse(t, !0);
            (o[l] = {
              width: n.width,
              height: n.height,
              format: n.format,
              mipmaps: n.mipmaps,
            }),
              (c += 1),
              6 === c &&
                (1 === n.mipmapCount && (s.minFilter = 1006),
                (s.format = n.format),
                (s.needsUpdate = !0),
                e && e(s));
          },
          n,
          i
        );
      }
      if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e) l(e);
      else
        a.load(
          t,
          function (t) {
            const n = r.parse(t, !0);
            if (n.isCubemap) {
              const t = n.mipmaps.length / n.mipmapCount;
              for (let e = 0; e < t; e++) {
                o[e] = { mipmaps: [] };
                for (let t = 0; t < n.mipmapCount; t++)
                  o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                    (o[e].format = n.format),
                    (o[e].width = n.width),
                    (o[e].height = n.height);
              }
            } else
              (s.image.width = n.width),
                (s.image.height = n.height),
                (s.mipmaps = n.mipmaps);
            1 === n.mipmapCount && (s.minFilter = 1006),
              (s.format = n.format),
              (s.needsUpdate = !0),
              e && e(s);
          },
          n,
          i
        );
      return s;
    },
  })),
  (sa.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: sa,
    load: function (t, e, n, i) {
      void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      const r = this,
        o = Qs.get(t);
      if (void 0 !== o)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(o), r.manager.itemEnd(t);
          }, 0),
          o
        );
      const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      function a() {
        s.removeEventListener("load", a, !1),
          s.removeEventListener("error", c, !1),
          Qs.add(t, this),
          e && e(this),
          r.manager.itemEnd(t);
      }
      function c(e) {
        s.removeEventListener("load", a, !1),
          s.removeEventListener("error", c, !1),
          i && i(e),
          r.manager.itemError(t),
          r.manager.itemEnd(t);
      }
      return (
        s.addEventListener("load", a, !1),
        s.addEventListener("error", c, !1),
        "data:" !== t.substr(0, 5) &&
          void 0 !== this.crossOrigin &&
          (s.crossOrigin = this.crossOrigin),
        r.manager.itemStart(t),
        (s.src = t),
        s
      );
    },
  })),
  (aa.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: aa,
    load: function (t, e, n, i) {
      const r = new vn(),
        o = new sa(this.manager);
      o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
      let s = 0;
      function a(n) {
        o.load(
          t[n],
          function (t) {
            (r.images[n] = t),
              s++,
              6 === s && ((r.needsUpdate = !0), e && e(r));
          },
          void 0,
          i
        );
      }
      for (let e = 0; e < t.length; ++e) a(e);
      return r;
    },
  })),
  (ca.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: ca,
    load: function (t, e, n, i) {
      const r = this,
        o = new We(),
        s = new ia(this.manager);
      return (
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setPath(this.path),
        s.load(
          t,
          function (t) {
            const n = r.parse(t);
            n &&
              (void 0 !== n.image
                ? (o.image = n.image)
                : void 0 !== n.data &&
                  ((o.image.width = n.width),
                  (o.image.height = n.height),
                  (o.image.data = n.data)),
              (o.wrapS = void 0 !== n.wrapS ? n.wrapS : 1001),
              (o.wrapT = void 0 !== n.wrapT ? n.wrapT : 1001),
              (o.magFilter = void 0 !== n.magFilter ? n.magFilter : 1006),
              (o.minFilter = void 0 !== n.minFilter ? n.minFilter : 1006),
              (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
              void 0 !== n.format && (o.format = n.format),
              void 0 !== n.type && (o.type = n.type),
              void 0 !== n.mipmaps &&
                ((o.mipmaps = n.mipmaps), (o.minFilter = 1008)),
              1 === n.mipmapCount && (o.minFilter = 1006),
              (o.needsUpdate = !0),
              e && e(o, n));
          },
          n,
          i
        ),
        o
      );
    },
  })),
  (la.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: la,
    load: function (t, e, n, i) {
      const r = new u(),
        o = new sa(this.manager);
      return (
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(
          t,
          function (n) {
            r.image = n;
            const i =
              t.search(/\.jpe?g($|\?)/i) > 0 ||
              0 === t.search(/^data\:image\/jpeg/);
            (r.format = i ? 1022 : 1023),
              (r.needsUpdate = !0),
              void 0 !== e && e(r);
          },
          n,
          i
        ),
        r
      );
    },
  })),
  Object.assign(ha.prototype, {
    getPoint: function () {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    },
    getPointAt: function (t, e) {
      const n = this.getUtoTmapping(t);
      return this.getPoint(n, e);
    },
    getPoints: function (t) {
      void 0 === t && (t = 5);
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return e;
    },
    getSpacedPoints: function (t) {
      void 0 === t && (t = 5);
      const e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
      return e;
    },
    getLength: function () {
      const t = this.getLengths();
      return t[t.length - 1];
    },
    getLengths: function (t) {
      if (
        (void 0 === t && (t = this.arcLengthDivisions),
        this.cacheArcLengths &&
          this.cacheArcLengths.length === t + 1 &&
          !this.needsUpdate)
      )
        return this.cacheArcLengths;
      this.needsUpdate = !1;
      const e = [];
      let n,
        i = this.getPoint(0),
        r = 0;
      e.push(0);
      for (let o = 1; o <= t; o++)
        (n = this.getPoint(o / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
      return (this.cacheArcLengths = e), e;
    },
    updateArcLengths: function () {
      (this.needsUpdate = !0), this.getLengths();
    },
    getUtoTmapping: function (t, e) {
      const n = this.getLengths();
      let i = 0;
      const r = n.length;
      let o;
      o = e || t * n[r - 1];
      let s,
        a = 0,
        c = r - 1;
      for (; a <= c; )
        if (((i = Math.floor(a + (c - a) / 2)), (s = n[i] - o), s < 0))
          a = i + 1;
        else {
          if (!(s > 0)) {
            c = i;
            break;
          }
          c = i - 1;
        }
      if (((i = c), n[i] === o)) return i / (r - 1);
      const l = n[i];
      return (i + (o - l) / (n[i + 1] - l)) / (r - 1);
    },
    getTangent: function (t, e) {
      const n = 1e-4;
      let i = t - n,
        r = t + n;
      i < 0 && (i = 0), r > 1 && (r = 1);
      const o = this.getPoint(i),
        a = this.getPoint(r),
        c = e || (o.isVector2 ? new s() : new g());
      return c.copy(a).sub(o).normalize(), c;
    },
    getTangentAt: function (t, e) {
      const n = this.getUtoTmapping(t);
      return this.getTangent(n, e);
    },
    computeFrenetFrames: function (t, e) {
      const n = new g(),
        i = [],
        r = [],
        s = [],
        a = new g(),
        c = new j();
      for (let e = 0; e <= t; e++) {
        const n = e / t;
        (i[e] = this.getTangentAt(n, new g())), i[e].normalize();
      }
      (r[0] = new g()), (s[0] = new g());
      let l = Number.MAX_VALUE;
      const h = Math.abs(i[0].x),
        u = Math.abs(i[0].y),
        d = Math.abs(i[0].z);
      h <= l && ((l = h), n.set(1, 0, 0)),
        u <= l && ((l = u), n.set(0, 1, 0)),
        d <= l && n.set(0, 0, 1),
        a.crossVectors(i[0], n).normalize(),
        r[0].crossVectors(i[0], a),
        s[0].crossVectors(i[0], r[0]);
      for (let e = 1; e <= t; e++) {
        if (
          ((r[e] = r[e - 1].clone()),
          (s[e] = s[e - 1].clone()),
          a.crossVectors(i[e - 1], i[e]),
          a.length() > Number.EPSILON)
        ) {
          a.normalize();
          const t = Math.acos(o.clamp(i[e - 1].dot(i[e]), -1, 1));
          r[e].applyMatrix4(c.makeRotationAxis(a, t));
        }
        s[e].crossVectors(i[e], r[e]);
      }
      if (!0 === e) {
        let e = Math.acos(o.clamp(r[0].dot(r[t]), -1, 1));
        (e /= t), i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
        for (let n = 1; n <= t; n++)
          r[n].applyMatrix4(c.makeRotationAxis(i[n], e * n)),
            s[n].crossVectors(i[n], r[n]);
      }
      return { tangents: i, normals: r, binormals: s };
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return (this.arcLengthDivisions = t.arcLengthDivisions), this;
    },
    toJSON: function () {
      const t = {
        metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
      };
      return (
        (t.arcLengthDivisions = this.arcLengthDivisions),
        (t.type = this.type),
        t
      );
    },
    fromJSON: function (t) {
      return (this.arcLengthDivisions = t.arcLengthDivisions), this;
    },
  }),
  (ua.prototype = Object.create(ha.prototype)),
  (ua.prototype.constructor = ua),
  (ua.prototype.isEllipseCurve = !0),
  (ua.prototype.getPoint = function (t, e) {
    const n = e || new s(),
      i = 2 * Math.PI;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += i;
    for (; r > i; ) r -= i;
    r < Number.EPSILON && (r = o ? 0 : i),
      !0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
    const a = this.aStartAngle + t * r;
    let c = this.aX + this.xRadius * Math.cos(a),
      l = this.aY + this.yRadius * Math.sin(a);
    if (0 !== this.aRotation) {
      const t = Math.cos(this.aRotation),
        e = Math.sin(this.aRotation),
        n = c - this.aX,
        i = l - this.aY;
      (c = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
    }
    return n.set(c, l);
  }),
  (ua.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }),
  (ua.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    );
  }),
  (ua.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }),
  (da.prototype = Object.create(ua.prototype)),
  (da.prototype.constructor = da),
  (da.prototype.isArcCurve = !0);
const fa = new g(),
  ma = new pa(),
  ga = new pa(),
  va = new pa();
function ya(t, e, n, i) {
  ha.call(this),
    (this.type = "CatmullRomCurve3"),
    (this.points = t || []),
    (this.closed = e || !1),
    (this.curveType = n || "centripetal"),
    (this.tension = void 0 !== i ? i : 0.5);
}
function xa(t, e, n, i, r) {
  const o = 0.5 * (i - e),
    s = 0.5 * (r - n),
    a = t * t;
  return (
    (2 * n - 2 * i + o + s) * (t * a) +
    (-3 * n + 3 * i - 2 * o - s) * a +
    o * t +
    n
  );
}
function ba(t, e, n, i) {
  return (
    (function (t, e) {
      const n = 1 - t;
      return n * n * e;
    })(t, e) +
    (function (t, e) {
      return 2 * (1 - t) * t * e;
    })(t, n) +
    (function (t, e) {
      return t * t * e;
    })(t, i)
  );
}
function _a(t, e, n, i, r) {
  return (
    (function (t, e) {
      const n = 1 - t;
      return n * n * n * e;
    })(t, e) +
    (function (t, e) {
      const n = 1 - t;
      return 3 * n * n * t * e;
    })(t, n) +
    (function (t, e) {
      return 3 * (1 - t) * t * t * e;
    })(t, i) +
    (function (t, e) {
      return t * t * t * e;
    })(t, r)
  );
}
function wa(t, e, n, i) {
  ha.call(this),
    (this.type = "CubicBezierCurve"),
    (this.v0 = t || new s()),
    (this.v1 = e || new s()),
    (this.v2 = n || new s()),
    (this.v3 = i || new s());
}
function Ma(t, e, n, i) {
  ha.call(this),
    (this.type = "CubicBezierCurve3"),
    (this.v0 = t || new g()),
    (this.v1 = e || new g()),
    (this.v2 = n || new g()),
    (this.v3 = i || new g());
}
function Sa(t, e) {
  ha.call(this),
    (this.type = "LineCurve"),
    (this.v1 = t || new s()),
    (this.v2 = e || new s());
}
function Ta(t, e) {
  ha.call(this),
    (this.type = "LineCurve3"),
    (this.v1 = t || new g()),
    (this.v2 = e || new g());
}
function Ea(t, e, n) {
  ha.call(this),
    (this.type = "QuadraticBezierCurve"),
    (this.v0 = t || new s()),
    (this.v1 = e || new s()),
    (this.v2 = n || new s());
}
function Aa(t, e, n) {
  ha.call(this),
    (this.type = "QuadraticBezierCurve3"),
    (this.v0 = t || new g()),
    (this.v1 = e || new g()),
    (this.v2 = n || new g());
}
function La(t) {
  ha.call(this), (this.type = "SplineCurve"), (this.points = t || []);
}
(ya.prototype = Object.create(ha.prototype)),
  (ya.prototype.constructor = ya),
  (ya.prototype.isCatmullRomCurve3 = !0),
  (ya.prototype.getPoint = function (t, e) {
    const n = e || new g(),
      i = this.points,
      r = i.length,
      o = (r - (this.closed ? 0 : 1)) * t;
    let s,
      a,
      c = Math.floor(o),
      l = o - c;
    this.closed
      ? (c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r)
      : 0 === l && c === r - 1 && ((c = r - 2), (l = 1)),
      this.closed || c > 0
        ? (s = i[(c - 1) % r])
        : (fa.subVectors(i[0], i[1]).add(i[0]), (s = fa));
    const h = i[c % r],
      u = i[(c + 1) % r];
    if (
      (this.closed || c + 2 < r
        ? (a = i[(c + 2) % r])
        : (fa.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (a = fa)),
      "centripetal" === this.curveType || "chordal" === this.curveType)
    ) {
      const t = "chordal" === this.curveType ? 0.5 : 0.25;
      let e = Math.pow(s.distanceToSquared(h), t),
        n = Math.pow(h.distanceToSquared(u), t),
        i = Math.pow(u.distanceToSquared(a), t);
      n < 1e-4 && (n = 1),
        e < 1e-4 && (e = n),
        i < 1e-4 && (i = n),
        ma.initNonuniformCatmullRom(s.x, h.x, u.x, a.x, e, n, i),
        ga.initNonuniformCatmullRom(s.y, h.y, u.y, a.y, e, n, i),
        va.initNonuniformCatmullRom(s.z, h.z, u.z, a.z, e, n, i);
    } else
      "catmullrom" === this.curveType &&
        (ma.initCatmullRom(s.x, h.x, u.x, a.x, this.tension),
        ga.initCatmullRom(s.y, h.y, u.y, a.y, this.tension),
        va.initCatmullRom(s.z, h.z, u.z, a.z, this.tension));
    return n.set(ma.calc(l), ga.calc(l), va.calc(l)), n;
  }),
  (ya.prototype.copy = function (t) {
    ha.prototype.copy.call(this, t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e];
      this.points.push(n.clone());
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    );
  }),
  (ya.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const n = this.points[e];
      t.points.push(n.toArray());
    }
    return (
      (t.closed = this.closed),
      (t.curveType = this.curveType),
      (t.tension = this.tension),
      t
    );
  }),
  (ya.prototype.fromJSON = function (t) {
    ha.prototype.fromJSON.call(this, t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e];
      this.points.push(new g().fromArray(n));
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    );
  }),
  (wa.prototype = Object.create(ha.prototype)),
  (wa.prototype.constructor = wa),
  (wa.prototype.isCubicBezierCurve = !0),
  (wa.prototype.getPoint = function (t, e) {
    const n = e || new s(),
      i = this.v0,
      r = this.v1,
      o = this.v2,
      a = this.v3;
    return n.set(_a(t, i.x, r.x, o.x, a.x), _a(t, i.y, r.y, o.y, a.y)), n;
  }),
  (wa.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }),
  (wa.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }),
  (wa.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }),
  (Ma.prototype = Object.create(ha.prototype)),
  (Ma.prototype.constructor = Ma),
  (Ma.prototype.isCubicBezierCurve3 = !0),
  (Ma.prototype.getPoint = function (t, e) {
    const n = e || new g(),
      i = this.v0,
      r = this.v1,
      o = this.v2,
      s = this.v3;
    return (
      n.set(
        _a(t, i.x, r.x, o.x, s.x),
        _a(t, i.y, r.y, o.y, s.y),
        _a(t, i.z, r.z, o.z, s.z)
      ),
      n
    );
  }),
  (Ma.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }),
  (Ma.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }),
  (Ma.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }),
  (Sa.prototype = Object.create(ha.prototype)),
  (Sa.prototype.constructor = Sa),
  (Sa.prototype.isLineCurve = !0),
  (Sa.prototype.getPoint = function (t, e) {
    const n = e || new s();
    return (
      1 === t
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    );
  }),
  (Sa.prototype.getPointAt = function (t, e) {
    return this.getPoint(t, e);
  }),
  (Sa.prototype.getTangent = function (t, e) {
    const n = e || new s();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }),
  (Sa.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }),
  (Sa.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }),
  (Sa.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }),
  (Ta.prototype = Object.create(ha.prototype)),
  (Ta.prototype.constructor = Ta),
  (Ta.prototype.isLineCurve3 = !0),
  (Ta.prototype.getPoint = function (t, e) {
    const n = e || new g();
    return (
      1 === t
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    );
  }),
  (Ta.prototype.getPointAt = function (t, e) {
    return this.getPoint(t, e);
  }),
  (Ta.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }),
  (Ta.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }),
  (Ta.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }),
  (Ea.prototype = Object.create(ha.prototype)),
  (Ea.prototype.constructor = Ea),
  (Ea.prototype.isQuadraticBezierCurve = !0),
  (Ea.prototype.getPoint = function (t, e) {
    const n = e || new s(),
      i = this.v0,
      r = this.v1,
      o = this.v2;
    return n.set(ba(t, i.x, r.x, o.x), ba(t, i.y, r.y, o.y)), n;
  }),
  (Ea.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }),
  (Ea.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }),
  (Ea.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }),
  (Aa.prototype = Object.create(ha.prototype)),
  (Aa.prototype.constructor = Aa),
  (Aa.prototype.isQuadraticBezierCurve3 = !0),
  (Aa.prototype.getPoint = function (t, e) {
    const n = e || new g(),
      i = this.v0,
      r = this.v1,
      o = this.v2;
    return (
      n.set(ba(t, i.x, r.x, o.x), ba(t, i.y, r.y, o.y), ba(t, i.z, r.z, o.z)), n
    );
  }),
  (Aa.prototype.copy = function (t) {
    return (
      ha.prototype.copy.call(this, t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }),
  (Aa.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }),
  (Aa.prototype.fromJSON = function (t) {
    return (
      ha.prototype.fromJSON.call(this, t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }),
  (La.prototype = Object.create(ha.prototype)),
  (La.prototype.constructor = La),
  (La.prototype.isSplineCurve = !0),
  (La.prototype.getPoint = function (t, e) {
    const n = e || new s(),
      i = this.points,
      r = (i.length - 1) * t,
      o = Math.floor(r),
      a = r - o,
      c = i[0 === o ? o : o - 1],
      l = i[o],
      h = i[o > i.length - 2 ? i.length - 1 : o + 1],
      u = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return n.set(xa(a, c.x, l.x, h.x, u.x), xa(a, c.y, l.y, h.y, u.y)), n;
  }),
  (La.prototype.copy = function (t) {
    ha.prototype.copy.call(this, t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e];
      this.points.push(n.clone());
    }
    return this;
  }),
  (La.prototype.toJSON = function () {
    const t = ha.prototype.toJSON.call(this);
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const n = this.points[e];
      t.points.push(n.toArray());
    }
    return t;
  }),
  (La.prototype.fromJSON = function (t) {
    ha.prototype.fromJSON.call(this, t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const n = t.points[e];
      this.points.push(new s().fromArray(n));
    }
    return this;
  });
var Ra = Object.freeze({
  __proto__: null,
  ArcCurve: da,
  CatmullRomCurve3: ya,
  CubicBezierCurve: wa,
  CubicBezierCurve3: Ma,
  EllipseCurve: ua,
  LineCurve: Sa,
  LineCurve3: Ta,
  QuadraticBezierCurve: Ea,
  QuadraticBezierCurve3: Aa,
  SplineCurve: La,
});
function Pa() {
  ha.call(this),
    (this.type = "CurvePath"),
    (this.curves = []),
    (this.autoClose = !1);
}
function Ca(t) {
  Pa.call(this),
    (this.type = "Path"),
    (this.currentPoint = new s()),
    t && this.setFromPoints(t);
}
function Oa(t) {
  Ca.call(this, t),
    (this.uuid = o.generateUUID()),
    (this.type = "Shape"),
    (this.holes = []);
}
function Na(t, e) {
  mt.call(this),
    (this.type = "Light"),
    (this.color = new zt(t)),
    (this.intensity = void 0 !== e ? e : 1),
    (this.receiveShadow = void 0);
}
function Ia(t, e, n) {
  Na.call(this, t, n),
    (this.type = "HemisphereLight"),
    (this.castShadow = void 0),
    this.position.copy(mt.DefaultUp),
    this.updateMatrix(),
    (this.groundColor = new zt(e));
}
function Da(t) {
  (this.camera = t),
    (this.bias = 0),
    (this.normalBias = 0),
    (this.radius = 1),
    (this.mapSize = new s(512, 512)),
    (this.map = null),
    (this.mapPass = null),
    (this.matrix = new j()),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this._frustum = new Ye()),
    (this._frameExtents = new s(1, 1)),
    (this._viewportCount = 1),
    (this._viewports = [new d(0, 0, 1, 1)]);
}
function Ba() {
  Da.call(this, new ke(50, 1, 0.5, 500));
}
function za(t, e, n, i, r, o) {
  Na.call(this, t, e),
    (this.type = "SpotLight"),
    this.position.copy(mt.DefaultUp),
    this.updateMatrix(),
    (this.target = new mt()),
    Object.defineProperty(this, "power", {
      get: function () {
        return this.intensity * Math.PI;
      },
      set: function (t) {
        this.intensity = t / Math.PI;
      },
    }),
    (this.distance = void 0 !== n ? n : 0),
    (this.angle = void 0 !== i ? i : Math.PI / 3),
    (this.penumbra = void 0 !== r ? r : 0),
    (this.decay = void 0 !== o ? o : 1),
    (this.shadow = new Ba());
}
function Fa() {
  Da.call(this, new ke(90, 1, 0.5, 500)),
    (this._frameExtents = new s(4, 2)),
    (this._viewportCount = 6),
    (this._viewports = [
      new d(2, 1, 1, 1),
      new d(0, 1, 1, 1),
      new d(3, 1, 1, 1),
      new d(1, 1, 1, 1),
      new d(3, 0, 1, 1),
      new d(1, 0, 1, 1),
    ]),
    (this._cubeDirections = [
      new g(1, 0, 0),
      new g(-1, 0, 0),
      new g(0, 0, 1),
      new g(0, 0, -1),
      new g(0, 1, 0),
      new g(0, -1, 0),
    ]),
    (this._cubeUps = [
      new g(0, 1, 0),
      new g(0, 1, 0),
      new g(0, 1, 0),
      new g(0, 1, 0),
      new g(0, 0, 1),
      new g(0, 0, -1),
    ]);
}
function Ua(t, e, n, i) {
  Na.call(this, t, e),
    (this.type = "PointLight"),
    Object.defineProperty(this, "power", {
      get: function () {
        return 4 * this.intensity * Math.PI;
      },
      set: function (t) {
        this.intensity = t / (4 * Math.PI);
      },
    }),
    (this.distance = void 0 !== n ? n : 0),
    (this.decay = void 0 !== i ? i : 1),
    (this.shadow = new Fa());
}
function Ga(t, e, n, i, r, o) {
  He.call(this),
    (this.type = "OrthographicCamera"),
    (this.zoom = 1),
    (this.view = null),
    (this.left = void 0 !== t ? t : -1),
    (this.right = void 0 !== e ? e : 1),
    (this.top = void 0 !== n ? n : 1),
    (this.bottom = void 0 !== i ? i : -1),
    (this.near = void 0 !== r ? r : 0.1),
    (this.far = void 0 !== o ? o : 2e3),
    this.updateProjectionMatrix();
}
function Ha() {
  Da.call(this, new Ga(-5, 5, 5, -5, 0.5, 500));
}
function ka(t, e) {
  Na.call(this, t, e),
    (this.type = "DirectionalLight"),
    this.position.copy(mt.DefaultUp),
    this.updateMatrix(),
    (this.target = new mt()),
    (this.shadow = new Ha());
}
function Va(t, e) {
  Na.call(this, t, e), (this.type = "AmbientLight"), (this.castShadow = void 0);
}
function ja(t, e, n, i) {
  Na.call(this, t, e),
    (this.type = "RectAreaLight"),
    (this.width = void 0 !== n ? n : 10),
    (this.height = void 0 !== i ? i : 10);
}
(Pa.prototype = Object.assign(Object.create(ha.prototype), {
  constructor: Pa,
  add: function (t) {
    this.curves.push(t);
  },
  closePath: function () {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new Sa(e, t));
  },
  getPoint: function (t) {
    const e = t * this.getLength(),
      n = this.getCurveLengths();
    let i = 0;
    for (; i < n.length; ) {
      if (n[i] >= e) {
        const t = n[i] - e,
          r = this.curves[i],
          o = r.getLength(),
          s = 0 === o ? 0 : 1 - t / o;
        return r.getPointAt(s);
      }
      i++;
    }
    return null;
  },
  getLength: function () {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  },
  updateArcLengths: function () {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  },
  getCurveLengths: function () {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (e += this.curves[n].getLength()), t.push(e);
    return (this.cacheLengths = t), t;
  },
  getSpacedPoints: function (t) {
    void 0 === t && (t = 40);
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  },
  getPoints: function (t) {
    t = t || 12;
    const e = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const o = r[i],
        s =
          o && o.isEllipseCurve
            ? 2 * t
            : o && (o.isLineCurve || o.isLineCurve3)
            ? 1
            : o && o.isSplineCurve
            ? t * o.points.length
            : t,
        a = o.getPoints(s);
      for (let t = 0; t < a.length; t++) {
        const i = a[t];
        (n && n.equals(i)) || (e.push(i), (n = i));
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    );
  },
  copy: function (t) {
    ha.prototype.copy.call(this, t), (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e];
      this.curves.push(n.clone());
    }
    return (this.autoClose = t.autoClose), this;
  },
  toJSON: function () {
    const t = ha.prototype.toJSON.call(this);
    (t.autoClose = this.autoClose), (t.curves = []);
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const n = this.curves[e];
      t.curves.push(n.toJSON());
    }
    return t;
  },
  fromJSON: function (t) {
    ha.prototype.fromJSON.call(this, t),
      (this.autoClose = t.autoClose),
      (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const n = t.curves[e];
      this.curves.push(new Ra[n.type]().fromJSON(n));
    }
    return this;
  },
})),
  (Ca.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: Ca,
    setFromPoints: function (t) {
      this.moveTo(t[0].x, t[0].y);
      for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
      return this;
    },
    moveTo: function (t, e) {
      return this.currentPoint.set(t, e), this;
    },
    lineTo: function (t, e) {
      const n = new Sa(this.currentPoint.clone(), new s(t, e));
      return this.curves.push(n), this.currentPoint.set(t, e), this;
    },
    quadraticCurveTo: function (t, e, n, i) {
      const r = new Ea(this.currentPoint.clone(), new s(t, e), new s(n, i));
      return this.curves.push(r), this.currentPoint.set(n, i), this;
    },
    bezierCurveTo: function (t, e, n, i, r, o) {
      const a = new wa(
        this.currentPoint.clone(),
        new s(t, e),
        new s(n, i),
        new s(r, o)
      );
      return this.curves.push(a), this.currentPoint.set(r, o), this;
    },
    splineThru: function (t) {
      const e = new La([this.currentPoint.clone()].concat(t));
      return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this;
    },
    arc: function (t, e, n, i, r, o) {
      const s = this.currentPoint.x,
        a = this.currentPoint.y;
      return this.absarc(t + s, e + a, n, i, r, o), this;
    },
    absarc: function (t, e, n, i, r, o) {
      return this.absellipse(t, e, n, n, i, r, o), this;
    },
    ellipse: function (t, e, n, i, r, o, s, a) {
      const c = this.currentPoint.x,
        l = this.currentPoint.y;
      return this.absellipse(t + c, e + l, n, i, r, o, s, a), this;
    },
    absellipse: function (t, e, n, i, r, o, s, a) {
      const c = new ua(t, e, n, i, r, o, s, a);
      if (this.curves.length > 0) {
        const t = c.getPoint(0);
        t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
      }
      this.curves.push(c);
      const l = c.getPoint(1);
      return this.currentPoint.copy(l), this;
    },
    copy: function (t) {
      return (
        Pa.prototype.copy.call(this, t),
        this.currentPoint.copy(t.currentPoint),
        this
      );
    },
    toJSON: function () {
      const t = Pa.prototype.toJSON.call(this);
      return (t.currentPoint = this.currentPoint.toArray()), t;
    },
    fromJSON: function (t) {
      return (
        Pa.prototype.fromJSON.call(this, t),
        this.currentPoint.fromArray(t.currentPoint),
        this
      );
    },
  })),
  (Oa.prototype = Object.assign(Object.create(Ca.prototype), {
    constructor: Oa,
    getPointsHoles: function (t) {
      const e = [];
      for (let n = 0, i = this.holes.length; n < i; n++)
        e[n] = this.holes[n].getPoints(t);
      return e;
    },
    extractPoints: function (t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    },
    copy: function (t) {
      Ca.prototype.copy.call(this, t), (this.holes = []);
      for (let e = 0, n = t.holes.length; e < n; e++) {
        const n = t.holes[e];
        this.holes.push(n.clone());
      }
      return this;
    },
    toJSON: function () {
      const t = Ca.prototype.toJSON.call(this);
      (t.uuid = this.uuid), (t.holes = []);
      for (let e = 0, n = this.holes.length; e < n; e++) {
        const n = this.holes[e];
        t.holes.push(n.toJSON());
      }
      return t;
    },
    fromJSON: function (t) {
      Ca.prototype.fromJSON.call(this, t),
        (this.uuid = t.uuid),
        (this.holes = []);
      for (let e = 0, n = t.holes.length; e < n; e++) {
        const n = t.holes[e];
        this.holes.push(new Ca().fromJSON(n));
      }
      return this;
    },
  })),
  (Na.prototype = Object.assign(Object.create(mt.prototype), {
    constructor: Na,
    isLight: !0,
    copy: function (t) {
      return (
        mt.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.intensity = t.intensity),
        this
      );
    },
    toJSON: function (t) {
      const e = mt.prototype.toJSON.call(this, t);
      return (
        (e.object.color = this.color.getHex()),
        (e.object.intensity = this.intensity),
        void 0 !== this.groundColor &&
          (e.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (e.object.distance = this.distance),
        void 0 !== this.angle && (e.object.angle = this.angle),
        void 0 !== this.decay && (e.object.decay = this.decay),
        void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
        e
      );
    },
  })),
  (Ia.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: Ia,
    isHemisphereLight: !0,
    copy: function (t) {
      return (
        Na.prototype.copy.call(this, t),
        this.groundColor.copy(t.groundColor),
        this
      );
    },
  })),
  Object.assign(Da.prototype, {
    _projScreenMatrix: new j(),
    _lightPositionWorld: new g(),
    _lookTarget: new g(),
    getViewportCount: function () {
      return this._viewportCount;
    },
    getFrustum: function () {
      return this._frustum;
    },
    updateMatrices: function (t) {
      const e = this.camera,
        n = this.matrix,
        i = this._projScreenMatrix,
        r = this._lookTarget,
        o = this._lightPositionWorld;
      o.setFromMatrixPosition(t.matrixWorld),
        e.position.copy(o),
        r.setFromMatrixPosition(t.target.matrixWorld),
        e.lookAt(r),
        e.updateMatrixWorld(),
        i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(i),
        n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        n.multiply(e.projectionMatrix),
        n.multiply(e.matrixWorldInverse);
    },
    getViewport: function (t) {
      return this._viewports[t];
    },
    getFrameExtents: function () {
      return this._frameExtents;
    },
    copy: function (t) {
      return (
        (this.camera = t.camera.clone()),
        (this.bias = t.bias),
        (this.radius = t.radius),
        this.mapSize.copy(t.mapSize),
        this
      );
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    toJSON: function () {
      const t = {};
      return (
        0 !== this.bias && (t.bias = this.bias),
        0 !== this.normalBias && (t.normalBias = this.normalBias),
        1 !== this.radius && (t.radius = this.radius),
        (512 === this.mapSize.x && 512 === this.mapSize.y) ||
          (t.mapSize = this.mapSize.toArray()),
        (t.camera = this.camera.toJSON(!1).object),
        delete t.camera.matrix,
        t
      );
    },
  }),
  (Ba.prototype = Object.assign(Object.create(Da.prototype), {
    constructor: Ba,
    isSpotLightShadow: !0,
    updateMatrices: function (t) {
      const e = this.camera,
        n = 2 * o.RAD2DEG * t.angle,
        i = this.mapSize.width / this.mapSize.height,
        r = t.distance || e.far;
      (n === e.fov && i === e.aspect && r === e.far) ||
        ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
        Da.prototype.updateMatrices.call(this, t);
    },
  })),
  (za.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: za,
    isSpotLight: !0,
    copy: function (t) {
      return (
        Na.prototype.copy.call(this, t),
        (this.distance = t.distance),
        (this.angle = t.angle),
        (this.penumbra = t.penumbra),
        (this.decay = t.decay),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    },
  })),
  (Fa.prototype = Object.assign(Object.create(Da.prototype), {
    constructor: Fa,
    isPointLightShadow: !0,
    updateMatrices: function (t, e) {
      void 0 === e && (e = 0);
      const n = this.camera,
        i = this.matrix,
        r = this._lightPositionWorld,
        o = this._lookTarget,
        s = this._projScreenMatrix;
      r.setFromMatrixPosition(t.matrixWorld),
        n.position.copy(r),
        o.copy(n.position),
        o.add(this._cubeDirections[e]),
        n.up.copy(this._cubeUps[e]),
        n.lookAt(o),
        n.updateMatrixWorld(),
        i.makeTranslation(-r.x, -r.y, -r.z),
        s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(s);
    },
  })),
  (Ua.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: Ua,
    isPointLight: !0,
    copy: function (t) {
      return (
        Na.prototype.copy.call(this, t),
        (this.distance = t.distance),
        (this.decay = t.decay),
        (this.shadow = t.shadow.clone()),
        this
      );
    },
  })),
  (Ga.prototype = Object.assign(Object.create(He.prototype), {
    constructor: Ga,
    isOrthographicCamera: !0,
    copy: function (t, e) {
      return (
        He.prototype.copy.call(this, t, e),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        this
      );
    },
    setViewOffset: function (t, e, n, i, r, o) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = o),
        this.updateProjectionMatrix();
    },
    clearViewOffset: function () {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function () {
      const t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2;
      let r = n - t,
        o = n + t,
        s = i + e,
        a = i - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (r += t * this.view.offsetX),
          (o = r + t * this.view.width),
          (s -= e * this.view.offsetY),
          (a = s - e * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far),
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function (t) {
      const e = mt.prototype.toJSON.call(this, t);
      return (
        (e.object.zoom = this.zoom),
        (e.object.left = this.left),
        (e.object.right = this.right),
        (e.object.top = this.top),
        (e.object.bottom = this.bottom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
      );
    },
  })),
  (Ha.prototype = Object.assign(Object.create(Da.prototype), {
    constructor: Ha,
    isDirectionalLightShadow: !0,
    updateMatrices: function (t) {
      Da.prototype.updateMatrices.call(this, t);
    },
  })),
  (ka.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: ka,
    isDirectionalLight: !0,
    copy: function (t) {
      return (
        Na.prototype.copy.call(this, t),
        (this.target = t.target.clone()),
        (this.shadow = t.shadow.clone()),
        this
      );
    },
  })),
  (Va.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: Va,
    isAmbientLight: !0,
  })),
  (ja.prototype = Object.assign(Object.create(Na.prototype), {
    constructor: ja,
    isRectAreaLight: !0,
    copy: function (t) {
      return (
        Na.prototype.copy.call(this, t),
        (this.width = t.width),
        (this.height = t.height),
        this
      );
    },
    toJSON: function (t) {
      const e = Na.prototype.toJSON.call(this, t);
      return (e.object.width = this.width), (e.object.height = this.height), e;
    },
  }));
class Wa {
  constructor() {
    Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }),
      (this.coefficients = []);
    for (let t = 0; t < 9; t++) this.coefficients.push(new g());
  }
  set(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
    return this;
  }
  zero() {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
    return this;
  }
  getAt(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      o = this.coefficients;
    return (
      e.copy(o[0]).multiplyScalar(0.282095),
      e.addScaledVector(o[1], 0.488603 * i),
      e.addScaledVector(o[2], 0.488603 * r),
      e.addScaledVector(o[3], 0.488603 * n),
      e.addScaledVector(o[4], n * i * 1.092548),
      e.addScaledVector(o[5], i * r * 1.092548),
      e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
      e.addScaledVector(o[7], n * r * 1.092548),
      e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
      e
    );
  }
  getIrradianceAt(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      o = this.coefficients;
    return (
      e.copy(o[0]).multiplyScalar(0.886227),
      e.addScaledVector(o[1], 1.023328 * i),
      e.addScaledVector(o[2], 1.023328 * r),
      e.addScaledVector(o[3], 1.023328 * n),
      e.addScaledVector(o[4], 0.858086 * n * i),
      e.addScaledVector(o[5], 0.858086 * i * r),
      e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
      e.addScaledVector(o[7], 0.858086 * n * r),
      e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
      e
    );
  }
  add(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
    return this;
  }
  addScaledSH(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e);
    return this;
  }
  scale(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
    return this;
  }
  lerp(t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
    return this;
  }
  equals(t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
    return !0;
  }
  copy(t) {
    return this.set(t.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(t, e) {
    void 0 === e && (e = 0);
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
    return this;
  }
  toArray(t, e) {
    void 0 === t && (t = []), void 0 === e && (e = 0);
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
    return t;
  }
  static getBasisAt(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z;
    (e[0] = 0.282095),
      (e[1] = 0.488603 * i),
      (e[2] = 0.488603 * r),
      (e[3] = 0.488603 * n),
      (e[4] = 1.092548 * n * i),
      (e[5] = 1.092548 * i * r),
      (e[6] = 0.315392 * (3 * r * r - 1)),
      (e[7] = 1.092548 * n * r),
      (e[8] = 0.546274 * (n * n - i * i));
  }
}
function qa(t, e) {
  Na.call(this, void 0, e),
    (this.type = "LightProbe"),
    (this.sh = void 0 !== t ? t : new Wa());
}
function Xa(t) {
  ea.call(this, t), (this.textures = {});
}
(qa.prototype = Object.assign(Object.create(Na.prototype), {
  constructor: qa,
  isLightProbe: !0,
  copy: function (t) {
    return Na.prototype.copy.call(this, t), this.sh.copy(t.sh), this;
  },
  fromJSON: function (t) {
    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
  },
  toJSON: function (t) {
    const e = Na.prototype.toJSON.call(this, t);
    return (e.object.sh = this.sh.toArray()), e;
  },
})),
  (Xa.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: Xa,
    load: function (t, e, n, i) {
      const r = this,
        o = new ia(r.manager);
      o.setPath(r.path),
        o.setRequestHeader(r.requestHeader),
        o.load(
          t,
          function (n) {
            try {
              e(r.parse(JSON.parse(n)));
            } catch (e) {
              i ? i(e) : console.error(e), r.manager.itemError(t);
            }
          },
          n,
          i
        );
    },
    parse: function (t) {
      const e = this.textures;
      function n(t) {
        return (
          void 0 === e[t] &&
            console.warn("THREE.MaterialLoader: Undefined texture", t),
          e[t]
        );
      }
      const i = new Bs[t.type]();
      if (
        (void 0 !== t.uuid && (i.uuid = t.uuid),
        void 0 !== t.name && (i.name = t.name),
        void 0 !== t.color && i.color.setHex(t.color),
        void 0 !== t.roughness && (i.roughness = t.roughness),
        void 0 !== t.metalness && (i.metalness = t.metalness),
        void 0 !== t.sheen && (i.sheen = new zt().setHex(t.sheen)),
        void 0 !== t.emissive && i.emissive.setHex(t.emissive),
        void 0 !== t.specular && i.specular.setHex(t.specular),
        void 0 !== t.shininess && (i.shininess = t.shininess),
        void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
        void 0 !== t.clearcoatRoughness &&
          (i.clearcoatRoughness = t.clearcoatRoughness),
        void 0 !== t.fog && (i.fog = t.fog),
        void 0 !== t.flatShading && (i.flatShading = t.flatShading),
        void 0 !== t.blending && (i.blending = t.blending),
        void 0 !== t.combine && (i.combine = t.combine),
        void 0 !== t.side && (i.side = t.side),
        void 0 !== t.opacity && (i.opacity = t.opacity),
        void 0 !== t.transparent && (i.transparent = t.transparent),
        void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
        void 0 !== t.depthTest && (i.depthTest = t.depthTest),
        void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
        void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
        void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
        void 0 !== t.stencilWriteMask &&
          (i.stencilWriteMask = t.stencilWriteMask),
        void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
        void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
        void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask),
        void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
        void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
        void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
        void 0 !== t.wireframe && (i.wireframe = t.wireframe),
        void 0 !== t.wireframeLinewidth &&
          (i.wireframeLinewidth = t.wireframeLinewidth),
        void 0 !== t.wireframeLinecap &&
          (i.wireframeLinecap = t.wireframeLinecap),
        void 0 !== t.wireframeLinejoin &&
          (i.wireframeLinejoin = t.wireframeLinejoin),
        void 0 !== t.rotation && (i.rotation = t.rotation),
        1 !== t.linewidth && (i.linewidth = t.linewidth),
        void 0 !== t.dashSize && (i.dashSize = t.dashSize),
        void 0 !== t.gapSize && (i.gapSize = t.gapSize),
        void 0 !== t.scale && (i.scale = t.scale),
        void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
        void 0 !== t.polygonOffsetFactor &&
          (i.polygonOffsetFactor = t.polygonOffsetFactor),
        void 0 !== t.polygonOffsetUnits &&
          (i.polygonOffsetUnits = t.polygonOffsetUnits),
        void 0 !== t.skinning && (i.skinning = t.skinning),
        void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
        void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
        void 0 !== t.dithering && (i.dithering = t.dithering),
        void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents),
        void 0 !== t.visible && (i.visible = t.visible),
        void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
        void 0 !== t.userData && (i.userData = t.userData),
        void 0 !== t.vertexColors &&
          ("number" == typeof t.vertexColors
            ? (i.vertexColors = t.vertexColors > 0)
            : (i.vertexColors = t.vertexColors)),
        void 0 !== t.uniforms)
      )
        for (const e in t.uniforms) {
          const r = t.uniforms[e];
          switch (((i.uniforms[e] = {}), r.type)) {
            case "t":
              i.uniforms[e].value = n(r.value);
              break;
            case "c":
              i.uniforms[e].value = new zt().setHex(r.value);
              break;
            case "v2":
              i.uniforms[e].value = new s().fromArray(r.value);
              break;
            case "v3":
              i.uniforms[e].value = new g().fromArray(r.value);
              break;
            case "v4":
              i.uniforms[e].value = new d().fromArray(r.value);
              break;
            case "m3":
              i.uniforms[e].value = new a().fromArray(r.value);
              break;
            case "m4":
              i.uniforms[e].value = new j().fromArray(r.value);
              break;
            default:
              i.uniforms[e].value = r.value;
          }
        }
      if (
        (void 0 !== t.defines && (i.defines = t.defines),
        void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
        void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
        void 0 !== t.extensions)
      )
        for (const e in t.extensions) i.extensions[e] = t.extensions[e];
      if (
        (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
        void 0 !== t.size && (i.size = t.size),
        void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation),
        void 0 !== t.map && (i.map = n(t.map)),
        void 0 !== t.matcap && (i.matcap = n(t.matcap)),
        void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
        void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
        void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
        void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
        void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
        void 0 !== t.normalScale)
      ) {
        let e = t.normalScale;
        !1 === Array.isArray(e) && (e = [e, e]),
          (i.normalScale = new s().fromArray(e));
      }
      return (
        void 0 !== t.displacementMap &&
          (i.displacementMap = n(t.displacementMap)),
        void 0 !== t.displacementScale &&
          (i.displacementScale = t.displacementScale),
        void 0 !== t.displacementBias &&
          (i.displacementBias = t.displacementBias),
        void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
        void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
        void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
        void 0 !== t.emissiveIntensity &&
          (i.emissiveIntensity = t.emissiveIntensity),
        void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
        void 0 !== t.envMap && (i.envMap = n(t.envMap)),
        void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity),
        void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
        void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio),
        void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
        void 0 !== t.lightMapIntensity &&
          (i.lightMapIntensity = t.lightMapIntensity),
        void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
        void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
        void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
        void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
        void 0 !== t.clearcoatRoughnessMap &&
          (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
        void 0 !== t.clearcoatNormalMap &&
          (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
        void 0 !== t.clearcoatNormalScale &&
          (i.clearcoatNormalScale = new s().fromArray(t.clearcoatNormalScale)),
        void 0 !== t.transmission && (i.transmission = t.transmission),
        void 0 !== t.transmissionMap &&
          (i.transmissionMap = n(t.transmissionMap)),
        i
      );
    },
    setTextures: function (t) {
      return (this.textures = t), this;
    },
  }));
const Ya = {
  decodeText: function (t) {
    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch (t) {
      return e;
    }
  },
  extractUrlBase: function (t) {
    const e = t.lastIndexOf("/");
    return -1 === e ? "./" : t.substr(0, e + 1);
  },
};
function Za() {
  le.call(this),
    (this.type = "InstancedBufferGeometry"),
    (this.instanceCount = 1 / 0);
}
function Ja(t, e, n, i) {
  "number" == typeof n &&
    ((i = n),
    (n = !1),
    console.error(
      "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
    )),
    jt.call(this, t, e, n),
    (this.meshPerAttribute = i || 1);
}
function Ka(t) {
  ea.call(this, t);
}
(Za.prototype = Object.assign(Object.create(le.prototype), {
  constructor: Za,
  isInstancedBufferGeometry: !0,
  copy: function (t) {
    return (
      le.prototype.copy.call(this, t),
      (this.instanceCount = t.instanceCount),
      this
    );
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const t = le.prototype.toJSON.call(this);
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    );
  },
})),
  (Ja.prototype = Object.assign(Object.create(jt.prototype), {
    constructor: Ja,
    isInstancedBufferAttribute: !0,
    copy: function (t) {
      return (
        jt.prototype.copy.call(this, t),
        (this.meshPerAttribute = t.meshPerAttribute),
        this
      );
    },
    toJSON: function () {
      const t = jt.prototype.toJSON.call(this);
      return (
        (t.meshPerAttribute = this.meshPerAttribute),
        (t.isInstancedBufferAttribute = !0),
        t
      );
    },
  })),
  (Ka.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: Ka,
    load: function (t, e, n, i) {
      const r = this,
        o = new ia(r.manager);
      o.setPath(r.path),
        o.setRequestHeader(r.requestHeader),
        o.load(
          t,
          function (n) {
            try {
              e(r.parse(JSON.parse(n)));
            } catch (e) {
              i ? i(e) : console.error(e), r.manager.itemError(t);
            }
          },
          n,
          i
        );
    },
    parse: function (t) {
      const e = {},
        n = {};
      function i(t, i) {
        if (void 0 !== e[i]) return e[i];
        const r = t.interleavedBuffers[i],
          o = (function (t, e) {
            if (void 0 !== n[e]) return n[e];
            const i = t.arrayBuffers[e],
              r = new Uint32Array(i).buffer;
            return (n[e] = r), r;
          })(t, r.buffer),
          s = new lr(new Qa[r.type](o), r.stride);
        return (s.uuid = r.uuid), (e[i] = s), s;
      }
      const r = t.isInstancedBufferGeometry ? new Za() : new le(),
        o = t.data.index;
      if (void 0 !== o) {
        const t = new Qa[o.type](o.array);
        r.setIndex(new jt(t, 1));
      }
      const s = t.data.attributes;
      for (const e in s) {
        const n = s[e];
        let o;
        if (n.isInterleavedBufferAttribute) {
          o = new ur(i(t.data, n.data), n.itemSize, n.offset, n.normalized);
        } else {
          const t = new Qa[n.type](n.array);
          o = new (n.isInstancedBufferAttribute ? Ja : jt)(
            t,
            n.itemSize,
            n.normalized
          );
        }
        void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o);
      }
      const a = t.data.morphAttributes;
      if (a)
        for (const e in a) {
          const n = a[e],
            o = [];
          for (let e = 0, r = n.length; e < r; e++) {
            const r = n[e];
            let s;
            if (r.isInterleavedBufferAttribute) {
              s = new ur(i(t.data, r.data), r.itemSize, r.offset, r.normalized);
            } else {
              s = new jt(new Qa[r.type](r.array), r.itemSize, r.normalized);
            }
            void 0 !== r.name && (s.name = r.name), o.push(s);
          }
          r.morphAttributes[e] = o;
        }
      t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
      const c = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (void 0 !== c)
        for (let t = 0, e = c.length; t !== e; ++t) {
          const e = c[t];
          r.addGroup(e.start, e.count, e.materialIndex);
        }
      const l = t.data.boundingSphere;
      if (void 0 !== l) {
        const t = new g();
        void 0 !== l.center && t.fromArray(l.center),
          (r.boundingSphere = new D(t, l.radius));
      }
      return (
        t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r
      );
    },
  }));
const Qa = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  Uint8ClampedArray:
    "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array,
};
function $a(t) {
  ea.call(this, t);
}
$a.prototype = Object.assign(Object.create(ea.prototype), {
  constructor: $a,
  load: function (t, e, n, i) {
    const r = this,
      o = "" === this.path ? Ya.extractUrlBase(t) : this.path;
    this.resourcePath = this.resourcePath || o;
    const s = new ia(r.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.load(
        t,
        function (n) {
          let o = null;
          try {
            o = JSON.parse(n);
          } catch (e) {
            return (
              void 0 !== i && i(e),
              void console.error(
                "THREE:ObjectLoader: Can't parse " + t + ".",
                e.message
              )
            );
          }
          const s = o.metadata;
          void 0 !== s &&
          void 0 !== s.type &&
          "geometry" !== s.type.toLowerCase()
            ? r.parse(o, e)
            : console.error("THREE.ObjectLoader: Can't load " + t);
        },
        n,
        i
      );
  },
  parse: function (t, e) {
    const n = this.parseShape(t.shapes),
      i = this.parseGeometries(t.geometries, n),
      r = this.parseImages(t.images, function () {
        void 0 !== e && e(a);
      }),
      o = this.parseTextures(t.textures, r),
      s = this.parseMaterials(t.materials, o),
      a = this.parseObject(t.object, i, s);
    return (
      t.animations && (a.animations = this.parseAnimations(t.animations)),
      (void 0 !== t.images && 0 !== t.images.length) || (void 0 !== e && e(a)),
      a
    );
  },
  parseShape: function (t) {
    const e = {};
    if (void 0 !== t)
      for (let n = 0, i = t.length; n < i; n++) {
        const i = new Oa().fromJSON(t[n]);
        e[i.uuid] = i;
      }
    return e;
  },
  parseGeometries: function (t, e) {
    const n = {};
    let i;
    if (void 0 !== t) {
      const r = new Ka();
      for (let o = 0, s = t.length; o < s; o++) {
        let s;
        const a = t[o];
        switch (a.type) {
          case "PlaneGeometry":
          case "PlaneBufferGeometry":
            s = new Ts[a.type](
              a.width,
              a.height,
              a.widthSegments,
              a.heightSegments
            );
            break;
          case "BoxGeometry":
          case "BoxBufferGeometry":
          case "CubeGeometry":
            s = new Ts[a.type](
              a.width,
              a.height,
              a.depth,
              a.widthSegments,
              a.heightSegments,
              a.depthSegments
            );
            break;
          case "CircleGeometry":
          case "CircleBufferGeometry":
            s = new Ts[a.type](
              a.radius,
              a.segments,
              a.thetaStart,
              a.thetaLength
            );
            break;
          case "CylinderGeometry":
          case "CylinderBufferGeometry":
            s = new Ts[a.type](
              a.radiusTop,
              a.radiusBottom,
              a.height,
              a.radialSegments,
              a.heightSegments,
              a.openEnded,
              a.thetaStart,
              a.thetaLength
            );
            break;
          case "ConeGeometry":
          case "ConeBufferGeometry":
            s = new Ts[a.type](
              a.radius,
              a.height,
              a.radialSegments,
              a.heightSegments,
              a.openEnded,
              a.thetaStart,
              a.thetaLength
            );
            break;
          case "SphereGeometry":
          case "SphereBufferGeometry":
            s = new Ts[a.type](
              a.radius,
              a.widthSegments,
              a.heightSegments,
              a.phiStart,
              a.phiLength,
              a.thetaStart,
              a.thetaLength
            );
            break;
          case "DodecahedronGeometry":
          case "DodecahedronBufferGeometry":
          case "IcosahedronGeometry":
          case "IcosahedronBufferGeometry":
          case "OctahedronGeometry":
          case "OctahedronBufferGeometry":
          case "TetrahedronGeometry":
          case "TetrahedronBufferGeometry":
            s = new Ts[a.type](a.radius, a.detail);
            break;
          case "RingGeometry":
          case "RingBufferGeometry":
            s = new Ts[a.type](
              a.innerRadius,
              a.outerRadius,
              a.thetaSegments,
              a.phiSegments,
              a.thetaStart,
              a.thetaLength
            );
            break;
          case "TorusGeometry":
          case "TorusBufferGeometry":
            s = new Ts[a.type](
              a.radius,
              a.tube,
              a.radialSegments,
              a.tubularSegments,
              a.arc
            );
            break;
          case "TorusKnotGeometry":
          case "TorusKnotBufferGeometry":
            s = new Ts[a.type](
              a.radius,
              a.tube,
              a.tubularSegments,
              a.radialSegments,
              a.p,
              a.q
            );
            break;
          case "TubeGeometry":
          case "TubeBufferGeometry":
            s = new Ts[a.type](
              new Ra[a.path.type]().fromJSON(a.path),
              a.tubularSegments,
              a.radius,
              a.radialSegments,
              a.closed
            );
            break;
          case "LatheGeometry":
          case "LatheBufferGeometry":
            s = new Ts[a.type](a.points, a.segments, a.phiStart, a.phiLength);
            break;
          case "PolyhedronGeometry":
          case "PolyhedronBufferGeometry":
            s = new Ts[a.type](a.vertices, a.indices, a.radius, a.details);
            break;
          case "ShapeGeometry":
          case "ShapeBufferGeometry":
            i = [];
            for (let t = 0, n = a.shapes.length; t < n; t++) {
              const n = e[a.shapes[t]];
              i.push(n);
            }
            s = new Ts[a.type](i, a.curveSegments);
            break;
          case "ExtrudeGeometry":
          case "ExtrudeBufferGeometry":
            i = [];
            for (let t = 0, n = a.shapes.length; t < n; t++) {
              const n = e[a.shapes[t]];
              i.push(n);
            }
            const t = a.options.extrudePath;
            void 0 !== t &&
              (a.options.extrudePath = new Ra[t.type]().fromJSON(t)),
              (s = new Ts[a.type](i, a.options));
            break;
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s = r.parse(a);
            break;
          case "Geometry":
            console.error(
              'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
            );
            break;
          default:
            console.warn(
              'THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"'
            );
            continue;
        }
        (s.uuid = a.uuid),
          void 0 !== a.name && (s.name = a.name),
          !0 === s.isBufferGeometry &&
            void 0 !== a.userData &&
            (s.userData = a.userData),
          (n[a.uuid] = s);
      }
    }
    return n;
  },
  parseMaterials: function (t, e) {
    const n = {},
      i = {};
    if (void 0 !== t) {
      const r = new Xa();
      r.setTextures(e);
      for (let e = 0, o = t.length; e < o; e++) {
        const o = t[e];
        if ("MultiMaterial" === o.type) {
          const t = [];
          for (let e = 0; e < o.materials.length; e++) {
            const i = o.materials[e];
            void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)), t.push(n[i.uuid]);
          }
          i[o.uuid] = t;
        } else
          void 0 === n[o.uuid] && (n[o.uuid] = r.parse(o)),
            (i[o.uuid] = n[o.uuid]);
      }
    }
    return i;
  },
  parseAnimations: function (t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
      const i = t[n],
        r = Js.parse(i);
      void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
    }
    return e;
  },
  parseImages: function (t, e) {
    const n = this,
      i = {};
    let r;
    function o(t) {
      return (
        n.manager.itemStart(t),
        r.load(
          t,
          function () {
            n.manager.itemEnd(t);
          },
          void 0,
          function () {
            n.manager.itemError(t), n.manager.itemEnd(t);
          }
        )
      );
    }
    if (void 0 !== t && t.length > 0) {
      const s = new $s(e);
      (r = new sa(s)), r.setCrossOrigin(this.crossOrigin);
      for (let e = 0, r = t.length; e < r; e++) {
        const r = t[e],
          s = r.url;
        if (Array.isArray(s)) {
          i[r.uuid] = [];
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t],
              a = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e;
            i[r.uuid].push(o(a));
          }
        } else {
          const t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(r.url)
            ? r.url
            : n.resourcePath + r.url;
          i[r.uuid] = o(t);
        }
      }
    }
    return i;
  },
  parseTextures: function (t, e) {
    function n(t, e) {
      return "number" == typeof t
        ? t
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            t
          ),
          e[t]);
    }
    const i = {};
    if (void 0 !== t)
      for (let r = 0, o = t.length; r < o; r++) {
        const o = t[r];
        let s;
        void 0 === o.image &&
          console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
          void 0 === e[o.image] &&
            console.warn("THREE.ObjectLoader: Undefined image", o.image),
          (s = Array.isArray(e[o.image])
            ? new vn(e[o.image])
            : new u(e[o.image])),
          (s.needsUpdate = !0),
          (s.uuid = o.uuid),
          void 0 !== o.name && (s.name = o.name),
          void 0 !== o.mapping && (s.mapping = n(o.mapping, tc)),
          void 0 !== o.offset && s.offset.fromArray(o.offset),
          void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
          void 0 !== o.center && s.center.fromArray(o.center),
          void 0 !== o.rotation && (s.rotation = o.rotation),
          void 0 !== o.wrap &&
            ((s.wrapS = n(o.wrap[0], ec)), (s.wrapT = n(o.wrap[1], ec))),
          void 0 !== o.format && (s.format = o.format),
          void 0 !== o.type && (s.type = o.type),
          void 0 !== o.encoding && (s.encoding = o.encoding),
          void 0 !== o.minFilter && (s.minFilter = n(o.minFilter, nc)),
          void 0 !== o.magFilter && (s.magFilter = n(o.magFilter, nc)),
          void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
          void 0 !== o.flipY && (s.flipY = o.flipY),
          void 0 !== o.premultiplyAlpha &&
            (s.premultiplyAlpha = o.premultiplyAlpha),
          void 0 !== o.unpackAlignment &&
            (s.unpackAlignment = o.unpackAlignment),
          (i[o.uuid] = s);
      }
    return i;
  },
  parseObject: function (t, e, n) {
    let i, r, o;
    function s(t) {
      return (
        void 0 === e[t] &&
          console.warn("THREE.ObjectLoader: Undefined geometry", t),
        e[t]
      );
    }
    function a(t) {
      if (void 0 !== t) {
        if (Array.isArray(t)) {
          const e = [];
          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i];
            void 0 === n[r] &&
              console.warn("THREE.ObjectLoader: Undefined material", r),
              e.push(n[r]);
          }
          return e;
        }
        return (
          void 0 === n[t] &&
            console.warn("THREE.ObjectLoader: Undefined material", t),
          n[t]
        );
      }
    }
    switch (t.type) {
      case "Scene":
        (i = new cr()),
          void 0 !== t.background &&
            Number.isInteger(t.background) &&
            (i.background = new zt(t.background)),
          void 0 !== t.fog &&
            ("Fog" === t.fog.type
              ? (i.fog = new ar(t.fog.color, t.fog.near, t.fog.far))
              : "FogExp2" === t.fog.type &&
                (i.fog = new sr(t.fog.color, t.fog.density)));
        break;
      case "PerspectiveCamera":
        (i = new ke(t.fov, t.aspect, t.near, t.far)),
          void 0 !== t.focus && (i.focus = t.focus),
          void 0 !== t.zoom && (i.zoom = t.zoom),
          void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
          void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
          void 0 !== t.view && (i.view = Object.assign({}, t.view));
        break;
      case "OrthographicCamera":
        (i = new Ga(t.left, t.right, t.top, t.bottom, t.near, t.far)),
          void 0 !== t.zoom && (i.zoom = t.zoom),
          void 0 !== t.view && (i.view = Object.assign({}, t.view));
        break;
      case "AmbientLight":
        i = new Va(t.color, t.intensity);
        break;
      case "DirectionalLight":
        i = new ka(t.color, t.intensity);
        break;
      case "PointLight":
        i = new Ua(t.color, t.intensity, t.distance, t.decay);
        break;
      case "RectAreaLight":
        i = new ja(t.color, t.intensity, t.width, t.height);
        break;
      case "SpotLight":
        i = new za(
          t.color,
          t.intensity,
          t.distance,
          t.angle,
          t.penumbra,
          t.decay
        );
        break;
      case "HemisphereLight":
        i = new Ia(t.color, t.groundColor, t.intensity);
        break;
      case "LightProbe":
        i = new qa().fromJSON(t);
        break;
      case "SkinnedMesh":
        console.warn(
          "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."
        );
      case "Mesh":
        (r = s(t.geometry)), (o = a(t.material)), (i = new Ae(r, o));
        break;
      case "InstancedMesh":
        (r = s(t.geometry)), (o = a(t.material));
        const e = t.count,
          n = t.instanceMatrix;
        (i = new Gr(r, o, e)),
          (i.instanceMatrix = new jt(new Float32Array(n.array), 16));
        break;
      case "LOD":
        i = new Pr();
        break;
      case "Line":
        i = new Xr(s(t.geometry), a(t.material), t.mode);
        break;
      case "LineLoop":
        i = new Kr(s(t.geometry), a(t.material));
        break;
      case "LineSegments":
        i = new Jr(s(t.geometry), a(t.material));
        break;
      case "PointCloud":
      case "Points":
        i = new io(s(t.geometry), a(t.material));
        break;
      case "Sprite":
        i = new Er(a(t.material));
        break;
      case "Group":
        i = new tr();
        break;
      default:
        i = new mt();
    }
    if (
      ((i.uuid = t.uuid),
      void 0 !== t.name && (i.name = t.name),
      void 0 !== t.matrix
        ? (i.matrix.fromArray(t.matrix),
          void 0 !== t.matrixAutoUpdate &&
            (i.matrixAutoUpdate = t.matrixAutoUpdate),
          i.matrixAutoUpdate &&
            i.matrix.decompose(i.position, i.quaternion, i.scale))
        : (void 0 !== t.position && i.position.fromArray(t.position),
          void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
          void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
          void 0 !== t.scale && i.scale.fromArray(t.scale)),
      void 0 !== t.castShadow && (i.castShadow = t.castShadow),
      void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
      t.shadow &&
        (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
        void 0 !== t.shadow.normalBias &&
          (i.shadow.normalBias = t.shadow.normalBias),
        void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
        void 0 !== t.shadow.mapSize &&
          i.shadow.mapSize.fromArray(t.shadow.mapSize),
        void 0 !== t.shadow.camera &&
          (i.shadow.camera = this.parseObject(t.shadow.camera))),
      void 0 !== t.visible && (i.visible = t.visible),
      void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
      void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
      void 0 !== t.userData && (i.userData = t.userData),
      void 0 !== t.layers && (i.layers.mask = t.layers),
      void 0 !== t.children)
    ) {
      const r = t.children;
      for (let t = 0; t < r.length; t++) i.add(this.parseObject(r[t], e, n));
    }
    if ("LOD" === t.type) {
      void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
      const e = t.levels;
      for (let t = 0; t < e.length; t++) {
        const n = e[t],
          r = i.getObjectByProperty("uuid", n.object);
        void 0 !== r && i.addLevel(r, n.distance);
      }
    }
    return i;
  },
});
const tc = {
    UVMapping: 300,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307,
  },
  ec = {
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002,
  },
  nc = {
    NearestFilter: 1003,
    NearestMipmapNearestFilter: 1004,
    NearestMipmapLinearFilter: 1005,
    LinearFilter: 1006,
    LinearMipmapNearestFilter: 1007,
    LinearMipmapLinearFilter: 1008,
  };
function ic(t) {
  "undefined" == typeof createImageBitmap &&
    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
    "undefined" == typeof fetch &&
      console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
    ea.call(this, t),
    (this.options = { premultiplyAlpha: "none" });
}
function rc() {
  (this.type = "ShapePath"),
    (this.color = new zt()),
    (this.subPaths = []),
    (this.currentPath = null);
}
function oc(t) {
  (this.type = "Font"), (this.data = t);
}
function sc(t, e, n, i, r) {
  const o = r.glyphs[t] || r.glyphs["?"];
  if (!o)
    return void console.error(
      'THREE.Font: character "' +
        t +
        '" does not exists in font family ' +
        r.familyName +
        "."
    );
  const s = new rc();
  let a, c, l, h, u, d, p, f;
  if (o.o) {
    const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
    for (let r = 0, o = t.length; r < o; ) {
      switch (t[r++]) {
        case "m":
          (a = t[r++] * e + n), (c = t[r++] * e + i), s.moveTo(a, c);
          break;
        case "l":
          (a = t[r++] * e + n), (c = t[r++] * e + i), s.lineTo(a, c);
          break;
        case "q":
          (l = t[r++] * e + n),
            (h = t[r++] * e + i),
            (u = t[r++] * e + n),
            (d = t[r++] * e + i),
            s.quadraticCurveTo(u, d, l, h);
          break;
        case "b":
          (l = t[r++] * e + n),
            (h = t[r++] * e + i),
            (u = t[r++] * e + n),
            (d = t[r++] * e + i),
            (p = t[r++] * e + n),
            (f = t[r++] * e + i),
            s.bezierCurveTo(u, d, p, f, l, h);
      }
    }
  }
  return { offsetX: o.ha * e, path: s };
}
function ac(t) {
  ea.call(this, t);
}
let cc;
(ic.prototype = Object.assign(Object.create(ea.prototype), {
  constructor: ic,
  isImageBitmapLoader: !0,
  setOptions: function (t) {
    return (this.options = t), this;
  },
  load: function (t, e, n, i) {
    void 0 === t && (t = ""),
      void 0 !== this.path && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      o = Qs.get(t);
    if (void 0 !== o)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0),
        o
      );
    fetch(t)
      .then(function (t) {
        return t.blob();
      })
      .then(function (t) {
        return createImageBitmap(t, r.options);
      })
      .then(function (n) {
        Qs.add(t, n), e && e(n), r.manager.itemEnd(t);
      })
      .catch(function (e) {
        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
      }),
      r.manager.itemStart(t);
  },
})),
  Object.assign(rc.prototype, {
    moveTo: function (t, e) {
      return (
        (this.currentPath = new Ca()),
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(t, e),
        this
      );
    },
    lineTo: function (t, e) {
      return this.currentPath.lineTo(t, e), this;
    },
    quadraticCurveTo: function (t, e, n, i) {
      return this.currentPath.quadraticCurveTo(t, e, n, i), this;
    },
    bezierCurveTo: function (t, e, n, i, r, o) {
      return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
    },
    splineThru: function (t) {
      return this.currentPath.splineThru(t), this;
    },
    toShapes: function (t, e) {
      function n(t) {
        const e = [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n],
            r = new Oa();
          (r.curves = i.curves), e.push(r);
        }
        return e;
      }
      function i(t, e) {
        const n = e.length;
        let i = !1;
        for (let r = n - 1, o = 0; o < n; r = o++) {
          let n = e[r],
            s = e[o],
            a = s.x - n.x,
            c = s.y - n.y;
          if (Math.abs(c) > Number.EPSILON) {
            if (
              (c < 0 && ((n = e[o]), (a = -a), (s = e[r]), (c = -c)),
              t.y < n.y || t.y > s.y)
            )
              continue;
            if (t.y === n.y) {
              if (t.x === n.x) return !0;
            } else {
              const e = c * (t.x - n.x) - a * (t.y - n.y);
              if (0 === e) return !0;
              if (e < 0) continue;
              i = !i;
            }
          } else {
            if (t.y !== n.y) continue;
            if ((s.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= s.x))
              return !0;
          }
        }
        return i;
      }
      const r = ts.isClockWise,
        o = this.subPaths;
      if (0 === o.length) return [];
      if (!0 === e) return n(o);
      let s, a, c;
      const l = [];
      if (1 === o.length)
        return (a = o[0]), (c = new Oa()), (c.curves = a.curves), l.push(c), l;
      let h = !r(o[0].getPoints());
      h = t ? !h : h;
      const u = [],
        d = [];
      let p,
        f,
        m = [],
        g = 0;
      (d[g] = void 0), (m[g] = []);
      for (let e = 0, n = o.length; e < n; e++)
        (a = o[e]),
          (p = a.getPoints()),
          (s = r(p)),
          (s = t ? !s : s),
          s
            ? (!h && d[g] && g++,
              (d[g] = { s: new Oa(), p: p }),
              (d[g].s.curves = a.curves),
              h && g++,
              (m[g] = []))
            : m[g].push({ h: a, p: p[0] });
      if (!d[0]) return n(o);
      if (d.length > 1) {
        let t = !1;
        const e = [];
        for (let t = 0, e = d.length; t < e; t++) u[t] = [];
        for (let n = 0, r = d.length; n < r; n++) {
          const r = m[n];
          for (let o = 0; o < r.length; o++) {
            const s = r[o];
            let a = !0;
            for (let r = 0; r < d.length; r++)
              i(s.p, d[r].p) &&
                (n !== r && e.push({ froms: n, tos: r, hole: o }),
                a ? ((a = !1), u[r].push(s)) : (t = !0));
            a && u[n].push(s);
          }
        }
        e.length > 0 && (t || (m = u));
      }
      for (let t = 0, e = d.length; t < e; t++) {
        (c = d[t].s), l.push(c), (f = m[t]);
        for (let t = 0, e = f.length; t < e; t++) c.holes.push(f[t].h);
      }
      return l;
    },
  }),
  Object.assign(oc.prototype, {
    isFont: !0,
    generateShapes: function (t, e) {
      void 0 === e && (e = 100);
      const n = [],
        i = (function (t, e, n) {
          const i = Array.from ? Array.from(t) : String(t).split(""),
            r = e / n.resolution,
            o =
              (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) *
              r,
            s = [];
          let a = 0,
            c = 0;
          for (let t = 0; t < i.length; t++) {
            const e = i[t];
            if ("\n" === e) (a = 0), (c -= o);
            else {
              const t = sc(e, r, a, c, n);
              (a += t.offsetX), s.push(t.path);
            }
          }
          return s;
        })(t, e, this.data);
      for (let t = 0, e = i.length; t < e; t++)
        Array.prototype.push.apply(n, i[t].toShapes());
      return n;
    },
  }),
  (ac.prototype = Object.assign(Object.create(ea.prototype), {
    constructor: ac,
    load: function (t, e, n, i) {
      const r = this,
        o = new ia(this.manager);
      o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.load(
          t,
          function (t) {
            let n;
            try {
              n = JSON.parse(t);
            } catch (e) {
              console.warn(
                "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
              ),
                (n = JSON.parse(t.substring(65, t.length - 2)));
            }
            const i = r.parse(n);
            e && e(i);
          },
          n,
          i
        );
    },
    parse: function (t) {
      return new oc(t);
    },
  }));
const lc = {
  getContext: function () {
    return (
      void 0 === cc &&
        (cc = new (window.AudioContext || window.webkitAudioContext)()),
      cc
    );
  },
  setContext: function (t) {
    cc = t;
  },
};
function hc(t) {
  ea.call(this, t);
}
function uc(t, e, n) {
  qa.call(this, void 0, n);
  const i = new zt().set(t),
    r = new zt().set(e),
    o = new g(i.r, i.g, i.b),
    s = new g(r.r, r.g, r.b),
    a = Math.sqrt(Math.PI),
    c = a * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
    this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
}
function dc(t, e) {
  qa.call(this, void 0, e);
  const n = new zt().set(t);
  this.sh.coefficients[0]
    .set(n.r, n.g, n.b)
    .multiplyScalar(2 * Math.sqrt(Math.PI));
}
(hc.prototype = Object.assign(Object.create(ea.prototype), {
  constructor: hc,
  load: function (t, e, n, i) {
    const r = this,
      o = new ia(r.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(r.path),
      o.setRequestHeader(r.requestHeader),
      o.load(
        t,
        function (n) {
          try {
            const t = n.slice(0);
            lc.getContext().decodeAudioData(t, function (t) {
              e(t);
            });
          } catch (e) {
            i ? i(e) : console.error(e), r.manager.itemError(t);
          }
        },
        n,
        i
      );
  },
})),
  (uc.prototype = Object.assign(Object.create(qa.prototype), {
    constructor: uc,
    isHemisphereLightProbe: !0,
    copy: function (t) {
      return qa.prototype.copy.call(this, t), this;
    },
    toJSON: function (t) {
      return qa.prototype.toJSON.call(this, t);
    },
  })),
  (dc.prototype = Object.assign(Object.create(qa.prototype), {
    constructor: dc,
    isAmbientLightProbe: !0,
    copy: function (t) {
      return qa.prototype.copy.call(this, t), this;
    },
    toJSON: function (t) {
      return qa.prototype.toJSON.call(this, t);
    },
  }));
const pc = new j(),
  fc = new j();
function mc() {
  (this.type = "StereoCamera"),
    (this.aspect = 1),
    (this.eyeSep = 0.064),
    (this.cameraL = new ke()),
    this.cameraL.layers.enable(1),
    (this.cameraL.matrixAutoUpdate = !1),
    (this.cameraR = new ke()),
    this.cameraR.layers.enable(2),
    (this.cameraR.matrixAutoUpdate = !1),
    (this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null,
    });
}
Object.assign(mc.prototype, {
  update: function (t) {
    const e = this._cache;
    if (
      e.focus !== t.focus ||
      e.fov !== t.fov ||
      e.aspect !== t.aspect * this.aspect ||
      e.near !== t.near ||
      e.far !== t.far ||
      e.zoom !== t.zoom ||
      e.eyeSep !== this.eyeSep
    ) {
      (e.focus = t.focus),
        (e.fov = t.fov),
        (e.aspect = t.aspect * this.aspect),
        (e.near = t.near),
        (e.far = t.far),
        (e.zoom = t.zoom),
        (e.eyeSep = this.eyeSep);
      const n = t.projectionMatrix.clone(),
        i = e.eyeSep / 2,
        r = (i * e.near) / e.focus,
        s = (e.near * Math.tan(o.DEG2RAD * e.fov * 0.5)) / e.zoom;
      let a, c;
      (fc.elements[12] = -i),
        (pc.elements[12] = i),
        (a = -s * e.aspect + r),
        (c = s * e.aspect + r),
        (n.elements[0] = (2 * e.near) / (c - a)),
        (n.elements[8] = (c + a) / (c - a)),
        this.cameraL.projectionMatrix.copy(n),
        (a = -s * e.aspect - r),
        (c = s * e.aspect - r),
        (n.elements[0] = (2 * e.near) / (c - a)),
        (n.elements[8] = (c + a) / (c - a)),
        this.cameraR.projectionMatrix.copy(n);
    }
    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(fc),
      this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(pc);
  },
});
class gc {
  constructor(t) {
    (this.autoStart = void 0 === t || t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = (
      "undefined" == typeof performance ? Date : performance
    ).now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e = ("undefined" == typeof performance ? Date : performance).now();
      (t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t);
    }
    return t;
  }
}
const vc = new g(),
  yc = new m(),
  xc = new g(),
  bc = new g();
class _c extends mt {
  constructor(t) {
    super(),
      (this.type = "Audio"),
      (this.listener = t),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = t),
      this.connect(),
      this
    );
  }
  setMediaElementSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(t)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(t)),
      this.connect(),
      this
    );
  }
  setBuffer(t) {
    return (
      (this.buffer = t),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(t) {
    if ((void 0 === t && (t = 0), !0 === this.isPlaying))
      return void console.warn("THREE.Audio: Audio is already playing.");
    if (!1 === this.hasPlaybackControl)
      return void console.warn(
        "THREE.Audio: this Audio has no playback control."
      );
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return (
      (e.buffer = this.buffer),
      (e.loop = this.loop),
      (e.loopStart = this.loopStart),
      (e.loopEnd = this.loopEnd),
      (e.onended = this.onEnded.bind(this)),
      e.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = e),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (!1 !== this.hasPlaybackControl)
      return (
        !0 === this.isPlaying &&
          ((this._progress +=
            Math.max(this.context.currentTime - this._startedAt, 0) *
            this.playbackRate),
          !0 === this.loop &&
            (this._progress =
              this._progress % (this.duration || this.buffer.duration)),
          this.source.stop(),
          (this.source.onended = null),
          (this.isPlaying = !1)),
        this
      );
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  stop() {
    if (!1 !== this.hasPlaybackControl)
      return (
        (this._progress = 0),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1),
        this
      );
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].disconnect(this.filters[t]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(t) {
    return (
      t || (t = []),
      !0 === this._connected
        ? (this.disconnect(), (this.filters = t), this.connect())
        : (this.filters = t),
      this
    );
  }
  setDetune(t) {
    if (((this.detune = t), void 0 !== this.source.detune))
      return (
        !0 === this.isPlaying &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(t) {
    return this.setFilters(t ? [t] : []);
  }
  setPlaybackRate(t) {
    if (!1 !== this.hasPlaybackControl)
      return (
        (this.playbackRate = t),
        !0 === this.isPlaying &&
          this.source.playbackRate.setTargetAtTime(
            this.playbackRate,
            this.context.currentTime,
            0.01
          ),
        this
      );
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return !1 === this.hasPlaybackControl
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(t) {
    if (!1 !== this.hasPlaybackControl)
      return (
        (this.loop = t),
        !0 === this.isPlaying && (this.source.loop = this.loop),
        this
      );
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  setLoopStart(t) {
    return (this.loopStart = t), this;
  }
  setLoopEnd(t) {
    return (this.loopEnd = t), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    );
  }
}
const wc = new g(),
  Mc = new m(),
  Sc = new g(),
  Tc = new g();
class Ec {
  constructor(t, e) {
    (this.analyser = t.context.createAnalyser()),
      (this.analyser.fftSize = void 0 !== e ? e : 2048),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      t.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let t = 0;
    const e = this.getFrequencyData();
    for (let n = 0; n < e.length; n++) t += e[n];
    return t / e.length;
  }
}
function Ac(t, e, n) {
  let i, r, o;
  switch (((this.binding = t), (this.valueSize = n), e)) {
    case "quaternion":
      (i = this._slerp),
        (r = this._slerpAdditive),
        (o = this._setAdditiveIdentityQuaternion),
        (this.buffer = new Float64Array(6 * n)),
        (this._workIndex = 5);
      break;
    case "string":
    case "bool":
      (i = this._select),
        (r = this._select),
        (o = this._setAdditiveIdentityOther),
        (this.buffer = new Array(5 * n));
      break;
    default:
      (i = this._lerp),
        (r = this._lerpAdditive),
        (o = this._setAdditiveIdentityNumeric),
        (this.buffer = new Float64Array(5 * n));
  }
  (this._mixBufferRegion = i),
    (this._mixBufferRegionAdditive = r),
    (this._setIdentity = o),
    (this._origIndex = 3),
    (this._addIndex = 4),
    (this.cumulativeWeight = 0),
    (this.cumulativeWeightAdditive = 0),
    (this.useCount = 0),
    (this.referenceCount = 0);
}
Object.assign(Ac.prototype, {
  accumulate: function (t, e) {
    const n = this.buffer,
      i = this.valueSize,
      r = t * i + i;
    let o = this.cumulativeWeight;
    if (0 === o) {
      for (let t = 0; t !== i; ++t) n[r + t] = n[t];
      o = e;
    } else {
      o += e;
      const t = e / o;
      this._mixBufferRegion(n, r, 0, t, i);
    }
    this.cumulativeWeight = o;
  },
  accumulateAdditive: function (t) {
    const e = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(),
      this._mixBufferRegionAdditive(e, i, 0, t, n),
      (this.cumulativeWeightAdditive += t);
  },
  apply: function (t) {
    const e = this.valueSize,
      n = this.buffer,
      i = t * e + e,
      r = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      s = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)
    ) {
      const t = e * this._origIndex;
      this._mixBufferRegion(n, i, t, 1 - r, e);
    }
    o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
    for (let t = e, r = e + e; t !== r; ++t)
      if (n[t] !== n[t + e]) {
        s.setValue(n, i);
        break;
      }
  },
  saveOriginalState: function () {
    const t = this.binding,
      e = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    t.getValue(e, i);
    for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  },
  restoreOriginalState: function () {
    const t = 3 * this.valueSize;
    this.binding.setValue(this.buffer, t);
  },
  _setAdditiveIdentityNumeric: function () {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize;
    for (let n = t; n < e; n++) this.buffer[n] = 0;
  },
  _setAdditiveIdentityQuaternion: function () {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  },
  _setAdditiveIdentityOther: function () {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  },
  _select: function (t, e, n, i, r) {
    if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
  },
  _slerp: function (t, e, n, i) {
    m.slerpFlat(t, e, t, e, t, n, i);
  },
  _slerpAdditive: function (t, e, n, i, r) {
    const o = this._workIndex * r;
    m.multiplyQuaternionsFlat(t, o, t, e, t, n),
      m.slerpFlat(t, e, t, e, t, o, i);
  },
  _lerp: function (t, e, n, i, r) {
    const o = 1 - i;
    for (let s = 0; s !== r; ++s) {
      const r = e + s;
      t[r] = t[r] * o + t[n + s] * i;
    }
  },
  _lerpAdditive: function (t, e, n, i, r) {
    for (let o = 0; o !== r; ++o) {
      const r = e + o;
      t[r] = t[r] + t[n + o] * i;
    }
  },
});
const Lc = new RegExp("[\\[\\]\\.:\\/]", "g"),
  Rc = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
  Pc = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
  Cc = /(WCOD+)?/.source.replace("WCOD", Rc),
  Oc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
  Nc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
  Ic = new RegExp("^" + Pc + Cc + Oc + Nc + "$"),
  Dc = ["material", "materials", "bones"];
function Bc(t, e, n) {
  const i = n || zc.parseTrackName(e);
  (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
}
function zc(t, e, n) {
  (this.path = e),
    (this.parsedPath = n || zc.parseTrackName(e)),
    (this.node = zc.findNode(t, this.parsedPath.nodeName) || t),
    (this.rootNode = t);
}
function Fc() {
  (this.uuid = o.generateUUID()),
    (this._objects = Array.prototype.slice.call(arguments)),
    (this.nCachedObjects_ = 0);
  const t = {};
  this._indicesByUUID = t;
  for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
  (this._paths = []),
    (this._parsedPaths = []),
    (this._bindings = []),
    (this._bindingsIndicesByPath = {});
  const e = this;
  this.stats = {
    objects: {
      get total() {
        return e._objects.length;
      },
      get inUse() {
        return this.total - e.nCachedObjects_;
      },
    },
    get bindingsPerObject() {
      return e._bindings.length;
    },
  };
}
Object.assign(Bc.prototype, {
  getValue: function (t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    void 0 !== i && i.getValue(t, e);
  },
  setValue: function (t, e) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(t, e);
  },
  bind: function () {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  },
  unbind: function () {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  },
}),
  Object.assign(zc, {
    Composite: Bc,
    create: function (t, e, n) {
      return t && t.isAnimationObjectGroup
        ? new zc.Composite(t, e, n)
        : new zc(t, e, n);
    },
    sanitizeNodeName: function (t) {
      return t.replace(/\s/g, "_").replace(Lc, "");
    },
    parseTrackName: function (t) {
      const e = Ic.exec(t);
      if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6],
        },
        i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== i && -1 !== i) {
        const t = n.nodeName.substring(i + 1);
        -1 !== Dc.indexOf(t) &&
          ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
      }
      if (null === n.propertyName || 0 === n.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + t
        );
      return n;
    },
    findNode: function (t, e) {
      if (
        !e ||
        "" === e ||
        "." === e ||
        -1 === e ||
        e === t.name ||
        e === t.uuid
      )
        return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (void 0 !== n) return n;
      }
      if (t.children) {
        const n = function (t) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (r.name === e || r.uuid === e) return r;
              const o = n(r.children);
              if (o) return o;
            }
            return null;
          },
          i = n(t.children);
        if (i) return i;
      }
      return null;
    },
  }),
  Object.assign(zc.prototype, {
    _getValue_unavailable: function () {},
    _setValue_unavailable: function () {},
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    },
    Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
    GetterByBindingType: [
      function (t, e) {
        t[e] = this.node[this.propertyName];
      },
      function (t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
      },
      function (t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      },
      function (t, e) {
        this.resolvedProperty.toArray(t, e);
      },
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function (t, e) {
          this.targetObject[this.propertyName] = t[e];
        },
        function (t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0);
        },
        function (t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        },
      ],
      [
        function (t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        },
        function (t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.needsUpdate = !0;
        },
        function (t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        },
      ],
      [
        function (t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        },
        function (t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0);
        },
        function (t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        },
      ],
      [
        function (t, e) {
          this.resolvedProperty.fromArray(t, e);
        },
        function (t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0);
        },
        function (t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        },
      ],
    ],
    getValue: function (t, e) {
      this.bind(), this.getValue(t, e);
    },
    setValue: function (t, e) {
      this.bind(), this.setValue(t, e);
    },
    bind: function () {
      let t = this.node;
      const e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName;
      let r = e.propertyIndex;
      if (
        (t ||
          ((t = zc.findNode(this.rootNode, e.nodeName) || this.rootNode),
          (this.node = t)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !t)
      )
        return void console.error(
          "THREE.PropertyBinding: Trying to update node for track: " +
            this.path +
            " but it wasn't found."
        );
      if (n) {
        let i = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === i) {
                i = e;
                break;
              }
            break;
          default:
            if (void 0 === t[n])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
            t = t[n];
        }
        if (void 0 !== i) {
          if (void 0 === t[i])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              t
            );
          t = t[i];
        }
      }
      const o = t[i];
      if (void 0 === o) {
        const n = e.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            n +
            "." +
            i +
            " but it wasn't found.",
          t
        );
      }
      let s = this.Versioning.None;
      (this.targetObject = t),
        void 0 !== t.needsUpdate
          ? (s = this.Versioning.NeedsUpdate)
          : void 0 !== t.matrixWorldNeedsUpdate &&
            (s = this.Versioning.MatrixWorldNeedsUpdate);
      let a = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
          if (!t.geometry.isBufferGeometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
              this
            );
          if (!t.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
          void 0 !== t.morphTargetDictionary[r] &&
            (r = t.morphTargetDictionary[r]);
        }
        (a = this.BindingType.ArrayElement),
          (this.resolvedProperty = o),
          (this.propertyIndex = r);
      } else
        void 0 !== o.fromArray && void 0 !== o.toArray
          ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
          : Array.isArray(o)
          ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = i);
      (this.getValue = this.GetterByBindingType[a]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[a][s]);
    },
    unbind: function () {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    },
  }),
  Object.assign(zc.prototype, {
    _getValue_unbound: zc.prototype.getValue,
    _setValue_unbound: zc.prototype.setValue,
  }),
  Object.assign(Fc.prototype, {
    isAnimationObjectGroup: !0,
    add: function () {
      const t = this._objects,
        e = this._indicesByUUID,
        n = this._paths,
        i = this._parsedPaths,
        r = this._bindings,
        o = r.length;
      let s,
        a = t.length,
        c = this.nCachedObjects_;
      for (let l = 0, h = arguments.length; l !== h; ++l) {
        const h = arguments[l],
          u = h.uuid;
        let d = e[u];
        if (void 0 === d) {
          (d = a++), (e[u] = d), t.push(h);
          for (let t = 0, e = o; t !== e; ++t) r[t].push(new zc(h, n[t], i[t]));
        } else if (d < c) {
          s = t[d];
          const a = --c,
            l = t[a];
          (e[l.uuid] = d), (t[d] = l), (e[u] = a), (t[a] = h);
          for (let t = 0, e = o; t !== e; ++t) {
            const e = r[t],
              o = e[a];
            let s = e[d];
            (e[d] = o), void 0 === s && (s = new zc(h, n[t], i[t])), (e[a] = s);
          }
        } else
          t[d] !== s &&
            console.error(
              "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
            );
      }
      this.nCachedObjects_ = c;
    },
    remove: function () {
      const t = this._objects,
        e = this._indicesByUUID,
        n = this._bindings,
        i = n.length;
      let r = this.nCachedObjects_;
      for (let o = 0, s = arguments.length; o !== s; ++o) {
        const s = arguments[o],
          a = s.uuid,
          c = e[a];
        if (void 0 !== c && c >= r) {
          const o = r++,
            l = t[o];
          (e[l.uuid] = c), (t[c] = l), (e[a] = o), (t[o] = s);
          for (let t = 0, e = i; t !== e; ++t) {
            const e = n[t],
              i = e[o],
              r = e[c];
            (e[c] = i), (e[o] = r);
          }
        }
      }
      this.nCachedObjects_ = r;
    },
    uncache: function () {
      const t = this._objects,
        e = this._indicesByUUID,
        n = this._bindings,
        i = n.length;
      let r = this.nCachedObjects_,
        o = t.length;
      for (let s = 0, a = arguments.length; s !== a; ++s) {
        const a = arguments[s].uuid,
          c = e[a];
        if (void 0 !== c)
          if ((delete e[a], c < r)) {
            const s = --r,
              a = t[s],
              l = --o,
              h = t[l];
            (e[a.uuid] = c), (t[c] = a), (e[h.uuid] = s), (t[s] = h), t.pop();
            for (let t = 0, e = i; t !== e; ++t) {
              const e = n[t],
                i = e[s],
                r = e[l];
              (e[c] = i), (e[s] = r), e.pop();
            }
          } else {
            const r = --o,
              s = t[r];
            (e[s.uuid] = c), (t[c] = s), t.pop();
            for (let t = 0, e = i; t !== e; ++t) {
              const e = n[t];
              (e[c] = e[r]), e.pop();
            }
          }
      }
      this.nCachedObjects_ = r;
    },
    subscribe_: function (t, e) {
      const n = this._bindingsIndicesByPath;
      let i = n[t];
      const r = this._bindings;
      if (void 0 !== i) return r[i];
      const o = this._paths,
        s = this._parsedPaths,
        a = this._objects,
        c = a.length,
        l = this.nCachedObjects_,
        h = new Array(c);
      (i = r.length), (n[t] = i), o.push(t), s.push(e), r.push(h);
      for (let n = l, i = a.length; n !== i; ++n) {
        const i = a[n];
        h[n] = new zc(i, t, e);
      }
      return h;
    },
    unsubscribe_: function (t) {
      const e = this._bindingsIndicesByPath,
        n = e[t];
      if (void 0 !== n) {
        const i = this._paths,
          r = this._parsedPaths,
          o = this._bindings,
          s = o.length - 1,
          a = o[s];
        (e[t[s]] = n),
          (o[n] = a),
          o.pop(),
          (r[n] = r[s]),
          r.pop(),
          (i[n] = i[s]),
          i.pop();
      }
    },
  });
class Uc {
  constructor(t, e, n, i) {
    (this._mixer = t),
      (this._clip = e),
      (this._localRoot = n || null),
      (this.blendMode = i || e.blendMode);
    const r = e.tracks,
      o = r.length,
      s = new Array(o),
      a = { endingStart: 2400, endingEnd: 2400 };
    for (let t = 0; t !== o; ++t) {
      const e = r[t].createInterpolant(null);
      (s[t] = e), (e.settings = a);
    }
    (this._interpolantSettings = a),
      (this._interpolants = s),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      0 !== this.timeScale &&
      null === this._startTime &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t) {
    return (this._startTime = t), this;
  }
  setLoop(t, e) {
    return (this.loop = t), (this.repetitions = e), this;
  }
  setEffectiveWeight(t) {
    return (
      (this.weight = t),
      (this._effectiveWeight = this.enabled ? t : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1);
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0);
  }
  crossFadeFrom(t, e, n) {
    if ((t.fadeOut(e), this.fadeIn(e), n)) {
      const n = this._clip.duration,
        i = t._clip.duration,
        r = i / n,
        o = n / i;
      t.warp(1, r, e), this.warp(o, 1, e);
    }
    return this;
  }
  crossFadeTo(t, e, n) {
    return t.crossFadeFrom(this, e, n);
  }
  stopFading() {
    const t = this._weightInterpolant;
    return (
      null !== t &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  setEffectiveTimeScale(t) {
    return (
      (this.timeScale = t),
      (this._effectiveTimeScale = this.paused ? 0 : t),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping();
  }
  syncWith(t) {
    return (
      (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
    );
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  }
  warp(t, e, n) {
    const i = this._mixer,
      r = i.time,
      o = this.timeScale;
    let s = this._timeScaleInterpolant;
    null === s &&
      ((s = i._lendControlInterpolant()), (this._timeScaleInterpolant = s));
    const a = s.parameterPositions,
      c = s.sampleValues;
    return (a[0] = r), (a[1] = r + n), (c[0] = t / o), (c[1] = e / o), this;
  }
  stopWarping() {
    const t = this._timeScaleInterpolant;
    return (
      null !== t &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t, e, n, i) {
    if (!this.enabled) return void this._updateWeight(t);
    const r = this._startTime;
    if (null !== r) {
      const i = (t - r) * n;
      if (i < 0 || 0 === n) return;
      (this._startTime = null), (e = n * i);
    }
    e *= this._updateTimeScale(t);
    const o = this._updateTime(e),
      s = this._updateWeight(t);
    if (s > 0) {
      const t = this._interpolants,
        e = this._propertyBindings;
      switch (this.blendMode) {
        case 2501:
          for (let n = 0, i = t.length; n !== i; ++n)
            t[n].evaluate(o), e[n].accumulateAdditive(s);
          break;
        case 2500:
        default:
          for (let n = 0, r = t.length; n !== r; ++n)
            t[n].evaluate(o), e[n].accumulate(i, s);
      }
    }
  }
  _updateWeight(t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;
      if (null !== n) {
        const i = n.evaluate(t)[0];
        (e *= i),
          t > n.parameterPositions[1] &&
            (this.stopFading(), 0 === i && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = e), e;
  }
  _updateTimeScale(t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (null !== n) {
        (e *= n.evaluate(t)[0]),
          t > n.parameterPositions[1] &&
            (this.stopWarping(),
            0 === e ? (this.paused = !0) : (this.timeScale = e));
      }
    }
    return (this._effectiveTimeScale = e), e;
  }
  _updateTime(t) {
    const e = this._clip.duration,
      n = this.loop;
    let i = this.time + t,
      r = this._loopCount;
    const o = 2202 === n;
    if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
    if (2200 === n) {
      -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      t: {
        if (i >= e) i = e;
        else {
          if (!(i < 0)) {
            this.time = i;
            break t;
          }
          i = 0;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (-1 === r &&
          (t >= 0
            ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
            : this._setEndings(0 === this.repetitions, !0, o)),
        i >= e || i < 0)
      ) {
        const n = Math.floor(i / e);
        (i -= e * n), (r += Math.abs(n));
        const s = this.repetitions - r;
        if (s <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = t > 0 ? e : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t > 0 ? 1 : -1,
            });
        else {
          if (1 === s) {
            const e = t < 0;
            this._setEndings(e, !e, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = r),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: n,
            });
        }
      } else this.time = i;
      if (o && 1 == (1 & r)) return e - i;
    }
    return i;
  }
  _setEndings(t, e, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = 2401), (i.endingEnd = 2401))
      : ((i.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402),
        (i.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
  }
  _scheduleFading(t, e, n) {
    const i = this._mixer,
      r = i.time;
    let o = this._weightInterpolant;
    null === o &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const s = o.parameterPositions,
      a = o.sampleValues;
    return (s[0] = r), (a[0] = e), (s[1] = r + t), (a[1] = n), this;
  }
}
function Gc(t) {
  (this._root = t),
    this._initMemoryManager(),
    (this._accuIndex = 0),
    (this.time = 0),
    (this.timeScale = 1);
}
Gc.prototype = Object.assign(Object.create(n.prototype), {
  constructor: Gc,
  _bindAction: function (t, e) {
    const n = t._localRoot || this._root,
      i = t._clip.tracks,
      r = i.length,
      o = t._propertyBindings,
      s = t._interpolants,
      a = n.uuid,
      c = this._bindingsByRootAndName;
    let l = c[a];
    void 0 === l && ((l = {}), (c[a] = l));
    for (let t = 0; t !== r; ++t) {
      const r = i[t],
        c = r.name;
      let h = l[c];
      if (void 0 !== h) o[t] = h;
      else {
        if (((h = o[t]), void 0 !== h)) {
          null === h._cacheIndex &&
            (++h.referenceCount, this._addInactiveBinding(h, a, c));
          continue;
        }
        const i = e && e._propertyBindings[t].binding.parsedPath;
        (h = new Ac(zc.create(n, c, i), r.ValueTypeName, r.getValueSize())),
          ++h.referenceCount,
          this._addInactiveBinding(h, a, c),
          (o[t] = h);
      }
      s[t].resultBuffer = h.buffer;
    }
  },
  _activateAction: function (t) {
    if (!this._isActiveAction(t)) {
      if (null === t._cacheIndex) {
        const e = (t._localRoot || this._root).uuid,
          n = t._clip.uuid,
          i = this._actionsByClip[n];
        this._bindAction(t, i && i.knownActions[0]),
          this._addInactiveAction(t, n, e);
      }
      const e = t._propertyBindings;
      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t];
        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState());
      }
      this._lendAction(t);
    }
  },
  _deactivateAction: function (t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let t = 0, n = e.length; t !== n; ++t) {
        const n = e[t];
        0 == --n.useCount &&
          (n.restoreOriginalState(), this._takeBackBinding(n));
      }
      this._takeBackAction(t);
    }
  },
  _initMemoryManager: function () {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        },
      },
    };
  },
  _isActiveAction: function (t) {
    const e = t._cacheIndex;
    return null !== e && e < this._nActiveActions;
  },
  _addInactiveAction: function (t, e, n) {
    const i = this._actions,
      r = this._actionsByClip;
    let o = r[e];
    if (void 0 === o)
      (o = { knownActions: [t], actionByRoot: {} }),
        (t._byClipCacheIndex = 0),
        (r[e] = o);
    else {
      const e = o.knownActions;
      (t._byClipCacheIndex = e.length), e.push(t);
    }
    (t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
  },
  _removeInactiveAction: function (t) {
    const e = this._actions,
      n = e[e.length - 1],
      i = t._cacheIndex;
    (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
    const r = t._clip.uuid,
      o = this._actionsByClip,
      s = o[r],
      a = s.knownActions,
      c = a[a.length - 1],
      l = t._byClipCacheIndex;
    (c._byClipCacheIndex = l),
      (a[l] = c),
      a.pop(),
      (t._byClipCacheIndex = null);
    delete s.actionByRoot[(t._localRoot || this._root).uuid],
      0 === a.length && delete o[r],
      this._removeInactiveBindingsForAction(t);
  },
  _removeInactiveBindingsForAction: function (t) {
    const e = t._propertyBindings;
    for (let t = 0, n = e.length; t !== n; ++t) {
      const n = e[t];
      0 == --n.referenceCount && this._removeInactiveBinding(n);
    }
  },
  _lendAction: function (t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = this._nActiveActions++,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _takeBackAction: function (t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = --this._nActiveActions,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _addInactiveBinding: function (t, e, n) {
    const i = this._bindingsByRootAndName,
      r = this._bindings;
    let o = i[e];
    void 0 === o && ((o = {}), (i[e] = o)),
      (o[n] = t),
      (t._cacheIndex = r.length),
      r.push(t);
  },
  _removeInactiveBinding: function (t) {
    const e = this._bindings,
      n = t.binding,
      i = n.rootNode.uuid,
      r = n.path,
      o = this._bindingsByRootAndName,
      s = o[i],
      a = e[e.length - 1],
      c = t._cacheIndex;
    (a._cacheIndex = c),
      (e[c] = a),
      e.pop(),
      delete s[r],
      0 === Object.keys(s).length && delete o[i];
  },
  _lendBinding: function (t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = this._nActiveBindings++,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _takeBackBinding: function (t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = --this._nActiveBindings,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  },
  _lendControlInterpolant: function () {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++;
    let n = t[e];
    return (
      void 0 === n &&
        ((n = new Gs(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (n.__cacheIndex = e),
        (t[e] = n)),
      n
    );
  },
  _takeBackControlInterpolant: function (t) {
    const e = this._controlInterpolants,
      n = t.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      r = e[i];
    (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  clipAction: function (t, e, n) {
    const i = e || this._root,
      r = i.uuid;
    let o = "string" == typeof t ? Js.findByName(i, t) : t;
    const s = null !== o ? o.uuid : t,
      a = this._actionsByClip[s];
    let c = null;
    if ((void 0 === n && (n = null !== o ? o.blendMode : 2500), void 0 !== a)) {
      const t = a.actionByRoot[r];
      if (void 0 !== t && t.blendMode === n) return t;
      (c = a.knownActions[0]), null === o && (o = c._clip);
    }
    if (null === o) return null;
    const l = new Uc(this, o, e, n);
    return this._bindAction(l, c), this._addInactiveAction(l, s, r), l;
  },
  existingAction: function (t, e) {
    const n = e || this._root,
      i = n.uuid,
      r = "string" == typeof t ? Js.findByName(n, t) : t,
      o = r ? r.uuid : t,
      s = this._actionsByClip[o];
    return (void 0 !== s && s.actionByRoot[i]) || null;
  },
  stopAllAction: function () {
    const t = this._actions;
    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
    return this;
  },
  update: function (t) {
    t *= this.timeScale;
    const e = this._actions,
      n = this._nActiveActions,
      i = (this.time += t),
      r = Math.sign(t),
      o = (this._accuIndex ^= 1);
    for (let s = 0; s !== n; ++s) {
      e[s]._update(i, t, r, o);
    }
    const s = this._bindings,
      a = this._nActiveBindings;
    for (let t = 0; t !== a; ++t) s[t].apply(o);
    return this;
  },
  setTime: function (t) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(t);
  },
  getRoot: function () {
    return this._root;
  },
  uncacheClip: function (t) {
    const e = this._actions,
      n = t.uuid,
      i = this._actionsByClip,
      r = i[n];
    if (void 0 !== r) {
      const t = r.knownActions;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const i = t[n];
        this._deactivateAction(i);
        const r = i._cacheIndex,
          o = e[e.length - 1];
        (i._cacheIndex = null),
          (i._byClipCacheIndex = null),
          (o._cacheIndex = r),
          (e[r] = o),
          e.pop(),
          this._removeInactiveBindingsForAction(i);
      }
      delete i[n];
    }
  },
  uncacheRoot: function (t) {
    const e = t.uuid,
      n = this._actionsByClip;
    for (const t in n) {
      const i = n[t].actionByRoot[e];
      void 0 !== i &&
        (this._deactivateAction(i), this._removeInactiveAction(i));
    }
    const i = this._bindingsByRootAndName[e];
    if (void 0 !== i)
      for (const t in i) {
        const e = i[t];
        e.restoreOriginalState(), this._removeInactiveBinding(e);
      }
  },
  uncacheAction: function (t, e) {
    const n = this.existingAction(t, e);
    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
  },
});
class Hc {
  constructor(t) {
    "string" == typeof t &&
      (console.warn("THREE.Uniform: Type parameter is no longer needed."),
      (t = arguments[1])),
      (this.value = t);
  }
  clone() {
    return new Hc(
      void 0 === this.value.clone ? this.value : this.value.clone()
    );
  }
}
function kc(t, e, n) {
  lr.call(this, t, e), (this.meshPerAttribute = n || 1);
}
function Vc(t, e, n, i, r) {
  (this.buffer = t),
    (this.type = e),
    (this.itemSize = n),
    (this.elementSize = i),
    (this.count = r),
    (this.version = 0);
}
function jc(t, e, n, i) {
  (this.ray = new V(t, e)),
    (this.near = n || 0),
    (this.far = i || 1 / 0),
    (this.camera = null),
    (this.layers = new et()),
    (this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {},
    }),
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function () {
          return (
            console.warn(
              "THREE.Raycaster: params.PointCloud has been renamed to params.Points."
            ),
            this.Points
          );
        },
      },
    });
}
function Wc(t, e) {
  return t.distance - e.distance;
}
function qc(t, e, n, i) {
  if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
    const i = t.children;
    for (let t = 0, r = i.length; t < r; t++) qc(i[t], e, n, !0);
  }
}
(kc.prototype = Object.assign(Object.create(lr.prototype), {
  constructor: kc,
  isInstancedInterleavedBuffer: !0,
  copy: function (t) {
    return (
      lr.prototype.copy.call(this, t),
      (this.meshPerAttribute = t.meshPerAttribute),
      this
    );
  },
  clone: function (t) {
    const e = lr.prototype.clone.call(this, t);
    return (e.meshPerAttribute = this.meshPerAttribute), e;
  },
  toJSON: function (t) {
    const e = lr.prototype.toJSON.call(this, t);
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    );
  },
})),
  Object.defineProperty(Vc.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++;
    },
  }),
  Object.assign(Vc.prototype, {
    isGLBufferAttribute: !0,
    setBuffer: function (t) {
      return (this.buffer = t), this;
    },
    setType: function (t, e) {
      return (this.type = t), (this.elementSize = e), this;
    },
    setItemSize: function (t) {
      return (this.itemSize = t), this;
    },
    setCount: function (t) {
      return (this.count = t), this;
    },
  }),
  Object.assign(jc.prototype, {
    set: function (t, e) {
      this.ray.set(t, e);
    },
    setFromCamera: function (t, e) {
      e && e.isPerspectiveCamera
        ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
          this.ray.direction
            .set(t.x, t.y, 0.5)
            .unproject(e)
            .sub(this.ray.origin)
            .normalize(),
          (this.camera = e))
        : e && e.isOrthographicCamera
        ? (this.ray.origin
            .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
            .unproject(e),
          this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
          (this.camera = e))
        : console.error("THREE.Raycaster: Unsupported camera type.");
    },
    intersectObject: function (t, e, n) {
      const i = n || [];
      return qc(t, this, i, e), i.sort(Wc), i;
    },
    intersectObjects: function (t, e, n) {
      const i = n || [];
      if (!1 === Array.isArray(t))
        return (
          console.warn(
            "THREE.Raycaster.intersectObjects: objects is not an Array."
          ),
          i
        );
      for (let n = 0, r = t.length; n < r; n++) qc(t[n], this, i, e);
      return i.sort(Wc), i;
    },
  });
class Xc {
  constructor(t = 1, e = 0, n = 0) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this;
  }
  set(t, e, n) {
    return (this.radius = t), (this.phi = e), (this.theta = n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this
    );
  }
  makeSafe() {
    const t = 1e-6;
    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, n) {
    return (
      (this.radius = Math.sqrt(t * t + e * e + n * n)),
      0 === this.radius
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(t, n)),
          (this.phi = Math.acos(o.clamp(e / this.radius, -1, 1)))),
      this
    );
  }
}
const Yc = new s();
class Zc {
  constructor(t, e) {
    Object.defineProperty(this, "isBox2", { value: !0 }),
      (this.min = void 0 !== t ? t : new s(1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new s(-1 / 0, -1 / 0));
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = Yc.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Box2: .getCenter() target is now required"),
        (t = new s())),
      this.isEmpty()
        ? t.set(0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5)
    );
  }
  getSize(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Box2: .getSize() target is now required"),
        (t = new s())),
      this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    );
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  containsPoint(t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y
    );
  }
  getParameter(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Box2: .getParameter() target is now required"),
        (e = new s())),
      e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y)
      )
    );
  }
  intersectsBox(t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y
    );
  }
  clampPoint(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Box2: .clampPoint() target is now required"),
        (e = new s())),
      e.copy(t).clamp(this.min, this.max)
    );
  }
  distanceToPoint(t) {
    return Yc.copy(t).clamp(this.min, this.max).sub(t).length();
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const Jc = new g(),
  Kc = new g();
class Qc {
  constructor(t, e) {
    (this.start = void 0 !== t ? t : new g()),
      (this.end = void 0 !== e ? e : new g());
  }
  set(t, e) {
    return this.start.copy(t), this.end.copy(e), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.start.copy(t.start), this.end.copy(t.end), this;
  }
  getCenter(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Line3: .getCenter() target is now required"),
        (t = new g())),
      t.addVectors(this.start, this.end).multiplyScalar(0.5)
    );
  }
  delta(t) {
    return (
      void 0 === t &&
        (console.warn("THREE.Line3: .delta() target is now required"),
        (t = new g())),
      t.subVectors(this.end, this.start)
    );
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, e) {
    return (
      void 0 === e &&
        (console.warn("THREE.Line3: .at() target is now required"),
        (e = new g())),
      this.delta(e).multiplyScalar(t).add(this.start)
    );
  }
  closestPointToPointParameter(t, e) {
    Jc.subVectors(t, this.start), Kc.subVectors(this.end, this.start);
    const n = Kc.dot(Kc);
    let i = Kc.dot(Jc) / n;
    return e && (i = o.clamp(i, 0, 1)), i;
  }
  closestPointToPoint(t, e, n) {
    const i = this.closestPointToPointParameter(t, e);
    return (
      void 0 === n &&
        (console.warn(
          "THREE.Line3: .closestPointToPoint() target is now required"
        ),
        (n = new g())),
      this.delta(n).multiplyScalar(i).add(this.start)
    );
  }
  applyMatrix4(t) {
    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
  }
  equals(t) {
    return t.start.equals(this.start) && t.end.equals(this.end);
  }
}
function $c(t) {
  mt.call(this),
    (this.material = t),
    (this.render = function () {}),
    (this.hasPositions = !1),
    (this.hasNormals = !1),
    (this.hasColors = !1),
    (this.hasUvs = !1),
    (this.positionArray = null),
    (this.normalArray = null),
    (this.colorArray = null),
    (this.uvArray = null),
    (this.count = 0);
}
($c.prototype = Object.create(mt.prototype)),
  ($c.prototype.constructor = $c),
  ($c.prototype.isImmediateRenderObject = !0);
const tl = new g();
const el = new g(),
  nl = new j(),
  il = new j();
class rl extends Jr {
  constructor(t) {
    const e = ol(t),
      n = new le(),
      i = [],
      r = [],
      o = new zt(0, 0, 1),
      s = new zt(0, 1, 0);
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      n.parent &&
        n.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        r.push(o.r, o.g, o.b),
        r.push(s.r, s.g, s.b));
    }
    n.setAttribute("position", new Qt(i, 3)),
      n.setAttribute("color", new Qt(r, 3));
    super(
      n,
      new Hr({
        vertexColors: !0,
        depthTest: !1,
        depthWrite: !1,
        toneMapped: !1,
        transparent: !0,
      })
    ),
      (this.type = "SkeletonHelper"),
      (this.isSkeletonHelper = !0),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(t) {
    const e = this.bones,
      n = this.geometry,
      i = n.getAttribute("position");
    il.getInverse(this.root.matrixWorld);
    for (let t = 0, n = 0; t < e.length; t++) {
      const r = e[t];
      r.parent &&
        r.parent.isBone &&
        (nl.multiplyMatrices(il, r.matrixWorld),
        el.setFromMatrixPosition(nl),
        i.setXYZ(n, el.x, el.y, el.z),
        nl.multiplyMatrices(il, r.parent.matrixWorld),
        el.setFromMatrixPosition(nl),
        i.setXYZ(n + 1, el.x, el.y, el.z),
        (n += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(t);
  }
}
function ol(t) {
  const e = [];
  t && t.isBone && e.push(t);
  for (let n = 0; n < t.children.length; n++)
    e.push.apply(e, ol(t.children[n]));
  return e;
}
const sl = new g(),
  al = new zt(),
  cl = new zt();
class ll extends Jr {
  constructor(t, e, n, i) {
    (t = t || 10),
      (e = e || 10),
      (n = new zt(void 0 !== n ? n : 4473924)),
      (i = new zt(void 0 !== i ? i : 8947848));
    const r = e / 2,
      o = t / e,
      s = t / 2,
      a = [],
      c = [];
    for (let t = 0, l = 0, h = -s; t <= e; t++, h += o) {
      a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s);
      const e = t === r ? n : i;
      e.toArray(c, l),
        (l += 3),
        e.toArray(c, l),
        (l += 3),
        e.toArray(c, l),
        (l += 3),
        e.toArray(c, l),
        (l += 3);
    }
    const l = new le();
    l.setAttribute("position", new Qt(a, 3)),
      l.setAttribute("color", new Qt(c, 3));
    super(l, new Hr({ vertexColors: !0, toneMapped: !1 })),
      (this.type = "GridHelper");
  }
}
const hl = new g(),
  ul = new g(),
  dl = new g();
const pl = new g(),
  fl = new He();
function ml(t, e, n, i, r, o, s) {
  pl.set(r, o, s).unproject(i);
  const a = e[t];
  if (void 0 !== a) {
    const t = n.getAttribute("position");
    for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], pl.x, pl.y, pl.z);
  }
}
const gl = new x();
class vl extends Jr {
  constructor(t, e = 16776960) {
    const n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(24),
      r = new le();
    r.setIndex(new jt(n, 1)),
      r.setAttribute("position", new jt(i, 3)),
      super(r, new Hr({ color: e, toneMapped: !1 })),
      (this.object = t),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(t) {
    if (
      (void 0 !== t &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      void 0 !== this.object && gl.setFromObject(this.object),
      gl.isEmpty())
    )
      return;
    const e = gl.min,
      n = gl.max,
      i = this.geometry.attributes.position,
      r = i.array;
    (r[0] = n.x),
      (r[1] = n.y),
      (r[2] = n.z),
      (r[3] = e.x),
      (r[4] = n.y),
      (r[5] = n.z),
      (r[6] = e.x),
      (r[7] = e.y),
      (r[8] = n.z),
      (r[9] = n.x),
      (r[10] = e.y),
      (r[11] = n.z),
      (r[12] = n.x),
      (r[13] = n.y),
      (r[14] = e.z),
      (r[15] = e.x),
      (r[16] = n.y),
      (r[17] = e.z),
      (r[18] = e.x),
      (r[19] = e.y),
      (r[20] = e.z),
      (r[21] = n.x),
      (r[22] = e.y),
      (r[23] = e.z),
      (i.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(t) {
    return (this.object = t), this.update(), this;
  }
  copy(t) {
    return Jr.prototype.copy.call(this, t), (this.object = t.object), this;
  }
}
const yl = new g();
let xl, bl;
class _l extends Jr {
  constructor(t = 1) {
    const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      n = new le();
    n.setAttribute("position", new Qt(e, 3)),
      n.setAttribute(
        "color",
        new Qt([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
      );
    super(n, new Hr({ vertexColors: !0, toneMapped: !1 })),
      (this.type = "AxesHelper");
  }
}
const wl = Math.pow(2, 8),
  Ml = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Sl = 5 + Ml.length,
  Tl = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
  El = new Ga(),
  {
    _lodPlanes: Al,
    _sizeLods: Ll,
    _sigmas: Rl,
  } = (function () {
    const t = [],
      e = [],
      n = [];
    let i = 8;
    for (let r = 0; r < Sl; r++) {
      const o = Math.pow(2, i);
      e.push(o);
      let s = 1 / o;
      r > 4 ? (s = Ml[r - 8 + 4 - 1]) : 0 == r && (s = 0), n.push(s);
      const a = 1 / (o - 1),
        c = -a / 2,
        l = 1 + a / 2,
        h = [c, c, l, c, l, l, c, c, l, l, c, l],
        u = 6,
        d = 6,
        p = 3,
        f = 2,
        m = 1,
        g = new Float32Array(p * d * u),
        v = new Float32Array(f * d * u),
        y = new Float32Array(m * d * u);
      for (let t = 0; t < u; t++) {
        const e = ((t % 3) * 2) / 3 - 1,
          n = t > 2 ? 0 : -1,
          i = [
            e,
            n,
            0,
            e + 2 / 3,
            n,
            0,
            e + 2 / 3,
            n + 1,
            0,
            e,
            n,
            0,
            e + 2 / 3,
            n + 1,
            0,
            e,
            n + 1,
            0,
          ];
        g.set(i, p * d * t), v.set(h, f * d * t);
        const r = [t, t, t, t, t, t];
        y.set(r, m * d * t);
      }
      const x = new le();
      x.setAttribute("position", new jt(g, p)),
        x.setAttribute("uv", new jt(v, f)),
        x.setAttribute("faceIndex", new jt(y, m)),
        t.push(x),
        i > 4 && i--;
    }
    return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
  })();
let Pl = null;
const Cl = (1 + Math.sqrt(5)) / 2,
  Ol = 1 / Cl,
  Nl = [
    new g(1, 1, 1),
    new g(-1, 1, 1),
    new g(1, 1, -1),
    new g(-1, 1, -1),
    new g(0, Cl, Ol),
    new g(0, Cl, -Ol),
    new g(Ol, 0, Cl),
    new g(-Ol, 0, Cl),
    new g(Cl, Ol, 0),
    new g(-Cl, Ol, 0),
  ];
function Il(t) {
  return (
    void 0 !== t &&
    1009 === t.type &&
    (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding)
  );
}
function Dl(t) {
  const e = new p(3 * wl, 3 * wl, t);
  return (
    (e.texture.mapping = 306),
    (e.texture.name = "PMREM.cubeUv"),
    (e.scissorTest = !0),
    e
  );
}
function Bl(t, e, n, i, r) {
  t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
}
function zl() {
  return new As({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
      texelSize: { value: new s(1, 1) },
      inputEncoding: { value: Tl[3e3] },
      outputEncoding: { value: Tl[3e3] },
    },
    vertexShader: Ul(),
    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Gl()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Fl() {
  return new As({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: Tl[3e3] },
      outputEncoding: { value: Tl[3e3] },
    },
    vertexShader: Ul(),
    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Gl()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Ul() {
  return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
}
function Gl() {
  return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
}
function Hl(t) {
  console.warn(
    "THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
  ),
    ya.call(this, t),
    (this.type = "catmullrom"),
    (this.closed = !0);
}
function kl(t) {
  console.warn(
    "THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."
  ),
    ya.call(this, t),
    (this.type = "catmullrom");
}
function Vl(t) {
  console.warn(
    "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."
  ),
    ya.call(this, t),
    (this.type = "catmullrom");
}
(ha.create = function (t, e) {
  return (
    console.log("THREE.Curve.create() has been deprecated"),
    (t.prototype = Object.create(ha.prototype)),
    (t.prototype.constructor = t),
    (t.prototype.getPoint = e),
    t
  );
}),
  Object.assign(Pa.prototype, {
    createPointsGeometry: function (t) {
      console.warn(
        "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      const e = this.getPoints(t);
      return this.createGeometry(e);
    },
    createSpacedPointsGeometry: function (t) {
      console.warn(
        "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      const e = this.getSpacedPoints(t);
      return this.createGeometry(e);
    },
    createGeometry: function (t) {
      console.warn(
        "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
      );
      const e = new Ie();
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n];
        e.vertices.push(new g(i.x, i.y, i.z || 0));
      }
      return e;
    },
  }),
  Object.assign(Ca.prototype, {
    fromPoints: function (t) {
      return (
        console.warn(
          "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
        ),
        this.setFromPoints(t)
      );
    },
  }),
  (Hl.prototype = Object.create(ya.prototype)),
  (kl.prototype = Object.create(ya.prototype)),
  (Vl.prototype = Object.create(ya.prototype)),
  Object.assign(Vl.prototype, {
    initFromArray: function () {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function () {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function () {
      console.error(
        "THREE.Spline: .reparametrizeByArcLength() has been removed."
      );
    },
  }),
  (ll.prototype.setColors = function () {
    console.error(
      "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
    );
  }),
  (rl.prototype.update = function () {
    console.error(
      "THREE.SkeletonHelper: update() no longer needs to be called."
    );
  }),
  Object.assign(ea.prototype, {
    extractUrlBase: function (t) {
      return (
        console.warn(
          "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
        ),
        Ya.extractUrlBase(t)
      );
    },
  }),
  (ea.Handlers = {
    add: function () {
      console.error(
        "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
      );
    },
    get: function () {
      console.error(
        "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
      );
    },
  }),
  Object.assign($a.prototype, {
    setTexturePath: function (t) {
      return (
        console.warn(
          "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
        ),
        this.setResourcePath(t)
      );
    },
  }),
  Object.assign(Zc.prototype, {
    center: function (t) {
      return (
        console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
      );
    },
    empty: function () {
      return (
        console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
      );
    },
    isIntersectionBox: function (t) {
      return (
        console.warn(
          "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
        ),
        this.intersectsBox(t)
      );
    },
    size: function (t) {
      return (
        console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
        this.getSize(t)
      );
    },
  }),
  Object.assign(x.prototype, {
    center: function (t) {
      return (
        console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
      );
    },
    empty: function () {
      return (
        console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
      );
    },
    isIntersectionBox: function (t) {
      return (
        console.warn(
          "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
        ),
        this.intersectsBox(t)
      );
    },
    isIntersectionSphere: function (t) {
      return (
        console.warn(
          "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
        ),
        this.intersectsSphere(t)
      );
    },
    size: function (t) {
      return (
        console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
        this.getSize(t)
      );
    },
  }),
  Object.assign(D.prototype, {
    empty: function () {
      return (
        console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
      );
    },
  }),
  (Ye.prototype.setFromMatrix = function (t) {
    return (
      console.warn(
        "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
      ),
      this.setFromProjectionMatrix(t)
    );
  }),
  (Qc.prototype.center = function (t) {
    return (
      console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
      this.getCenter(t)
    );
  }),
  Object.assign(o, {
    random16: function () {
      return (
        console.warn(
          "THREE.Math: .random16() has been deprecated. Use Math.random() instead."
        ),
        Math.random()
      );
    },
    nearestPowerOfTwo: function (t) {
      return (
        console.warn(
          "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."
        ),
        o.floorPowerOfTwo(t)
      );
    },
    nextPowerOfTwo: function (t) {
      return (
        console.warn(
          "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."
        ),
        o.ceilPowerOfTwo(t)
      );
    },
  }),
  Object.assign(a.prototype, {
    flattenToArrayOffset: function (t, e) {
      return (
        console.warn(
          "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
        ),
        this.toArray(t, e)
      );
    },
    multiplyVector3: function (t) {
      return (
        console.warn(
          "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
        ),
        t.applyMatrix3(this)
      );
    },
    multiplyVector3Array: function () {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBufferAttribute: function (t) {
      return (
        console.warn(
          "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
        ),
        t.applyMatrix3(this)
      );
    },
    applyToVector3Array: function () {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    },
  }),
  Object.assign(j.prototype, {
    extractPosition: function (t) {
      return (
        console.warn(
          "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
        ),
        this.copyPosition(t)
      );
    },
    flattenToArrayOffset: function (t, e) {
      return (
        console.warn(
          "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
        ),
        this.toArray(t, e)
      );
    },
    getPosition: function () {
      return (
        console.warn(
          "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
        ),
        new g().setFromMatrixColumn(this, 3)
      );
    },
    setRotationFromQuaternion: function (t) {
      return (
        console.warn(
          "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
        ),
        this.makeRotationFromQuaternion(t)
      );
    },
    multiplyToArray: function () {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function (t) {
      return (
        console.warn(
          "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
        ),
        t.applyMatrix4(this)
      );
    },
    multiplyVector4: function (t) {
      return (
        console.warn(
          "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
        ),
        t.applyMatrix4(this)
      );
    },
    multiplyVector3Array: function () {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function (t) {
      console.warn(
        "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
      ),
        t.transformDirection(this);
    },
    crossVector: function (t) {
      return (
        console.warn(
          "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
        ),
        t.applyMatrix4(this)
      );
    },
    translate: function () {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function () {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function () {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function () {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function () {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBufferAttribute: function (t) {
      return (
        console.warn(
          "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
        ),
        t.applyMatrix4(this)
      );
    },
    applyToVector3Array: function () {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function (t, e, n, i, r, o) {
      return (
        console.warn(
          "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
        ),
        this.makePerspective(t, e, i, n, r, o)
      );
    },
  }),
  (xt.prototype.isIntersectionLine = function (t) {
    return (
      console.warn(
        "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
      ),
      this.intersectsLine(t)
    );
  }),
  (m.prototype.multiplyVector3 = function (t) {
    return (
      console.warn(
        "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
      ),
      t.applyQuaternion(this)
    );
  }),
  Object.assign(V.prototype, {
    isIntersectionBox: function (t) {
      return (
        console.warn(
          "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
        ),
        this.intersectsBox(t)
      );
    },
    isIntersectionPlane: function (t) {
      return (
        console.warn(
          "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
        ),
        this.intersectsPlane(t)
      );
    },
    isIntersectionSphere: function (t) {
      return (
        console.warn(
          "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
        ),
        this.intersectsSphere(t)
      );
    },
  }),
  Object.assign(Pt.prototype, {
    area: function () {
      return (
        console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
        this.getArea()
      );
    },
    barycoordFromPoint: function (t, e) {
      return (
        console.warn(
          "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
        ),
        this.getBarycoord(t, e)
      );
    },
    midpoint: function (t) {
      return (
        console.warn(
          "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
        ),
        this.getMidpoint(t)
      );
    },
    normal: function (t) {
      return (
        console.warn(
          "THREE.Triangle: .normal() has been renamed to .getNormal()."
        ),
        this.getNormal(t)
      );
    },
    plane: function (t) {
      return (
        console.warn(
          "THREE.Triangle: .plane() has been renamed to .getPlane()."
        ),
        this.getPlane(t)
      );
    },
  }),
  Object.assign(Pt, {
    barycoordFromPoint: function (t, e, n, i, r) {
      return (
        console.warn(
          "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
        ),
        Pt.getBarycoord(t, e, n, i, r)
      );
    },
    normal: function (t, e, n, i) {
      return (
        console.warn(
          "THREE.Triangle: .normal() has been renamed to .getNormal()."
        ),
        Pt.getNormal(t, e, n, i)
      );
    },
  }),
  Object.assign(Oa.prototype, {
    extractAllPoints: function (t) {
      return (
        console.warn(
          "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
        ),
        this.extractPoints(t)
      );
    },
    extrude: function (t) {
      return (
        console.warn(
          "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
        ),
        new is(this, t)
      );
    },
    makeGeometry: function (t) {
      return (
        console.warn(
          "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
        ),
        new ms(this, t)
      );
    },
  }),
  Object.assign(s.prototype, {
    fromAttribute: function (t, e, n) {
      return (
        console.warn(
          "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
        ),
        this.fromBufferAttribute(t, e, n)
      );
    },
    distanceToManhattan: function (t) {
      return (
        console.warn(
          "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
        ),
        this.manhattanDistanceTo(t)
      );
    },
    lengthManhattan: function () {
      return (
        console.warn(
          "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
        ),
        this.manhattanLength()
      );
    },
  }),
  Object.assign(g.prototype, {
    setEulerFromRotationMatrix: function () {
      console.error(
        "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
      );
    },
    setEulerFromQuaternion: function () {
      console.error(
        "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
      );
    },
    getPositionFromMatrix: function (t) {
      return (
        console.warn(
          "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
        ),
        this.setFromMatrixPosition(t)
      );
    },
    getScaleFromMatrix: function (t) {
      return (
        console.warn(
          "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
        ),
        this.setFromMatrixScale(t)
      );
    },
    getColumnFromMatrix: function (t, e) {
      return (
        console.warn(
          "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
        ),
        this.setFromMatrixColumn(e, t)
      );
    },
    applyProjection: function (t) {
      return (
        console.warn(
          "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
        ),
        this.applyMatrix4(t)
      );
    },
    fromAttribute: function (t, e, n) {
      return (
        console.warn(
          "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
        ),
        this.fromBufferAttribute(t, e, n)
      );
    },
    distanceToManhattan: function (t) {
      return (
        console.warn(
          "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
        ),
        this.manhattanDistanceTo(t)
      );
    },
    lengthManhattan: function () {
      return (
        console.warn(
          "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
        ),
        this.manhattanLength()
      );
    },
  }),
  Object.assign(d.prototype, {
    fromAttribute: function (t, e, n) {
      return (
        console.warn(
          "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
        ),
        this.fromBufferAttribute(t, e, n)
      );
    },
    lengthManhattan: function () {
      return (
        console.warn(
          "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
        ),
        this.manhattanLength()
      );
    },
  }),
  Object.assign(Ie.prototype, {
    computeTangents: function () {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function () {
      console.error(
        "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
      );
    },
    applyMatrix: function (t) {
      return (
        console.warn(
          "THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(t)
      );
    },
  }),
  Object.assign(mt.prototype, {
    getChildByName: function (t) {
      return (
        console.warn(
          "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
        ),
        this.getObjectByName(t)
      );
    },
    renderDepth: function () {
      console.warn(
        "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
      );
    },
    translate: function (t, e) {
      return (
        console.warn(
          "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
        ),
        this.translateOnAxis(e, t)
      );
    },
    getWorldRotation: function () {
      console.error(
        "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
      );
    },
    applyMatrix: function (t) {
      return (
        console.warn(
          "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(t)
      );
    },
  }),
  Object.defineProperties(mt.prototype, {
    eulerOrder: {
      get: function () {
        return (
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
          this.rotation.order
        );
      },
      set: function (t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
          (this.rotation.order = t);
      },
    },
    useQuaternion: {
      get: function () {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
      set: function () {
        console.warn(
          "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
        );
      },
    },
  }),
  Object.assign(Ae.prototype, {
    setDrawMode: function () {
      console.error(
        "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
      );
    },
  }),
  Object.defineProperties(Ae.prototype, {
    drawMode: {
      get: function () {
        return (
          console.error(
            "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
          ),
          0
        );
      },
      set: function () {
        console.error(
          "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
        );
      },
    },
  }),
  Object.defineProperties(Pr.prototype, {
    objects: {
      get: function () {
        return (
          console.warn("THREE.LOD: .objects has been renamed to .levels."),
          this.levels
        );
      },
    },
  }),
  Object.defineProperty(Ir.prototype, "useVertexTexture", {
    get: function () {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function () {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
  }),
  (Cr.prototype.initBones = function () {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  }),
  Object.defineProperty(ha.prototype, "__arcLengthDivisions", {
    get: function () {
      return (
        console.warn(
          "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
        ),
        this.arcLengthDivisions
      );
    },
    set: function (t) {
      console.warn(
        "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."
      ),
        (this.arcLengthDivisions = t);
    },
  }),
  (ke.prototype.setLens = function (t, e) {
    console.warn(
      "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
    ),
      void 0 !== e && (this.filmGauge = e),
      this.setFocalLength(t);
  }),
  Object.defineProperties(Na.prototype, {
    onlyShadow: {
      set: function () {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      },
    },
    shadowCameraFov: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
        ),
          (this.shadow.camera.fov = t);
      },
    },
    shadowCameraLeft: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
        ),
          (this.shadow.camera.left = t);
      },
    },
    shadowCameraRight: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
        ),
          (this.shadow.camera.right = t);
      },
    },
    shadowCameraTop: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
        ),
          (this.shadow.camera.top = t);
      },
    },
    shadowCameraBottom: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
        ),
          (this.shadow.camera.bottom = t);
      },
    },
    shadowCameraNear: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
        ),
          (this.shadow.camera.near = t);
      },
    },
    shadowCameraFar: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
        ),
          (this.shadow.camera.far = t);
      },
    },
    shadowCameraVisible: {
      set: function () {
        console.warn(
          "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
        );
      },
    },
    shadowBias: {
      set: function (t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
          (this.shadow.bias = t);
      },
    },
    shadowDarkness: {
      set: function () {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      },
    },
    shadowMapWidth: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
        ),
          (this.shadow.mapSize.width = t);
      },
    },
    shadowMapHeight: {
      set: function (t) {
        console.warn(
          "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
        ),
          (this.shadow.mapSize.height = t);
      },
    },
  }),
  Object.defineProperties(jt.prototype, {
    length: {
      get: function () {
        return (
          console.warn(
            "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
          ),
          this.array.length
        );
      },
    },
    dynamic: {
      get: function () {
        return (
          console.warn(
            "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
          ),
          35048 === this.usage
        );
      },
      set: function () {
        console.warn(
          "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
        ),
          this.setUsage(35048);
      },
    },
  }),
  Object.assign(jt.prototype, {
    setDynamic: function (t) {
      return (
        console.warn(
          "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
        ),
        this.setUsage(!0 === t ? 35048 : 35044),
        this
      );
    },
    copyIndicesArray: function () {
      console.error(
        "THREE.BufferAttribute: .copyIndicesArray() has been removed."
      );
    },
    setArray: function () {
      console.error(
        "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
      );
    },
  }),
  Object.assign(le.prototype, {
    addIndex: function (t) {
      console.warn(
        "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
      ),
        this.setIndex(t);
    },
    addAttribute: function (t, e) {
      return (
        console.warn(
          "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
        ),
        (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
          ? "index" === t
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
              ),
              this.setIndex(e),
              this)
            : this.setAttribute(t, e)
          : (console.warn(
              "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
            ),
            this.setAttribute(t, new jt(arguments[1], arguments[2])))
      );
    },
    addDrawCall: function (t, e, n) {
      void 0 !== n &&
        console.warn(
          "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
        ),
        console.warn(
          "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
        ),
        this.addGroup(t, e);
    },
    clearDrawCalls: function () {
      console.warn(
        "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
      ),
        this.clearGroups();
    },
    computeTangents: function () {
      console.warn(
        "THREE.BufferGeometry: .computeTangents() has been removed."
      );
    },
    computeOffsets: function () {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    },
    removeAttribute: function (t) {
      return (
        console.warn(
          "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
        ),
        this.deleteAttribute(t)
      );
    },
    applyMatrix: function (t) {
      return (
        console.warn(
          "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
        ),
        this.applyMatrix4(t)
      );
    },
  }),
  Object.defineProperties(le.prototype, {
    drawcalls: {
      get: function () {
        return (
          console.error(
            "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
          ),
          this.groups
        );
      },
    },
    offsets: {
      get: function () {
        return (
          console.warn(
            "THREE.BufferGeometry: .offsets has been renamed to .groups."
          ),
          this.groups
        );
      },
    },
  }),
  Object.defineProperties(Za.prototype, {
    maxInstancedCount: {
      get: function () {
        return (
          console.warn(
            "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
          ),
          this.instanceCount
        );
      },
      set: function (t) {
        console.warn(
          "THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."
        ),
          (this.instanceCount = t);
      },
    },
  }),
  Object.defineProperties(jc.prototype, {
    linePrecision: {
      get: function () {
        return (
          console.warn(
            "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
          ),
          this.params.Line.threshold
        );
      },
      set: function (t) {
        console.warn(
          "THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."
        ),
          (this.params.Line.threshold = t);
      },
    },
  }),
  Object.defineProperties(lr.prototype, {
    dynamic: {
      get: function () {
        return (
          console.warn(
            "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
          ),
          35048 === this.usage
        );
      },
      set: function (t) {
        console.warn(
          "THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."
        ),
          this.setUsage(t);
      },
    },
  }),
  Object.assign(lr.prototype, {
    setDynamic: function (t) {
      return (
        console.warn(
          "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
        ),
        this.setUsage(!0 === t ? 35048 : 35044),
        this
      );
    },
    setArray: function () {
      console.error(
        "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
      );
    },
  }),
  Object.assign(rs.prototype, {
    getArrays: function () {
      console.error(
        "THREE.ExtrudeBufferGeometry: .getArrays() has been removed."
      );
    },
    addShapeList: function () {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed."
      );
    },
    addShape: function () {
      console.error(
        "THREE.ExtrudeBufferGeometry: .addShape() has been removed."
      );
    },
  }),
  Object.assign(cr.prototype, {
    dispose: function () {
      console.error("THREE.Scene: .dispose() has been removed.");
    },
  }),
  Object.defineProperties(Hc.prototype, {
    dynamic: {
      set: function () {
        console.warn(
          "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead."
        );
      },
    },
    onUpdate: {
      value: function () {
        return (
          console.warn(
            "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
          ),
          this
        );
      },
    },
  }),
  Object.defineProperties(Gt.prototype, {
    wrapAround: {
      get: function () {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function () {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
    },
    overdraw: {
      get: function () {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function () {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
    },
    wrapRGB: {
      get: function () {
        return (
          console.warn("THREE.Material: .wrapRGB has been removed."), new zt()
        );
      },
    },
    shading: {
      get: function () {
        console.error(
          "THREE." +
            this.type +
            ": .shading has been removed. Use the boolean .flatShading instead."
        );
      },
      set: function (t) {
        console.warn(
          "THREE." +
            this.type +
            ": .shading has been removed. Use the boolean .flatShading instead."
        ),
          (this.flatShading = 1 === t);
      },
    },
    stencilMask: {
      get: function () {
        return (
          console.warn(
            "THREE." +
              this.type +
              ": .stencilMask has been removed. Use .stencilFuncMask instead."
          ),
          this.stencilFuncMask
        );
      },
      set: function (t) {
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        ),
          (this.stencilFuncMask = t);
      },
    },
  }),
  Object.defineProperties(Ps.prototype, {
    metal: {
      get: function () {
        return (
          console.warn(
            "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."
          ),
          !1
        );
      },
      set: function () {
        console.warn(
          "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead"
        );
      },
    },
  }),
  Object.defineProperties(Rs.prototype, {
    transparency: {
      get: function () {
        return (
          console.warn(
            "THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
          ),
          this.transmission
        );
      },
      set: function (t) {
        console.warn(
          "THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."
        ),
          (this.transmission = t);
      },
    },
  }),
  Object.defineProperties(Ge.prototype, {
    derivatives: {
      get: function () {
        return (
          console.warn(
            "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
          ),
          this.extensions.derivatives
        );
      },
      set: function (t) {
        console.warn(
          "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ),
          (this.extensions.derivatives = t);
      },
    },
  }),
  Object.assign(rr.prototype, {
    clearTarget: function (t, e, n, i) {
      console.warn(
        "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
      ),
        this.setRenderTarget(t),
        this.clear(e, n, i);
    },
    animate: function (t) {
      console.warn(
        "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
      ),
        this.setAnimationLoop(t);
    },
    getCurrentRenderTarget: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
        ),
        this.getRenderTarget()
      );
    },
    getMaxAnisotropy: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
        ),
        this.capabilities.getMaxAnisotropy()
      );
    },
    getPrecision: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
        ),
        this.capabilities.precision
      );
    },
    resetGLState: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
        ),
        this.state.reset()
      );
    },
    supportsFloatTextures: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
        ),
        this.extensions.get("OES_texture_float")
      );
    },
    supportsHalfFloatTextures: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
        ),
        this.extensions.get("OES_texture_half_float")
      );
    },
    supportsStandardDerivatives: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
        ),
        this.extensions.get("OES_standard_derivatives")
      );
    },
    supportsCompressedTextureS3TC: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
        ),
        this.extensions.get("WEBGL_compressed_texture_s3tc")
      );
    },
    supportsCompressedTexturePVRTC: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
        ),
        this.extensions.get("WEBGL_compressed_texture_pvrtc")
      );
    },
    supportsBlendMinMax: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
        ),
        this.extensions.get("EXT_blend_minmax")
      );
    },
    supportsVertexTextures: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
        ),
        this.capabilities.vertexTextures
      );
    },
    supportsInstancedArrays: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
        ),
        this.extensions.get("ANGLE_instanced_arrays")
      );
    },
    enableScissorTest: function (t) {
      console.warn(
        "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
      ),
        this.setScissorTest(t);
    },
    initMaterial: function () {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function () {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function () {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function () {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function () {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    },
    allocTextureUnit: function () {
      console.warn(
        "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
      );
    },
    setTexture: function () {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    },
    setTexture2D: function () {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    },
    setTextureCube: function () {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    },
    getActiveMipMapLevel: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
        ),
        this.getActiveMipmapLevel()
      );
    },
  }),
  Object.defineProperties(rr.prototype, {
    shadowMapEnabled: {
      get: function () {
        return this.shadowMap.enabled;
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
        ),
          (this.shadowMap.enabled = t);
      },
    },
    shadowMapType: {
      get: function () {
        return this.shadowMap.type;
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
        ),
          (this.shadowMap.type = t);
      },
    },
    shadowMapCullFace: {
      get: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
        );
      },
    },
    context: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
          ),
          this.getContext()
        );
      },
    },
    vr: {
      get: function () {
        return (
          console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
          this.xr
        );
      },
    },
    gammaInput: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
          ),
          !1
        );
      },
      set: function () {
        console.warn(
          "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
        );
      },
    },
    gammaOutput: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
          ),
          !1
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
        ),
          (this.outputEncoding = !0 === t ? 3001 : 3e3);
      },
    },
    toneMappingWhitePoint: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
          ),
          1
        );
      },
      set: function () {
        console.warn(
          "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
        );
      },
    },
  }),
  Object.defineProperties(Zi.prototype, {
    cullFace: {
      get: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
      set: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
        );
      },
    },
    renderReverseSided: {
      get: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
        );
      },
    },
    renderSingleSided: {
      get: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
      set: function () {
        console.warn(
          "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
        );
      },
    },
  }),
  Object.defineProperties(p.prototype, {
    wrapS: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
          ),
          this.texture.wrapS
        );
      },
      set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
          (this.texture.wrapS = t);
      },
    },
    wrapT: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
          ),
          this.texture.wrapT
        );
      },
      set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
          (this.texture.wrapT = t);
      },
    },
    magFilter: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
          ),
          this.texture.magFilter
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ),
          (this.texture.magFilter = t);
      },
    },
    minFilter: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
          ),
          this.texture.minFilter
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ),
          (this.texture.minFilter = t);
      },
    },
    anisotropy: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
          ),
          this.texture.anisotropy
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ),
          (this.texture.anisotropy = t);
      },
    },
    offset: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .offset is now .texture.offset."
          ),
          this.texture.offset
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ),
          (this.texture.offset = t);
      },
    },
    repeat: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
          ),
          this.texture.repeat
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ),
          (this.texture.repeat = t);
      },
    },
    format: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .format is now .texture.format."
          ),
          this.texture.format
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ),
          (this.texture.format = t);
      },
    },
    type: {
      get: function () {
        return (
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
          this.texture.type
        );
      },
      set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
          (this.texture.type = t);
      },
    },
    generateMipmaps: {
      get: function () {
        return (
          console.warn(
            "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
          ),
          this.texture.generateMipmaps
        );
      },
      set: function (t) {
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ),
          (this.texture.generateMipmaps = t);
      },
    },
  }),
  Object.defineProperties(_c.prototype, {
    load: {
      value: function (t) {
        console.warn(
          "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
        );
        const e = this;
        return (
          new hc().load(t, function (t) {
            e.setBuffer(t);
          }),
          this
        );
      },
    },
    startTime: {
      set: function () {
        console.warn("THREE.Audio: .startTime is now .play( delay ).");
      },
    },
  }),
  (Ec.prototype.getData = function () {
    return (
      console.warn(
        "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
      ),
      this.getFrequencyData()
    );
  }),
  (Ve.prototype.updateCubeMap = function (t, e) {
    return (
      console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
      this.update(t, e)
    );
  });
const jl = {
  merge: function (t, e, n) {
    let i;
    console.warn(
      "THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
    ),
      e.isMesh &&
        (e.matrixAutoUpdate && e.updateMatrix(),
        (i = e.matrix),
        (e = e.geometry)),
      t.merge(e, i, n);
  },
  center: function (t) {
    return (
      console.warn(
        "THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."
      ),
      t.center()
    );
  },
};
(l.crossOrigin = void 0),
  (l.loadTexture = function (t, e, n, i) {
    console.warn(
      "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
    );
    const r = new la();
    r.setCrossOrigin(this.crossOrigin);
    const o = r.load(t, n, void 0, i);
    return e && (o.mapping = e), o;
  }),
  (l.loadTextureCube = function (t, e, n, i) {
    console.warn(
      "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
    );
    const r = new aa();
    r.setCrossOrigin(this.crossOrigin);
    const o = r.load(t, n, void 0, i);
    return e && (o.mapping = e), o;
  }),
  (l.loadCompressedTexture = function () {
    console.error(
      "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
    );
  }),
  (l.loadCompressedTextureCube = function () {
    console.error(
      "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
    );
  });
const Wl = {
  createMultiMaterialObject: function () {
    console.error(
      "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
    );
  },
  detach: function () {
    console.error(
      "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
    );
  },
  attach: function () {
    console.error(
      "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
    );
  },
};
"undefined" != typeof __THREE_DEVTOOLS__ &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: "120" } })
  );
var ql = Object.freeze({
    __proto__: null,
    ACESFilmicToneMapping: 4,
    AddEquation: 100,
    AddOperation: 2,
    AdditiveAnimationBlendMode: 2501,
    AdditiveBlending: 2,
    AlphaFormat: 1021,
    AlwaysDepth: 1,
    AlwaysStencilFunc: 519,
    AmbientLight: Va,
    AmbientLightProbe: dc,
    AnimationClip: Js,
    AnimationLoader: ra,
    AnimationMixer: Gc,
    AnimationObjectGroup: Fc,
    AnimationUtils: zs,
    ArcCurve: da,
    ArrayCamera: $i,
    ArrowHelper: class extends mt {
      constructor(t, e, n, i, r, o) {
        super(),
          (this.type = "ArrowHelper"),
          void 0 === t && (t = new g(0, 0, 1)),
          void 0 === e && (e = new g(0, 0, 0)),
          void 0 === n && (n = 1),
          void 0 === i && (i = 16776960),
          void 0 === r && (r = 0.2 * n),
          void 0 === o && (o = 0.2 * r),
          void 0 === xl &&
            ((xl = new le()),
            xl.setAttribute("position", new Qt([0, 0, 0, 0, 1, 0], 3)),
            (bl = new bs(0, 0.5, 1, 5, 1)),
            bl.translate(0, -0.5, 0)),
          this.position.copy(e),
          (this.line = new Xr(xl, new Hr({ color: i, toneMapped: !1 }))),
          (this.line.matrixAutoUpdate = !1),
          this.add(this.line),
          (this.cone = new Ae(bl, new Ht({ color: i, toneMapped: !1 }))),
          (this.cone.matrixAutoUpdate = !1),
          this.add(this.cone),
          this.setDirection(t),
          this.setLength(n, r, o);
      }
      setDirection(t) {
        if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
          yl.set(t.z, 0, -t.x).normalize();
          const e = Math.acos(t.y);
          this.quaternion.setFromAxisAngle(yl, e);
        }
      }
      setLength(t, e, n) {
        void 0 === e && (e = 0.2 * t),
          void 0 === n && (n = 0.2 * e),
          this.line.scale.set(1, Math.max(1e-4, t - e), 1),
          this.line.updateMatrix(),
          this.cone.scale.set(n, e, n),
          (this.cone.position.y = t),
          this.cone.updateMatrix();
      }
      setColor(t) {
        this.line.material.color.set(t), this.cone.material.color.set(t);
      }
      copy(t) {
        return (
          super.copy(t, !1),
          this.line.copy(t.line),
          this.cone.copy(t.cone),
          this
        );
      }
    },
    Audio: _c,
    AudioAnalyser: Ec,
    AudioContext: lc,
    AudioListener: class extends mt {
      constructor() {
        super(),
          (this.type = "AudioListener"),
          (this.context = lc.getContext()),
          (this.gain = this.context.createGain()),
          this.gain.connect(this.context.destination),
          (this.filter = null),
          (this.timeDelta = 0),
          (this._clock = new gc());
      }
      getInput() {
        return this.gain;
      }
      removeFilter() {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      }
      getFilter() {
        return this.filter;
      }
      setFilter(t) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = t),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      }
      getMasterVolume() {
        return this.gain.gain.value;
      }
      setMasterVolume(t) {
        return (
          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
          this
        );
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t);
        const e = this.context.listener,
          n = this.up;
        if (
          ((this.timeDelta = this._clock.getDelta()),
          this.matrixWorld.decompose(vc, yc, xc),
          bc.set(0, 0, -1).applyQuaternion(yc),
          e.positionX)
        ) {
          const t = this.context.currentTime + this.timeDelta;
          e.positionX.linearRampToValueAtTime(vc.x, t),
            e.positionY.linearRampToValueAtTime(vc.y, t),
            e.positionZ.linearRampToValueAtTime(vc.z, t),
            e.forwardX.linearRampToValueAtTime(bc.x, t),
            e.forwardY.linearRampToValueAtTime(bc.y, t),
            e.forwardZ.linearRampToValueAtTime(bc.z, t),
            e.upX.linearRampToValueAtTime(n.x, t),
            e.upY.linearRampToValueAtTime(n.y, t),
            e.upZ.linearRampToValueAtTime(n.z, t);
        } else
          e.setPosition(vc.x, vc.y, vc.z),
            e.setOrientation(bc.x, bc.y, bc.z, n.x, n.y, n.z);
      }
    },
    AudioLoader: hc,
    AxesHelper: _l,
    AxisHelper: function (t) {
      return (
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new _l(t)
      );
    },
    BackSide: 1,
    BasicDepthPacking: 3200,
    BasicShadowMap: 0,
    BinaryTextureLoader: function (t) {
      return (
        console.warn(
          "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
        ),
        new ca(t)
      );
    },
    Bone: Dr,
    BooleanKeyframeTrack: Vs,
    BoundingBoxHelper: function (t, e) {
      return (
        console.warn(
          "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
        ),
        new vl(t, e)
      );
    },
    Box2: Zc,
    Box3: x,
    Box3Helper: class extends Jr {
      constructor(t, e = 16776960) {
        const n = new Uint16Array([
            0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3,
            7,
          ]),
          i = new le();
        i.setIndex(new jt(n, 1)),
          i.setAttribute(
            "position",
            new Qt(
              [
                1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1,
                -1, -1, 1, -1, -1,
              ],
              3
            )
          ),
          super(i, new Hr({ color: e, toneMapped: !1 })),
          (this.box = t),
          (this.type = "Box3Helper"),
          this.geometry.computeBoundingSphere();
      }
      updateMatrixWorld(t) {
        const e = this.box;
        e.isEmpty() ||
          (e.getCenter(this.position),
          e.getSize(this.scale),
          this.scale.multiplyScalar(0.5),
          super.updateMatrixWorld(t));
      }
    },
    BoxBufferGeometry: Be,
    BoxGeometry: De,
    BoxHelper: vl,
    BufferAttribute: jt,
    BufferGeometry: le,
    BufferGeometryLoader: Ka,
    ByteType: 1010,
    Cache: Qs,
    Camera: He,
    CameraHelper: class extends Jr {
      constructor(t) {
        const e = new le(),
          n = new Hr({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
          i = [],
          r = [],
          o = {},
          s = new zt(16755200),
          a = new zt(16711680),
          c = new zt(43775),
          l = new zt(16777215),
          h = new zt(3355443);
        function u(t, e, n) {
          d(t, n), d(e, n);
        }
        function d(t, e) {
          i.push(0, 0, 0),
            r.push(e.r, e.g, e.b),
            void 0 === o[t] && (o[t] = []),
            o[t].push(i.length / 3 - 1);
        }
        u("n1", "n2", s),
          u("n2", "n4", s),
          u("n4", "n3", s),
          u("n3", "n1", s),
          u("f1", "f2", s),
          u("f2", "f4", s),
          u("f4", "f3", s),
          u("f3", "f1", s),
          u("n1", "f1", s),
          u("n2", "f2", s),
          u("n3", "f3", s),
          u("n4", "f4", s),
          u("p", "n1", a),
          u("p", "n2", a),
          u("p", "n3", a),
          u("p", "n4", a),
          u("u1", "u2", c),
          u("u2", "u3", c),
          u("u3", "u1", c),
          u("c", "t", l),
          u("p", "c", h),
          u("cn1", "cn2", h),
          u("cn3", "cn4", h),
          u("cf1", "cf2", h),
          u("cf3", "cf4", h),
          e.setAttribute("position", new Qt(i, 3)),
          e.setAttribute("color", new Qt(r, 3)),
          super(e, n),
          (this.type = "CameraHelper"),
          (this.camera = t),
          this.camera.updateProjectionMatrix &&
            this.camera.updateProjectionMatrix(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.pointMap = o),
          this.update();
      }
      update() {
        const t = this.geometry,
          e = this.pointMap;
        fl.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
          ml("c", e, t, fl, 0, 0, -1),
          ml("t", e, t, fl, 0, 0, 1),
          ml("n1", e, t, fl, -1, -1, -1),
          ml("n2", e, t, fl, 1, -1, -1),
          ml("n3", e, t, fl, -1, 1, -1),
          ml("n4", e, t, fl, 1, 1, -1),
          ml("f1", e, t, fl, -1, -1, 1),
          ml("f2", e, t, fl, 1, -1, 1),
          ml("f3", e, t, fl, -1, 1, 1),
          ml("f4", e, t, fl, 1, 1, 1),
          ml("u1", e, t, fl, 0.7, 1.1, -1),
          ml("u2", e, t, fl, -0.7, 1.1, -1),
          ml("u3", e, t, fl, 0, 2, -1),
          ml("cf1", e, t, fl, -1, 0, 1),
          ml("cf2", e, t, fl, 1, 0, 1),
          ml("cf3", e, t, fl, 0, -1, 1),
          ml("cf4", e, t, fl, 0, 1, 1),
          ml("cn1", e, t, fl, -1, 0, -1),
          ml("cn2", e, t, fl, 1, 0, -1),
          ml("cn3", e, t, fl, 0, -1, -1),
          ml("cn4", e, t, fl, 0, 1, -1),
          (t.getAttribute("position").needsUpdate = !0);
      }
    },
    CanvasRenderer: function () {
      console.error("THREE.CanvasRenderer has been removed");
    },
    CanvasTexture: ao,
    CatmullRomCurve3: ya,
    CineonToneMapping: 3,
    CircleBufferGeometry: Ss,
    CircleGeometry: Ms,
    ClampToEdgeWrapping: 1001,
    Clock: gc,
    ClosedSplineCurve3: Hl,
    Color: zt,
    ColorKeyframeTrack: js,
    CompressedTexture: so,
    CompressedTextureLoader: oa,
    ConeBufferGeometry: ws,
    ConeGeometry: _s,
    CubeCamera: Ve,
    CubeGeometry: De,
    CubeReflectionMapping: 301,
    CubeRefractionMapping: 302,
    CubeTexture: vn,
    CubeTextureLoader: aa,
    CubeUVReflectionMapping: 306,
    CubeUVRefractionMapping: 307,
    CubicBezierCurve: wa,
    CubicBezierCurve3: Ma,
    CubicInterpolant: Us,
    CullFaceBack: 1,
    CullFaceFront: 2,
    CullFaceFrontBack: 3,
    CullFaceNone: 0,
    Curve: ha,
    CurvePath: Pa,
    CustomBlending: 5,
    CustomToneMapping: 5,
    CylinderBufferGeometry: bs,
    CylinderGeometry: xs,
    Cylindrical: class {
      constructor(t, e, n) {
        return (
          (this.radius = void 0 !== t ? t : 1),
          (this.theta = void 0 !== e ? e : 0),
          (this.y = void 0 !== n ? n : 0),
          this
        );
      }
      set(t, e, n) {
        return (this.radius = t), (this.theta = e), (this.y = n), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return (
          (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this
        );
      }
      setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z);
      }
      setFromCartesianCoords(t, e, n) {
        return (
          (this.radius = Math.sqrt(t * t + n * n)),
          (this.theta = Math.atan2(t, n)),
          (this.y = e),
          this
        );
      }
    },
    DataTexture: We,
    DataTexture2DArray: yn,
    DataTexture3D: xn,
    DataTextureLoader: ca,
    DecrementStencilOp: 7683,
    DecrementWrapStencilOp: 34056,
    DefaultLoadingManager: ta,
    DepthFormat: 1026,
    DepthStencilFormat: 1027,
    DepthTexture: co,
    DirectionalLight: ka,
    DirectionalLightHelper: class extends mt {
      constructor(t, e, n) {
        super(),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n),
          void 0 === e && (e = 1);
        let i = new le();
        i.setAttribute(
          "position",
          new Qt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
        );
        const r = new Hr({ fog: !1, toneMapped: !1 });
        (this.lightPlane = new Xr(i, r)),
          this.add(this.lightPlane),
          (i = new le()),
          i.setAttribute("position", new Qt([0, 0, 0, 0, 0, 1], 3)),
          (this.targetLine = new Xr(i, r)),
          this.add(this.targetLine),
          this.update();
      }
      dispose() {
        this.lightPlane.geometry.dispose(),
          this.lightPlane.material.dispose(),
          this.targetLine.geometry.dispose(),
          this.targetLine.material.dispose();
      }
      update() {
        hl.setFromMatrixPosition(this.light.matrixWorld),
          ul.setFromMatrixPosition(this.light.target.matrixWorld),
          dl.subVectors(ul, hl),
          this.lightPlane.lookAt(ul),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(ul),
          (this.targetLine.scale.z = dl.length());
      }
    },
    DiscreteInterpolant: Hs,
    DodecahedronBufferGeometry: wo,
    DodecahedronGeometry: _o,
    DoubleSide: 2,
    DstAlphaFactor: 206,
    DstColorFactor: 208,
    DynamicBufferAttribute: function (t, e) {
      return (
        console.warn(
          "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
        ),
        new jt(t, e).setUsage(35048)
      );
    },
    DynamicCopyUsage: 35050,
    DynamicDrawUsage: 35048,
    DynamicReadUsage: 35049,
    EdgesGeometry: ys,
    EdgesHelper: function (t, e) {
      return (
        console.warn(
          "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
        ),
        new Jr(
          new ys(t.geometry),
          new Hr({ color: void 0 !== e ? e : 16777215 })
        )
      );
    },
    EllipseCurve: ua,
    EqualDepth: 4,
    EqualStencilFunc: 514,
    EquirectangularReflectionMapping: 303,
    EquirectangularRefractionMapping: 304,
    Euler: Q,
    EventDispatcher: n,
    ExtrudeBufferGeometry: rs,
    ExtrudeGeometry: is,
    Face3: Ft,
    Face4: function (t, e, n, i, r, o, s) {
      return (
        console.warn(
          "THREE.Face4 has been removed. A THREE.Face3 will be created instead."
        ),
        new Ft(t, e, n, r, o, s)
      );
    },
    FaceColors: 1,
    FileLoader: ia,
    FlatShading: 1,
    Float32Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
        ),
        new Qt(t, e)
      );
    },
    Float32BufferAttribute: Qt,
    Float64Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
        ),
        new $t(t, e)
      );
    },
    Float64BufferAttribute: $t,
    FloatType: 1015,
    Fog: ar,
    FogExp2: sr,
    Font: oc,
    FontLoader: ac,
    FrontSide: 0,
    Frustum: Ye,
    GLBufferAttribute: Vc,
    GLSL1: "100",
    GLSL3: "300 es",
    GammaEncoding: 3007,
    Geometry: Ie,
    GeometryUtils: jl,
    GreaterDepth: 6,
    GreaterEqualDepth: 5,
    GreaterEqualStencilFunc: 518,
    GreaterStencilFunc: 516,
    GridHelper: ll,
    Group: tr,
    HalfFloatType: 1016,
    HemisphereLight: Ia,
    HemisphereLightHelper: class extends mt {
      constructor(t, e, n) {
        super(),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = n);
        const i = new yo(e);
        i.rotateY(0.5 * Math.PI),
          (this.material = new Ht({ wireframe: !0, fog: !1, toneMapped: !1 })),
          void 0 === this.color && (this.material.vertexColors = !0);
        const r = i.getAttribute("position"),
          o = new Float32Array(3 * r.count);
        i.setAttribute("color", new jt(o, 3)),
          this.add(new Ae(i, this.material)),
          this.update();
      }
      dispose() {
        this.children[0].geometry.dispose(),
          this.children[0].material.dispose();
      }
      update() {
        const t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          const e = t.geometry.getAttribute("color");
          al.copy(this.light.color), cl.copy(this.light.groundColor);
          for (let t = 0, n = e.count; t < n; t++) {
            const i = t < n / 2 ? al : cl;
            e.setXYZ(t, i.r, i.g, i.b);
          }
          e.needsUpdate = !0;
        }
        t.lookAt(sl.setFromMatrixPosition(this.light.matrixWorld).negate());
      }
    },
    HemisphereLightProbe: uc,
    IcosahedronBufferGeometry: bo,
    IcosahedronGeometry: xo,
    ImageBitmapLoader: ic,
    ImageLoader: sa,
    ImageUtils: l,
    ImmediateRenderObject: $c,
    IncrementStencilOp: 7682,
    IncrementWrapStencilOp: 34055,
    InstancedBufferAttribute: Ja,
    InstancedBufferGeometry: Za,
    InstancedInterleavedBuffer: kc,
    InstancedMesh: Gr,
    Int16Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
        ),
        new Yt(t, e)
      );
    },
    Int16BufferAttribute: Yt,
    Int32Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
        ),
        new Jt(t, e)
      );
    },
    Int32BufferAttribute: Jt,
    Int8Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
        ),
        new Wt(t, e)
      );
    },
    Int8BufferAttribute: Wt,
    IntType: 1013,
    InterleavedBuffer: lr,
    InterleavedBufferAttribute: ur,
    Interpolant: Fs,
    InterpolateDiscrete: 2300,
    InterpolateLinear: 2301,
    InterpolateSmooth: 2302,
    InvertStencilOp: 5386,
    JSONLoader: function () {
      console.error("THREE.JSONLoader has been removed.");
    },
    KeepStencilOp: 7680,
    KeyframeTrack: ks,
    LOD: Pr,
    LatheBufferGeometry: fs,
    LatheGeometry: ps,
    Layers: et,
    LensFlare: function () {
      console.error(
        "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
      );
    },
    LessDepth: 2,
    LessEqualDepth: 3,
    LessEqualStencilFunc: 515,
    LessStencilFunc: 513,
    Light: Na,
    LightProbe: qa,
    LightShadow: Da,
    Line: Xr,
    Line3: Qc,
    LineBasicMaterial: Hr,
    LineCurve: Sa,
    LineCurve3: Ta,
    LineDashedMaterial: Ds,
    LineLoop: Kr,
    LinePieces: 1,
    LineSegments: Jr,
    LineStrip: 0,
    LinearEncoding: 3e3,
    LinearFilter: 1006,
    LinearInterpolant: Gs,
    LinearMipMapLinearFilter: 1008,
    LinearMipMapNearestFilter: 1007,
    LinearMipmapLinearFilter: 1008,
    LinearMipmapNearestFilter: 1007,
    LinearToneMapping: 1,
    Loader: ea,
    LoaderUtils: Ya,
    LoadingManager: $s,
    LogLuvEncoding: 3003,
    LoopOnce: 2200,
    LoopPingPong: 2202,
    LoopRepeat: 2201,
    LuminanceAlphaFormat: 1025,
    LuminanceFormat: 1024,
    MOUSE: t,
    Material: Gt,
    MaterialLoader: Xa,
    Math: o,
    MathUtils: o,
    Matrix3: a,
    Matrix4: j,
    MaxEquation: 104,
    Mesh: Ae,
    MeshBasicMaterial: Ht,
    MeshDepthMaterial: Xi,
    MeshDistanceMaterial: Yi,
    MeshFaceMaterial: function (t) {
      return (
        console.warn(
          "THREE.MeshFaceMaterial has been removed. Use an Array instead."
        ),
        t
      );
    },
    MeshLambertMaterial: Ns,
    MeshMatcapMaterial: Is,
    MeshNormalMaterial: Os,
    MeshPhongMaterial: Ps,
    MeshPhysicalMaterial: Rs,
    MeshStandardMaterial: Ls,
    MeshToonMaterial: Cs,
    MinEquation: 103,
    MirroredRepeatWrapping: 1002,
    MixOperation: 1,
    MultiMaterial: function (t) {
      return (
        void 0 === t && (t = []),
        console.warn(
          "THREE.MultiMaterial has been removed. Use an Array instead."
        ),
        (t.isMultiMaterial = !0),
        (t.materials = t),
        (t.clone = function () {
          return t.slice();
        }),
        t
      );
    },
    MultiplyBlending: 4,
    MultiplyOperation: 0,
    NearestFilter: 1003,
    NearestMipMapLinearFilter: 1005,
    NearestMipMapNearestFilter: 1004,
    NearestMipmapLinearFilter: 1005,
    NearestMipmapNearestFilter: 1004,
    NeverDepth: 0,
    NeverStencilFunc: 512,
    NoBlending: 0,
    NoColors: 0,
    NoToneMapping: 0,
    NormalAnimationBlendMode: 2500,
    NormalBlending: 1,
    NotEqualDepth: 7,
    NotEqualStencilFunc: 517,
    NumberKeyframeTrack: Ws,
    Object3D: mt,
    ObjectLoader: $a,
    ObjectSpaceNormalMap: 1,
    OctahedronBufferGeometry: yo,
    OctahedronGeometry: vo,
    OneFactor: 201,
    OneMinusDstAlphaFactor: 207,
    OneMinusDstColorFactor: 209,
    OneMinusSrcAlphaFactor: 205,
    OneMinusSrcColorFactor: 203,
    OrthographicCamera: Ga,
    PCFShadowMap: 1,
    PCFSoftShadowMap: 2,
    PMREMGenerator: class {
      constructor(t) {
        (this._renderer = t),
          (this._pingPongRenderTarget = null),
          (this._blurMaterial = (function (t) {
            const e = new Float32Array(t),
              n = new g(0, 1, 0);
            return new As({
              name: "SphericalGaussianBlur",
              defines: { n: t },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: e },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: n },
                inputEncoding: { value: Tl[3e3] },
                outputEncoding: { value: Tl[3e3] },
              },
              vertexShader: Ul(),
              fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Gl()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
              blending: 0,
              depthTest: !1,
              depthWrite: !1,
            });
          })(20)),
          (this._equirectShader = null),
          (this._cubemapShader = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(t, e = 0, n = 0.1, i = 100) {
        Pl = this._renderer.getRenderTarget();
        const r = this._allocateTargets();
        return (
          this._sceneToCubeUV(t, n, i, r),
          e > 0 && this._blur(r, 0, 0, e),
          this._applyPMREM(r),
          this._cleanup(r),
          r
        );
      }
      fromEquirectangular(t) {
        return this._fromTexture(t);
      }
      fromCubemap(t) {
        return this._fromTexture(t);
      }
      compileCubemapShader() {
        null === this._cubemapShader &&
          ((this._cubemapShader = Fl()),
          this._compileMaterial(this._cubemapShader));
      }
      compileEquirectangularShader() {
        null === this._equirectShader &&
          ((this._equirectShader = zl()),
          this._compileMaterial(this._equirectShader));
      }
      dispose() {
        this._blurMaterial.dispose(),
          null !== this._cubemapShader && this._cubemapShader.dispose(),
          null !== this._equirectShader && this._equirectShader.dispose();
        for (let t = 0; t < Al.length; t++) Al[t].dispose();
      }
      _cleanup(t) {
        this._pingPongRenderTarget.dispose(),
          this._renderer.setRenderTarget(Pl),
          (t.scissorTest = !1),
          Bl(t, 0, 0, t.width, t.height);
      }
      _fromTexture(t) {
        Pl = this._renderer.getRenderTarget();
        const e = this._allocateTargets(t);
        return (
          this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
        );
      }
      _allocateTargets(t) {
        const e = {
            magFilter: 1003,
            minFilter: 1003,
            generateMipmaps: !1,
            type: 1009,
            format: 1023,
            encoding: Il(t) ? t.encoding : 3002,
            depthBuffer: !1,
          },
          n = Dl(e);
        return (n.depthBuffer = !t), (this._pingPongRenderTarget = Dl(e)), n;
      }
      _compileMaterial(t) {
        const e = new Ae(Al[0], t);
        this._renderer.compile(e, El);
      }
      _sceneToCubeUV(t, e, n, i) {
        const r = new ke(90, 1, e, n),
          o = [1, -1, 1, 1, 1, 1],
          s = [1, 1, 1, -1, -1, -1],
          a = this._renderer,
          c = a.outputEncoding,
          l = a.toneMapping,
          h = a.getClearColor(),
          u = a.getClearAlpha();
        (a.toneMapping = 0), (a.outputEncoding = 3e3);
        let d = t.background;
        if (d && d.isColor) {
          d.convertSRGBToLinear();
          const e = Math.max(d.r, d.g, d.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
          d = d.multiplyScalar(Math.pow(2, -n));
          const i = (n + 128) / 255;
          a.setClearColor(d, i), (t.background = null);
        }
        for (let e = 0; e < 6; e++) {
          const n = e % 3;
          0 == n
            ? (r.up.set(0, o[e], 0), r.lookAt(s[e], 0, 0))
            : 1 == n
            ? (r.up.set(0, 0, o[e]), r.lookAt(0, s[e], 0))
            : (r.up.set(0, o[e], 0), r.lookAt(0, 0, s[e])),
            Bl(i, n * wl, e > 2 ? wl : 0, wl, wl),
            a.setRenderTarget(i),
            a.render(t, r);
        }
        (a.toneMapping = l), (a.outputEncoding = c), a.setClearColor(h, u);
      }
      _textureToCubeUV(t, e) {
        const n = this._renderer;
        t.isCubeTexture
          ? null == this._cubemapShader && (this._cubemapShader = Fl())
          : null == this._equirectShader && (this._equirectShader = zl());
        const i = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
          r = new Ae(Al[0], i),
          o = i.uniforms;
        (o.envMap.value = t),
          t.isCubeTexture ||
            o.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
          (o.inputEncoding.value = Tl[t.encoding]),
          (o.outputEncoding.value = Tl[e.texture.encoding]),
          Bl(e, 0, 0, 3 * wl, 2 * wl),
          n.setRenderTarget(e),
          n.render(r, El);
      }
      _applyPMREM(t) {
        const e = this._renderer,
          n = e.autoClear;
        e.autoClear = !1;
        for (let e = 1; e < Sl; e++) {
          const n = Math.sqrt(Rl[e] * Rl[e] - Rl[e - 1] * Rl[e - 1]),
            i = Nl[(e - 1) % Nl.length];
          this._blur(t, e - 1, e, n, i);
        }
        e.autoClear = n;
      }
      _blur(t, e, n, i, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(t, o, e, n, i, "latitudinal", r),
          this._halfBlur(o, t, n, n, i, "longitudinal", r);
      }
      _halfBlur(t, e, n, i, r, o, s) {
        const a = this._renderer,
          c = this._blurMaterial;
        "latitudinal" !== o &&
          "longitudinal" !== o &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        const l = new Ae(Al[i], c),
          h = c.uniforms,
          u = Ll[n] - 1,
          d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
          p = r / d,
          f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
        f > 20 &&
          console.warn(
            `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
          );
        const m = [];
        let g = 0;
        for (let t = 0; t < 20; ++t) {
          const e = t / p,
            n = Math.exp((-e * e) / 2);
          m.push(n), 0 == t ? (g += n) : t < f && (g += 2 * n);
        }
        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
        (h.envMap.value = t.texture),
          (h.samples.value = f),
          (h.weights.value = m),
          (h.latitudinal.value = "latitudinal" === o),
          s && (h.poleAxis.value = s),
          (h.dTheta.value = d),
          (h.mipInt.value = 8 - n),
          (h.inputEncoding.value = Tl[t.texture.encoding]),
          (h.outputEncoding.value = Tl[t.texture.encoding]);
        const v = Ll[i];
        Bl(
          e,
          3 * Math.max(0, wl - 2 * v),
          (0 === i ? 0 : 2 * wl) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
          3 * v,
          2 * v
        ),
          a.setRenderTarget(e),
          a.render(l, El);
      }
    },
    ParametricBufferGeometry: uo,
    ParametricGeometry: ho,
    Particle: function (t) {
      return (
        console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new Er(t)
      );
    },
    ParticleBasicMaterial: function (t) {
      return (
        console.warn(
          "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Qr(t)
      );
    },
    ParticleSystem: function (t, e) {
      return (
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new io(t, e)
      );
    },
    ParticleSystemMaterial: function (t) {
      return (
        console.warn(
          "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Qr(t)
      );
    },
    Path: Ca,
    PerspectiveCamera: ke,
    Plane: xt,
    PlaneBufferGeometry: Qe,
    PlaneGeometry: Ke,
    PlaneHelper: class extends Xr {
      constructor(t, e, n) {
        const i = void 0 !== n ? n : 16776960,
          r = new le();
        r.setAttribute(
          "position",
          new Qt(
            [
              1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1,
              -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
            ],
            3
          )
        ),
          r.computeBoundingSphere(),
          super(r, new Hr({ color: i, toneMapped: !1 })),
          (this.type = "PlaneHelper"),
          (this.plane = t),
          (this.size = void 0 === e ? 1 : e);
        const o = new le();
        o.setAttribute(
          "position",
          new Qt(
            [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
            3
          )
        ),
          o.computeBoundingSphere(),
          this.add(
            new Ae(
              o,
              new Ht({
                color: i,
                opacity: 0.2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1,
              })
            )
          );
      }
      updateMatrixWorld(t) {
        let e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8),
          this.scale.set(0.5 * this.size, 0.5 * this.size, e),
          (this.children[0].material.side = e < 0 ? 1 : 0),
          this.lookAt(this.plane.normal),
          super.updateMatrixWorld(t);
      }
    },
    PointCloud: function (t, e) {
      return (
        console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new io(t, e)
      );
    },
    PointCloudMaterial: function (t) {
      return (
        console.warn(
          "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
        ),
        new Qr(t)
      );
    },
    PointLight: Ua,
    PointLightHelper: class extends Ae {
      constructor(t, e, n) {
        super(
          new hs(e, 4, 2),
          new Ht({ wireframe: !0, fog: !1, toneMapped: !1 })
        ),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.color = n),
          (this.type = "PointLightHelper"),
          (this.matrix = this.light.matrixWorld),
          (this.matrixAutoUpdate = !1),
          this.update();
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose();
      }
      update() {
        void 0 !== this.color
          ? this.material.color.set(this.color)
          : this.material.color.copy(this.light.color);
      }
    },
    Points: io,
    PointsMaterial: Qr,
    PolarGridHelper: class extends Jr {
      constructor(t, e, n, i, r, o) {
        (t = t || 10),
          (e = e || 16),
          (n = n || 8),
          (i = i || 64),
          (r = new zt(void 0 !== r ? r : 4473924)),
          (o = new zt(void 0 !== o ? o : 8947848));
        const s = [],
          a = [];
        for (let n = 0; n <= e; n++) {
          const i = (n / e) * (2 * Math.PI),
            c = Math.sin(i) * t,
            l = Math.cos(i) * t;
          s.push(0, 0, 0), s.push(c, 0, l);
          const h = 1 & n ? r : o;
          a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b);
        }
        for (let e = 0; e <= n; e++) {
          const c = 1 & e ? r : o,
            l = t - (t / n) * e;
          for (let t = 0; t < i; t++) {
            let e = (t / i) * (2 * Math.PI),
              n = Math.sin(e) * l,
              r = Math.cos(e) * l;
            s.push(n, 0, r),
              a.push(c.r, c.g, c.b),
              (e = ((t + 1) / i) * (2 * Math.PI)),
              (n = Math.sin(e) * l),
              (r = Math.cos(e) * l),
              s.push(n, 0, r),
              a.push(c.r, c.g, c.b);
          }
        }
        const c = new le();
        c.setAttribute("position", new Qt(s, 3)),
          c.setAttribute("color", new Qt(a, 3));
        super(c, new Hr({ vertexColors: !0, toneMapped: !1 })),
          (this.type = "PolarGridHelper");
      }
    },
    PolyhedronBufferGeometry: fo,
    PolyhedronGeometry: po,
    PositionalAudio: class extends _c {
      constructor(t) {
        super(t),
          (this.panner = this.context.createPanner()),
          (this.panner.panningModel = "HRTF"),
          this.panner.connect(this.gain);
      }
      getOutput() {
        return this.panner;
      }
      getRefDistance() {
        return this.panner.refDistance;
      }
      setRefDistance(t) {
        return (this.panner.refDistance = t), this;
      }
      getRolloffFactor() {
        return this.panner.rolloffFactor;
      }
      setRolloffFactor(t) {
        return (this.panner.rolloffFactor = t), this;
      }
      getDistanceModel() {
        return this.panner.distanceModel;
      }
      setDistanceModel(t) {
        return (this.panner.distanceModel = t), this;
      }
      getMaxDistance() {
        return this.panner.maxDistance;
      }
      setMaxDistance(t) {
        return (this.panner.maxDistance = t), this;
      }
      setDirectionalCone(t, e, n) {
        return (
          (this.panner.coneInnerAngle = t),
          (this.panner.coneOuterAngle = e),
          (this.panner.coneOuterGain = n),
          this
        );
      }
      updateMatrixWorld(t) {
        if (
          (super.updateMatrixWorld(t),
          !0 === this.hasPlaybackControl && !1 === this.isPlaying)
        )
          return;
        this.matrixWorld.decompose(wc, Mc, Sc),
          Tc.set(0, 0, 1).applyQuaternion(Mc);
        const e = this.panner;
        if (e.positionX) {
          const t = this.context.currentTime + this.listener.timeDelta;
          e.positionX.linearRampToValueAtTime(wc.x, t),
            e.positionY.linearRampToValueAtTime(wc.y, t),
            e.positionZ.linearRampToValueAtTime(wc.z, t),
            e.orientationX.linearRampToValueAtTime(Tc.x, t),
            e.orientationY.linearRampToValueAtTime(Tc.y, t),
            e.orientationZ.linearRampToValueAtTime(Tc.z, t);
        } else
          e.setPosition(wc.x, wc.y, wc.z), e.setOrientation(Tc.x, Tc.y, Tc.z);
      }
    },
    PropertyBinding: zc,
    PropertyMixer: Ac,
    QuadraticBezierCurve: Ea,
    QuadraticBezierCurve3: Aa,
    Quaternion: m,
    QuaternionKeyframeTrack: Xs,
    QuaternionLinearInterpolant: qs,
    REVISION: "120",
    RGBADepthPacking: 3201,
    RGBAFormat: 1023,
    RGBAIntegerFormat: 1033,
    RGBA_ASTC_10x10_Format: 37819,
    RGBA_ASTC_10x5_Format: 37816,
    RGBA_ASTC_10x6_Format: 37817,
    RGBA_ASTC_10x8_Format: 37818,
    RGBA_ASTC_12x10_Format: 37820,
    RGBA_ASTC_12x12_Format: 37821,
    RGBA_ASTC_4x4_Format: 37808,
    RGBA_ASTC_5x4_Format: 37809,
    RGBA_ASTC_5x5_Format: 37810,
    RGBA_ASTC_6x5_Format: 37811,
    RGBA_ASTC_6x6_Format: 37812,
    RGBA_ASTC_8x5_Format: 37813,
    RGBA_ASTC_8x6_Format: 37814,
    RGBA_ASTC_8x8_Format: 37815,
    RGBA_BPTC_Format: 36492,
    RGBA_ETC2_EAC_Format: 37496,
    RGBA_PVRTC_2BPPV1_Format: 35843,
    RGBA_PVRTC_4BPPV1_Format: 35842,
    RGBA_S3TC_DXT1_Format: 33777,
    RGBA_S3TC_DXT3_Format: 33778,
    RGBA_S3TC_DXT5_Format: 33779,
    RGBDEncoding: 3006,
    RGBEEncoding: 3002,
    RGBEFormat: 1023,
    RGBFormat: 1022,
    RGBIntegerFormat: 1032,
    RGBM16Encoding: 3005,
    RGBM7Encoding: 3004,
    RGB_ETC1_Format: 36196,
    RGB_ETC2_Format: 37492,
    RGB_PVRTC_2BPPV1_Format: 35841,
    RGB_PVRTC_4BPPV1_Format: 35840,
    RGB_S3TC_DXT1_Format: 33776,
    RGFormat: 1030,
    RGIntegerFormat: 1031,
    RawShaderMaterial: As,
    Ray: V,
    Raycaster: jc,
    RectAreaLight: ja,
    RedFormat: 1028,
    RedIntegerFormat: 1029,
    ReinhardToneMapping: 2,
    RepeatWrapping: 1e3,
    ReplaceStencilOp: 7681,
    ReverseSubtractEquation: 102,
    RingBufferGeometry: ds,
    RingGeometry: us,
    SRGB8_ALPHA8_ASTC_10x10_Format: 37851,
    SRGB8_ALPHA8_ASTC_10x5_Format: 37848,
    SRGB8_ALPHA8_ASTC_10x6_Format: 37849,
    SRGB8_ALPHA8_ASTC_10x8_Format: 37850,
    SRGB8_ALPHA8_ASTC_12x10_Format: 37852,
    SRGB8_ALPHA8_ASTC_12x12_Format: 37853,
    SRGB8_ALPHA8_ASTC_4x4_Format: 37840,
    SRGB8_ALPHA8_ASTC_5x4_Format: 37841,
    SRGB8_ALPHA8_ASTC_5x5_Format: 37842,
    SRGB8_ALPHA8_ASTC_6x5_Format: 37843,
    SRGB8_ALPHA8_ASTC_6x6_Format: 37844,
    SRGB8_ALPHA8_ASTC_8x5_Format: 37845,
    SRGB8_ALPHA8_ASTC_8x6_Format: 37846,
    SRGB8_ALPHA8_ASTC_8x8_Format: 37847,
    Scene: cr,
    SceneUtils: Wl,
    ShaderChunk: $e,
    ShaderLib: en,
    ShaderMaterial: Ge,
    ShadowMaterial: Es,
    Shape: Oa,
    ShapeBufferGeometry: gs,
    ShapeGeometry: ms,
    ShapePath: rc,
    ShapeUtils: ts,
    ShortType: 1011,
    Skeleton: Ir,
    SkeletonHelper: rl,
    SkinnedMesh: Cr,
    SmoothShading: 2,
    Sphere: D,
    SphereBufferGeometry: hs,
    SphereGeometry: ls,
    Spherical: Xc,
    SphericalHarmonics3: Wa,
    Spline: Vl,
    SplineCurve: La,
    SplineCurve3: kl,
    SpotLight: za,
    SpotLightHelper: class extends mt {
      constructor(t, e) {
        super(),
          (this.light = t),
          this.light.updateMatrixWorld(),
          (this.matrix = t.matrixWorld),
          (this.matrixAutoUpdate = !1),
          (this.color = e);
        const n = new le(),
          i = [
            0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0,
            1, 1, 0, 0, 0, 0, -1, 1,
          ];
        for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
          const r = (t / n) * Math.PI * 2,
            o = (e / n) * Math.PI * 2;
          i.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1);
        }
        n.setAttribute("position", new Qt(i, 3));
        const r = new Hr({ fog: !1, toneMapped: !1 });
        (this.cone = new Jr(n, r)), this.add(this.cone), this.update();
      }
      dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose();
      }
      update() {
        this.light.updateMatrixWorld();
        const t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
          tl.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(tl),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      }
    },
    Sprite: Er,
    SpriteMaterial: dr,
    SrcAlphaFactor: 204,
    SrcAlphaSaturateFactor: 210,
    SrcColorFactor: 202,
    StaticCopyUsage: 35046,
    StaticDrawUsage: 35044,
    StaticReadUsage: 35045,
    StereoCamera: mc,
    StreamCopyUsage: 35042,
    StreamDrawUsage: 35040,
    StreamReadUsage: 35041,
    StringKeyframeTrack: Ys,
    SubtractEquation: 101,
    SubtractiveBlending: 3,
    TOUCH: e,
    TangentSpaceNormalMap: 0,
    TetrahedronBufferGeometry: go,
    TetrahedronGeometry: mo,
    TextBufferGeometry: cs,
    TextGeometry: as,
    Texture: u,
    TextureLoader: la,
    TorusBufferGeometry: Lo,
    TorusGeometry: Ao,
    TorusKnotBufferGeometry: Eo,
    TorusKnotGeometry: To,
    Triangle: Pt,
    TriangleFanDrawMode: 2,
    TriangleStripDrawMode: 1,
    TrianglesDrawMode: 0,
    TubeBufferGeometry: So,
    TubeGeometry: Mo,
    UVMapping: 300,
    Uint16Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
        ),
        new Zt(t, e)
      );
    },
    Uint16BufferAttribute: Zt,
    Uint32Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
        ),
        new Kt(t, e)
      );
    },
    Uint32BufferAttribute: Kt,
    Uint8Attribute: function (t, e) {
      return (
        console.warn(
          "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
        ),
        new qt(t, e)
      );
    },
    Uint8BufferAttribute: qt,
    Uint8ClampedAttribute: function (t, e) {
      return (
        console.warn(
          "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
        ),
        new Xt(t, e)
      );
    },
    Uint8ClampedBufferAttribute: Xt,
    Uniform: Hc,
    UniformsLib: tn,
    UniformsUtils: Ue,
    UnsignedByteType: 1009,
    UnsignedInt248Type: 1020,
    UnsignedIntType: 1014,
    UnsignedShort4444Type: 1017,
    UnsignedShort5551Type: 1018,
    UnsignedShort565Type: 1019,
    UnsignedShortType: 1012,
    VSMShadowMap: 3,
    Vector2: s,
    Vector3: g,
    Vector4: d,
    VectorKeyframeTrack: Zs,
    Vertex: function (t, e, n) {
      return (
        console.warn(
          "THREE.Vertex has been removed. Use THREE.Vector3 instead."
        ),
        new g(t, e, n)
      );
    },
    VertexColors: 2,
    VideoTexture: oo,
    WebGL1Renderer: or,
    WebGLCubeRenderTarget: je,
    WebGLMultisampleRenderTarget: f,
    WebGLRenderTarget: p,
    WebGLRenderTargetCube: function (t, e, n) {
      return (
        console.warn(
          "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
        ),
        new je(t, n)
      );
    },
    WebGLRenderer: rr,
    WebGLUtils: Qi,
    WireframeGeometry: lo,
    WireframeHelper: function (t, e) {
      return (
        console.warn(
          "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
        ),
        new Jr(
          new lo(t.geometry),
          new Hr({ color: void 0 !== e ? e : 16777215 })
        )
      );
    },
    WrapAroundEnding: 2402,
    XHRLoader: function (t) {
      return (
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new ia(t)
      );
    },
    ZeroCurvatureEnding: 2400,
    ZeroFactor: 200,
    ZeroSlopeEnding: 2401,
    ZeroStencilOp: 0,
    sRGBEncoding: 3001,
  }),
  Xl = function (n, i) {
    var r, o, a, c, l, h;
    void 0 === i &&
      console.warn(
        'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
      ),
      i === document &&
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        ),
      (this.object = n),
      (this.domElement = i),
      (this.enabled = !0),
      (this.target = new g()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.enableKeys = !0),
      (this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }),
      (this.mouseButtons = { LEFT: t.ROTATE, MIDDLE: t.DOLLY, RIGHT: t.PAN }),
      (this.touches = { ONE: e.ROTATE, TWO: e.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = function () {
        return b.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return b.theta;
      }),
      (this.saveState = function () {
        u.target0.copy(u.target),
          u.position0.copy(u.object.position),
          (u.zoom0 = u.object.zoom);
      }),
      (this.reset = function () {
        u.target.copy(u.target0),
          u.object.position.copy(u.position0),
          (u.object.zoom = u.zoom0),
          u.object.updateProjectionMatrix(),
          u.dispatchEvent(d),
          u.update(),
          (y = v.NONE);
      }),
      (this.update =
        ((r = new g()),
        (o = new m().setFromUnitVectors(n.up, new g(0, 1, 0))),
        (a = o.clone().inverse()),
        (c = new g()),
        (l = new m()),
        (h = 2 * Math.PI),
        function () {
          var t = u.object.position;
          r.copy(t).sub(u.target),
            r.applyQuaternion(o),
            b.setFromVector3(r),
            u.autoRotate &&
              y === v.NONE &&
              D(((2 * Math.PI) / 60 / 60) * u.autoRotateSpeed),
            u.enableDamping
              ? ((b.theta += _.theta * u.dampingFactor),
                (b.phi += _.phi * u.dampingFactor))
              : ((b.theta += _.theta), (b.phi += _.phi));
          var e = u.minAzimuthAngle,
            n = u.maxAzimuthAngle;
          return (
            isFinite(e) &&
              isFinite(n) &&
              (e < -Math.PI ? (e += h) : e > Math.PI && (e -= h),
              n < -Math.PI ? (n += h) : n > Math.PI && (n -= h),
              (b.theta =
                e < n
                  ? Math.max(e, Math.min(n, b.theta))
                  : b.theta > (e + n) / 2
                  ? Math.max(e, b.theta)
                  : Math.min(n, b.theta))),
            (b.phi = Math.max(
              u.minPolarAngle,
              Math.min(u.maxPolarAngle, b.phi)
            )),
            b.makeSafe(),
            (b.radius *= w),
            (b.radius = Math.max(
              u.minDistance,
              Math.min(u.maxDistance, b.radius)
            )),
            !0 === u.enableDamping
              ? u.target.addScaledVector(M, u.dampingFactor)
              : u.target.add(M),
            r.setFromSpherical(b),
            r.applyQuaternion(a),
            t.copy(u.target).add(r),
            u.object.lookAt(u.target),
            !0 === u.enableDamping
              ? ((_.theta *= 1 - u.dampingFactor),
                (_.phi *= 1 - u.dampingFactor),
                M.multiplyScalar(1 - u.dampingFactor))
              : (_.set(0, 0, 0), M.set(0, 0, 0)),
            (w = 1),
            !!(
              S ||
              c.distanceToSquared(u.object.position) > x ||
              8 * (1 - l.dot(u.object.quaternion)) > x
            ) &&
              (u.dispatchEvent(d),
              c.copy(u.object.position),
              l.copy(u.object.quaternion),
              (S = !1),
              !0)
          );
        })),
      (this.dispose = function () {
        u.domElement.removeEventListener("contextmenu", ot, !1),
          u.domElement.removeEventListener("pointerdown", K, !1),
          u.domElement.removeEventListener("wheel", tt, !1),
          u.domElement.removeEventListener("touchstart", nt, !1),
          u.domElement.removeEventListener("touchend", rt, !1),
          u.domElement.removeEventListener("touchmove", it, !1),
          u.domElement.ownerDocument.removeEventListener("pointermove", Q, !1),
          u.domElement.ownerDocument.removeEventListener("pointerup", $, !1),
          u.domElement.removeEventListener("keydown", et, !1);
      });
    var u = this,
      d = { type: "change" },
      p = { type: "start" },
      f = { type: "end" },
      v = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      },
      y = v.NONE,
      x = 1e-6,
      b = new Xc(),
      _ = new Xc(),
      w = 1,
      M = new g(),
      S = !1,
      T = new s(),
      E = new s(),
      A = new s(),
      L = new s(),
      R = new s(),
      P = new s(),
      C = new s(),
      O = new s(),
      N = new s();
    function I() {
      return Math.pow(0.95, u.zoomSpeed);
    }
    function D(t) {
      _.theta -= t;
    }
    function B(t) {
      _.phi -= t;
    }
    var z,
      F =
        ((z = new g()),
        function (t, e) {
          z.setFromMatrixColumn(e, 0), z.multiplyScalar(-t), M.add(z);
        }),
      U = (function () {
        var t = new g();
        return function (e, n) {
          !0 === u.screenSpacePanning
            ? t.setFromMatrixColumn(n, 1)
            : (t.setFromMatrixColumn(n, 0), t.crossVectors(u.object.up, t)),
            t.multiplyScalar(e),
            M.add(t);
        };
      })(),
      G = (function () {
        var t = new g();
        return function (e, n) {
          var i = u.domElement;
          if (u.object.isPerspectiveCamera) {
            var r = u.object.position;
            t.copy(r).sub(u.target);
            var o = t.length();
            (o *= Math.tan(((u.object.fov / 2) * Math.PI) / 180)),
              F((2 * e * o) / i.clientHeight, u.object.matrix),
              U((2 * n * o) / i.clientHeight, u.object.matrix);
          } else
            u.object.isOrthographicCamera
              ? (F(
                  (e * (u.object.right - u.object.left)) /
                    u.object.zoom /
                    i.clientWidth,
                  u.object.matrix
                ),
                U(
                  (n * (u.object.top - u.object.bottom)) /
                    u.object.zoom /
                    i.clientHeight,
                  u.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (u.enablePan = !1));
        };
      })();
    function H(t) {
      u.object.isPerspectiveCamera
        ? (w /= t)
        : u.object.isOrthographicCamera
        ? ((u.object.zoom = Math.max(
            u.minZoom,
            Math.min(u.maxZoom, u.object.zoom * t)
          )),
          u.object.updateProjectionMatrix(),
          (S = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (u.enableZoom = !1));
    }
    function k(t) {
      u.object.isPerspectiveCamera
        ? (w *= t)
        : u.object.isOrthographicCamera
        ? ((u.object.zoom = Math.max(
            u.minZoom,
            Math.min(u.maxZoom, u.object.zoom / t)
          )),
          u.object.updateProjectionMatrix(),
          (S = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (u.enableZoom = !1));
    }
    function V(t) {
      T.set(t.clientX, t.clientY);
    }
    function j(t) {
      L.set(t.clientX, t.clientY);
    }
    function W(t) {
      if (1 == t.touches.length) T.set(t.touches[0].pageX, t.touches[0].pageY);
      else {
        var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY);
        T.set(e, n);
      }
    }
    function q(t) {
      if (1 == t.touches.length) L.set(t.touches[0].pageX, t.touches[0].pageY);
      else {
        var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY);
        L.set(e, n);
      }
    }
    function X(t) {
      var e = t.touches[0].pageX - t.touches[1].pageX,
        n = t.touches[0].pageY - t.touches[1].pageY,
        i = Math.sqrt(e * e + n * n);
      C.set(0, i);
    }
    function Y(t) {
      if (1 == t.touches.length) E.set(t.touches[0].pageX, t.touches[0].pageY);
      else {
        var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY);
        E.set(e, n);
      }
      A.subVectors(E, T).multiplyScalar(u.rotateSpeed);
      var i = u.domElement;
      D((2 * Math.PI * A.x) / i.clientHeight),
        B((2 * Math.PI * A.y) / i.clientHeight),
        T.copy(E);
    }
    function Z(t) {
      if (1 == t.touches.length) R.set(t.touches[0].pageX, t.touches[0].pageY);
      else {
        var e = 0.5 * (t.touches[0].pageX + t.touches[1].pageX),
          n = 0.5 * (t.touches[0].pageY + t.touches[1].pageY);
        R.set(e, n);
      }
      P.subVectors(R, L).multiplyScalar(u.panSpeed), G(P.x, P.y), L.copy(R);
    }
    function J(t) {
      var e = t.touches[0].pageX - t.touches[1].pageX,
        n = t.touches[0].pageY - t.touches[1].pageY,
        i = Math.sqrt(e * e + n * n);
      O.set(0, i),
        N.set(0, Math.pow(O.y / C.y, u.zoomSpeed)),
        H(N.y),
        C.copy(O);
    }
    function K(e) {
      if (!1 !== u.enabled)
        switch (e.pointerType) {
          case "mouse":
            !(function (e) {
              var n;
              switch (
                (e.preventDefault(),
                u.domElement.focus ? u.domElement.focus() : window.focus(),
                e.button)
              ) {
                case 0:
                  n = u.mouseButtons.LEFT;
                  break;
                case 1:
                  n = u.mouseButtons.MIDDLE;
                  break;
                case 2:
                  n = u.mouseButtons.RIGHT;
                  break;
                default:
                  n = -1;
              }
              switch (n) {
                case t.DOLLY:
                  if (!1 === u.enableZoom) return;
                  !(function (t) {
                    C.set(t.clientX, t.clientY);
                  })(e),
                    (y = v.DOLLY);
                  break;
                case t.ROTATE:
                  if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    if (!1 === u.enablePan) return;
                    j(e), (y = v.PAN);
                  } else {
                    if (!1 === u.enableRotate) return;
                    V(e), (y = v.ROTATE);
                  }
                  break;
                case t.PAN:
                  if (e.ctrlKey || e.metaKey || e.shiftKey) {
                    if (!1 === u.enableRotate) return;
                    V(e), (y = v.ROTATE);
                  } else {
                    if (!1 === u.enablePan) return;
                    j(e), (y = v.PAN);
                  }
                  break;
                default:
                  y = v.NONE;
              }
              y !== v.NONE &&
                (u.domElement.ownerDocument.addEventListener(
                  "pointermove",
                  Q,
                  !1
                ),
                u.domElement.ownerDocument.addEventListener("pointerup", $, !1),
                u.dispatchEvent(p));
            })(e);
        }
    }
    function Q(t) {
      if (!1 !== u.enabled)
        switch (t.pointerType) {
          case "mouse":
            !(function (t) {
              if (!1 === u.enabled) return;
              switch ((t.preventDefault(), y)) {
                case v.ROTATE:
                  if (!1 === u.enableRotate) return;
                  !(function (t) {
                    E.set(t.clientX, t.clientY),
                      A.subVectors(E, T).multiplyScalar(u.rotateSpeed);
                    var e = u.domElement;
                    D((2 * Math.PI * A.x) / e.clientHeight),
                      B((2 * Math.PI * A.y) / e.clientHeight),
                      T.copy(E),
                      u.update();
                  })(t);
                  break;
                case v.DOLLY:
                  if (!1 === u.enableZoom) return;
                  !(function (t) {
                    O.set(t.clientX, t.clientY),
                      N.subVectors(O, C),
                      N.y > 0 ? H(I()) : N.y < 0 && k(I()),
                      C.copy(O),
                      u.update();
                  })(t);
                  break;
                case v.PAN:
                  if (!1 === u.enablePan) return;
                  !(function (t) {
                    R.set(t.clientX, t.clientY),
                      P.subVectors(R, L).multiplyScalar(u.panSpeed),
                      G(P.x, P.y),
                      L.copy(R),
                      u.update();
                  })(t);
              }
            })(t);
        }
    }
    function $(t) {
      if (!1 !== u.enabled)
        switch (t.pointerType) {
          case "mouse":
            !(function (t) {
              if (!1 === u.enabled) return;
              u.domElement.ownerDocument.removeEventListener(
                "pointermove",
                Q,
                !1
              ),
                u.domElement.ownerDocument.removeEventListener(
                  "pointerup",
                  $,
                  !1
                ),
                u.dispatchEvent(f),
                (y = v.NONE);
            })();
        }
    }
    function tt(t) {
      !1 === u.enabled ||
        !1 === u.enableZoom ||
        (y !== v.NONE && y !== v.ROTATE) ||
        (t.preventDefault(),
        t.stopPropagation(),
        u.dispatchEvent(p),
        (function (t) {
          t.deltaY < 0 ? k(I()) : t.deltaY > 0 && H(I()), u.update();
        })(t),
        u.dispatchEvent(f));
    }
    function et(t) {
      !1 !== u.enabled &&
        !1 !== u.enableKeys &&
        !1 !== u.enablePan &&
        (function (t) {
          var e = !1;
          switch (t.keyCode) {
            case u.keys.UP:
              G(0, u.keyPanSpeed), (e = !0);
              break;
            case u.keys.BOTTOM:
              G(0, -u.keyPanSpeed), (e = !0);
              break;
            case u.keys.LEFT:
              G(u.keyPanSpeed, 0), (e = !0);
              break;
            case u.keys.RIGHT:
              G(-u.keyPanSpeed, 0), (e = !0);
          }
          e && (t.preventDefault(), u.update());
        })(t);
    }
    function nt(t) {
      if (!1 !== u.enabled) {
        switch ((t.preventDefault(), t.touches.length)) {
          case 1:
            switch (u.touches.ONE) {
              case e.ROTATE:
                if (!1 === u.enableRotate) return;
                W(t), (y = v.TOUCH_ROTATE);
                break;
              case e.PAN:
                if (!1 === u.enablePan) return;
                q(t), (y = v.TOUCH_PAN);
                break;
              default:
                y = v.NONE;
            }
            break;
          case 2:
            switch (u.touches.TWO) {
              case e.DOLLY_PAN:
                if (!1 === u.enableZoom && !1 === u.enablePan) return;
                !(function (t) {
                  u.enableZoom && X(t), u.enablePan && q(t);
                })(t),
                  (y = v.TOUCH_DOLLY_PAN);
                break;
              case e.DOLLY_ROTATE:
                if (!1 === u.enableZoom && !1 === u.enableRotate) return;
                !(function (t) {
                  u.enableZoom && X(t), u.enableRotate && W(t);
                })(t),
                  (y = v.TOUCH_DOLLY_ROTATE);
                break;
              default:
                y = v.NONE;
            }
            break;
          default:
            y = v.NONE;
        }
        y !== v.NONE && u.dispatchEvent(p);
      }
    }
    function it(t) {
      if (!1 !== u.enabled)
        switch ((t.preventDefault(), t.stopPropagation(), y)) {
          case v.TOUCH_ROTATE:
            if (!1 === u.enableRotate) return;
            Y(t), u.update();
            break;
          case v.TOUCH_PAN:
            if (!1 === u.enablePan) return;
            Z(t), u.update();
            break;
          case v.TOUCH_DOLLY_PAN:
            if (!1 === u.enableZoom && !1 === u.enablePan) return;
            !(function (t) {
              u.enableZoom && J(t), u.enablePan && Z(t);
            })(t),
              u.update();
            break;
          case v.TOUCH_DOLLY_ROTATE:
            if (!1 === u.enableZoom && !1 === u.enableRotate) return;
            !(function (t) {
              u.enableZoom && J(t), u.enableRotate && Y(t);
            })(t),
              u.update();
            break;
          default:
            y = v.NONE;
        }
    }
    function rt(t) {
      !1 !== u.enabled && (u.dispatchEvent(f), (y = v.NONE));
    }
    function ot(t) {
      !1 !== u.enabled && t.preventDefault();
    }
    u.domElement.addEventListener("contextmenu", ot, !1),
      u.domElement.addEventListener("pointerdown", K, !1),
      u.domElement.addEventListener("wheel", tt, !1),
      u.domElement.addEventListener("touchstart", nt, !1),
      u.domElement.addEventListener("touchend", rt, !1),
      u.domElement.addEventListener("touchmove", it, !1),
      u.domElement.addEventListener("keydown", et, !1),
      -1 === u.domElement.tabIndex && (u.domElement.tabIndex = 0),
      this.update();
  };
(Xl.prototype = Object.create(n.prototype)).constructor = Xl;
var Yl = function (n, i) {
  Xl.call(this, n, i),
    (this.screenSpacePanning = !1),
    (this.mouseButtons.LEFT = t.PAN),
    (this.mouseButtons.RIGHT = t.ROTATE),
    (this.touches.ONE = e.PAN),
    (this.touches.TWO = e.DOLLY_ROTATE);
};
(Yl.prototype = Object.create(n.prototype)).constructor = Yl;
export { Xl as OrbitControls, ql as THREE };
